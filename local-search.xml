<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>论文笔记：MonetDB/X100: Hyper-Pipelining Query Execution</title>
    <link href="/2023/07/22/paper-reading-monetdb/"/>
    <url>/2023/07/22/paper-reading-monetdb/</url>
    
    <content type="html"><![CDATA[<p>“MonetDB&#x2F;X100: Hyper-Pipelining Query Execution” 是一篇在 2005 年 CIDR 会议上发表的颇具影响力的论文，如今在 Google 上的引用量已超过860次。这篇论文主要展示了现代超标量 CPU 的运行机制，并对当时市场上主流的数据库系统在超标量 CPU 上的运行表现进行了深入的分析与实证测试。测试结果表明，市面上的主流数据库系统均未能在运行过程中充分挖掘并发挥出超标量 CPU 的全部性能潜力。正因为这个发现，作者在 MonetDB 的基础上设计并实现了一个全新的查询引擎，名为 X100。这个新型查询引擎的设计目标是为了让其能够充分利用超标量处理器的性能，从而减少每个操作在运行过程中的 CPU Cycle 数。</p><p>论文的原文地址为：<a href="https://15721.courses.cs.cmu.edu/spring2020/papers/13-execution/boncz-cidr2005.pdf">MonetDB&#x2F;X100: Hyper-Pipelining Query Execution</a>。</p><h1 id="CPU-是如何工作的"><a href="#CPU-是如何工作的" class="headerlink" title="CPU 是如何工作的"></a>CPU 是如何工作的</h1><p>经过过去几十年的发展，CPU 已经成了一个非常复杂的器件。同样一个 CPU，高效运行和低效运行之间的性能可能有数量级的差别。下面这张图展示了过去 CPU 的发展趋势<br><img src="/2023/07/22/paper-reading-monetdb/cpu-performance.png"><br>这张图是论文里的附图，上面的内容比较旧，但是我们仍然可以从中看到一些 CPU 发展的趋势。CPU 的制造工艺每隔 18 个月就缩小 1.4 倍（面积上则是 2 倍），这是 CPU 频率提升的根本原因。晶体管的大小缩小了之后，CPU 的延迟也就更低了（因为电信号传输的距离缩短了）。理论上 CPU 频率应该和延迟的倒数成正比，也就是和制程的倒数成正比，但是从上图中我们可以发现 CPU 频率的提升比制程的提升更快。这是因为 CPU 采用了流水线机制，该机制将单个指令拆分成多个阶段（stage），每个阶段需要做的工作都比一个完整的指令更少。每个阶段需要做的工作更少，也就意味着完成工作的时间更少，CPU 的频率也就越高。1988 年的 Intel 80386 CPU 每个 cycle 只完成一条指令，1993 年的 Pentium 有 5 阶段的流水线，到了 2004 年 Pentium 4 已经有 31 阶段的流水线。当然 CPU 流水线的级数并不是越高越好，我们后面会解释。到 2023 年，AMD 最新的 Zen4 架构处理器的流水线级数大约为 13-15 级（参考<a href="https://zhuanlan.zhihu.com/p/568419115">Edison Chen：AMD Zen 4 微架构深入测试报告</a>），Intel 最新的 Raptor Cove 架构处理器的流水线级数为 12 级（参考<a href="https://en.wikipedia.org/wiki/List_of_Intel_CPU_microarchitectures">Wikipedia: List of Intel CPU microarchitectures</a>）。</p><p>然而，流水线技术也带来了两个问题：</p><ol><li>如果一个指令依赖于前序指令执行的结果，那么这个指令等待前一个指令执行完成后才能执行，这会造成流水线阻塞；</li><li>如果遇到了一个 IF-a-THEN-b-ELSE-c 这样的分支，CPU 必须预测 a 到底是 true 还是 false，然后选择一条路径执行。例如 CPU 猜测 a 是 false，然后将 c 加入到流水线中 a 的位置之后进行执行。假如执行完了 a，发现 a 的结果是 true，也就是 CPU 的分支预测出现了错误，那么就必须将流水线清洗（flush），然后重新执行 b。</li></ol><p>从第二个问题我们不难发现为什么流水线不是越长越好，越长的流水线在分支预测错误时被 flush 掉的损失就越大。一个 5 阶段的流水线被清洗了之后只会浪费掉 5 个 cycle，而一个 31 阶段的流水线在被清洗了以后则会浪费 31 个 cycle。对于数据库来说，分支条件通常是和数据有关的。例如一个 Filter 需要判断条件真假以过滤数据，条件通常是和数据有关的。如果条件为真的概率非常大或者非常小，那么对于 CPU 来说都会很好做分支预测。对于 CPU 来说，那些条件概率不高不低的情况对分支预测并不友好，也会带来很大的性能损失。</p><p>现代的 CPU 通常还使用了超标量技术。超标量 CPU 拥有多条独立的流水线，它们可以各自执行自己的指令。在每个 cycle 中，只要指令之间是互相独立的，每条流水线都会执行一条新的指令。因此，一个超标量 CPU 可以获得大于 1 的 IPC（Instructions Per Cycle）。所以在上面那张 CPU 发展图中，我们可以看到 CPU 的性能提升比频率的提升还要快。</p><p>现代 CPU 可以在不同的方面进行平衡。例如 Intel Itanium 2 是一个 VLIW（Very Large Instruction Word）的处理器，它拥有 6 条流水线，每条流水线的只有 7 级，所以它的频率也只有 1.5 GHz。Pentium 4 只有 3 条流水线，但是每条流水线有 31 级，频率也有 3.6 GHz。我们可以计算出，在任意时刻，Itanium2 需要程序有 $7 \times 6 &#x3D; 42$ 条独立的指令才能发挥出其最大性能，而 Pentium 4 则需要 $3 \times 31 &#x3D; 93$ 条独立的指令才能发挥出最大性能。这么多独立的指令是很难找出来的，大部分程序只能充分利用 Itanium 2 的并发能力，因此，尽管两者的频率差距较大，但在 benchmark 上，他们的性能相差不大。</p><p>大多数编程语言并不强制要求程序员明确指出指令间的独立性，这些任务通常由编译器自动完成。在编译器的众多优化技术中，循环流水线（loop pipelining）尤为重要。例如有两个操作，<code>F()</code> 和 <code>G()</code>，后者依赖于前者的执行结果。假如在数组 $A$ 中有 $n$ 个元素，需要对每一个元素都执行 <code>F()</code> 和 <code>G()</code>，那么指令的顺序就是</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">F</span><span class="hljs-params">(A[<span class="hljs-number">0</span>])</span></span>, <span class="hljs-built_in">G</span>(A<span class="hljs-selector-attr">[0]</span>), <span class="hljs-built_in">F</span>(A<span class="hljs-selector-attr">[1]</span>), <span class="hljs-built_in">G</span>(A<span class="hljs-selector-attr">[1]</span>), ... <span class="hljs-built_in">F</span>(A<span class="hljs-selector-attr">[n]</span>), <span class="hljs-built_in">G</span>(A<span class="hljs-selector-attr">[n]</span>)<br></code></pre></td></tr></table></figure><p>假设 <code>F()</code> 需要两个 cycle 来执行，那么我们可以在 <code>F(A[i])</code>  和 <code>G(A[i])</code> 之间插入两个无关的指令，充分利用上这两个周期的延迟，使得指令的顺序变成</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">F</span><span class="hljs-params">(A[<span class="hljs-number">0</span>])</span></span>, <span class="hljs-built_in">F</span>(A<span class="hljs-selector-attr">[1]</span>), <span class="hljs-built_in">F</span>(A<span class="hljs-selector-attr">[2]</span>), <span class="hljs-built_in">G</span>(A<span class="hljs-selector-attr">[0]</span>), <span class="hljs-built_in">G</span>(A<span class="hljs-selector-attr">[1]</span>), <span class="hljs-built_in">G</span>(A<span class="hljs-selector-attr">[2]</span>), <span class="hljs-built_in">F</span>(A<span class="hljs-selector-attr">[3]</span>) ...<br></code></pre></td></tr></table></figure><p><img src="/2023/07/22/paper-reading-monetdb/branch-mispredication.png"></p><p>上面这张图是作者做的一个实验，模拟一个 Filter 对数据进行过滤，并统计运行的时间。作者用同样的逻辑实现了两种代码，一种包含分支，另一种则无。结果表明，对于包含分支的代码，类似 AthlonMP 的 CPU 在选择率为 50% 左右时性能最差，这是因为此时 CPU 的分支预测错误率最高；然而，Itanium 2 的性能基本上不受选择率变动的影响，原因是编译器能将分支转化为硬件谓词化代码（hardware-predicated code）。对于没有分支的代码，即使是 AthlonMP 也不会受到选择率的影响，但是平均的运行时间却更长了。</p><p>最后要讲的一部分是 CPU 缓存。在 CPU 运行程序时，大约有 30% 的操作是对内存的 load 或者 store。因为内存与 CPU 是分开的，且通常在主板上的位置离 CPU 较远，访问内存的时间通常需要大约 50 ns。对于一个 3.6 GHz 的 CPU 来说，50 ns 代表这个 CPU 需要等待 180 个 cycle。只有当 CPU 需要访问的大部分数据都在缓存上的时候，CPU 才有可能发挥出最大的性能。有一些数据库研究者也提出了一些对缓存友好的数据结构，例如缓存对齐的 B 树（cached-aligned B-trees）、列式数据布局 PAX 等。</p><p>总的来说，由于现代 CPU 已经变得极度复杂，同样的 CPU 在运行不同程序时，由于各种因素，如缓存命中率、分支数量、分支预测准确率、无关指令数量等，性能可能相差数个数量级。研究表明，在执行查询时，一般的商用数据库的每周期指令数（IPC）只有 0.7，低于 1。然而，在科学计算这类场景中，IPC 可以达到 2 或更高。因此，作者想要改变数据库架构以充分利用编译器和 CPU 的优化和性能，提升查询的吞吐。</p><p>最后，关于 CPU 的介绍，我想推荐一篇非常不错的博客<a href="https://www.lighterra.com/papers/modernmicroprocessors/">Modern Microprocessors A 90-Minute Guide</a>，里面介绍了包括流水线、多发射、分支预测、超线程等现代 CPU 使用的技术，对理解 CPU 运行原理以及写出更好的代码有很大的帮助。</p><h1 id="对主流数据库的测试与讨论"><a href="#对主流数据库的测试与讨论" class="headerlink" title="对主流数据库的测试与讨论"></a>对主流数据库的测试与讨论</h1><h2 id="测试查询语句"><a href="#测试查询语句" class="headerlink" title="测试查询语句"></a>测试查询语句</h2><p>论文关注查询执行的效率，但是为了简化，先关注表达式计算的效率，而不考虑更加复杂的操作（例如 join）。作者选择 TPC-H 的 Query 1 作为测试的基准，查询如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">SELECT</span> l_returnflag, l_linestatus,<br>       <span class="hljs-built_in">sum</span>(l_quantity) <span class="hljs-keyword">AS</span> sum_qty,<br>       <span class="hljs-built_in">sum</span>(l_extendedprice) <span class="hljs-keyword">AS</span> sum_base_price,<br>       <span class="hljs-built_in">sum</span>(l_extendedprice <span class="hljs-operator">*</span> (<span class="hljs-number">1</span> <span class="hljs-operator">-</span> l_discount))<br>          <span class="hljs-keyword">AS</span> sum_disc_price,<br>       <span class="hljs-built_in">sum</span>(l_extendedprice <span class="hljs-operator">*</span> (<span class="hljs-number">1</span> <span class="hljs-operator">-</span> l_discount) <span class="hljs-operator">*</span><br>       (<span class="hljs-number">1</span> <span class="hljs-operator">+</span> l_tax)) <span class="hljs-keyword">AS</span> sum_charge,<br>       <span class="hljs-built_in">avg</span>(l_quantity) <span class="hljs-keyword">AS</span> avg_qty,<br>       <span class="hljs-built_in">avg</span>(l_extendedprice) <span class="hljs-keyword">AS</span> avg_price,<br>       <span class="hljs-built_in">avg</span>(l_discount) <span class="hljs-keyword">AS</span> avg_disc,<br>       <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">AS</span> count_order<br><span class="hljs-keyword">FROM</span> lineitem<br><span class="hljs-keyword">WHERE</span> l_shipdate <span class="hljs-operator">&lt;=</span> <span class="hljs-type">date</span> <span class="hljs-string">&#x27;1998-09-02&#x27;</span><br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> l_returnflag, l_linestatus<br></code></pre></td></tr></table></figure><p>可以看到这个查询非常简单，从一个 lineitem 表中读出数据，经过过滤后进行一系列聚合函数的计算，然后进行分组，就得到了查询的结果。执行这个查询不需要任何对 join 的优化或者复杂的实现，因此执行这个查询能够体现不同数据库计算表达式的效率。<br>TPC-H 基准测试在一个 1GB 的数据集上运行，其大小可以通过一个比例因子（SF）调整。Query 1 对有 $\text{SF} \times \text{6M}$ 行记录的 lineitem 表的扫描，选择几乎所有的元组（$\text{SF} \times \text{5.9M}$），并计算一些定点数表达式：两个列与常数的减法，一个列与常数的加法，三个列与列的乘法，以及八个聚合函数。聚合的结果对两个单字符列进行分组，并只产生 4 个组合，因此聚合可以用一个小哈希表高效地执行，不需要额外的 IO，甚至不会造成 CPU 缓存未命中。</p><h2 id="关系数据库上的查询"><a href="#关系数据库上的查询" class="headerlink" title="关系数据库上的查询"></a>关系数据库上的查询</h2><p>在关系数据库中，查询执行通常是实现物理关系代数来实现的，大部分数据库都使用了火山（Volcano）模型。由于 SQL 语句非常灵活，数据库需要实现一个可以处理任意复杂度的表达式的表达式解释器。使用火山模型实现这种解释器的 CPU 效率并不高，特别是使用 tuple-at-a-time 的处理方式时，真正用于计算的时间其实只占查询总执行时间的小部分。例如，下面这张表显示了在 MySQL 4.1 中执行 Query-1 时使用 gprof 进行跟踪的结果，第一列是第二列的累计总和，第三列列出了函数被调用的次数，而第四和第五列显示了每次调用执行的平均指令数以及达到的IPC。<br><img src="/2023/07/22/paper-reading-monetdb/mysql-q1-result.png"></p><p>首先观察不同部分的耗时占比。粗体的五个部分代表了真正执行计算的部分，它们只占总执行时间的 10%。剩下的时间中，其中 28% 用于哈希表的创建和查找，剩下的 62% 分散在 <code>rec_get_nth_field</code> 这样的函数上，这些函数在 MySQL 的数据行中找到某个 Field 并复制数据。其他的像锁开销（<code>pthread_mutex_unlock</code>，<code>mutex_test_and_set</code>）或者缓冲区内存的申请（<code>buf_frame_align</code>）的开销非常小。</p><p>然后观察真正执行计算部分的开销，这些部分都是以 Item 开头的部分。例如 <code>Item_func_plus::val</code> 每次计算一个加法，需要 38 个指令。测试是在 MIPS R12000 CPU 上进行的，理论上每个周期可以完成三个整数或浮点数的操作指令或者一个 load&#x2F;store 指令，每个操作大约需要 5 个 cycle 来完成。在 RISC 中实现对 double 的加法操作 <code>+(double src1, double src2) : double</code> 大致如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ASM">LOAD src1, reg1<br>LOAD src2, reg2<br>ADD reg1, reg2, reg3<br>STOR dst, reg3<br></code></pre></td></tr></table></figure><p>MIPS 处理器应该可以在 3 个周期内完成对浮点数的加法，这和 MySQL 中使用 38&#x2F;0.8 &#x3D; 49 个 cycle 完成计算的差别很大。一种可能的解释是，由于 MySQL 使用了 tuple-at-a-time 的处理方式，导致编译器进行 loop-pipelining 的优化，有依赖关系的指令只能等待前序指令执行完后再执行。但是前面提到一个指令的运行时间是 5 个 cycle，这样也只占了其中的 20 个 cycle。剩下的 29 个 cycle 主要用于指令跳转、压栈和出栈（也就是函数调用的开销）。因此，MySQL 使用 tuple-at-a-time 处理方式的后果有两个：</p><ol><li><code>Item_func_plus::val</code> 只执行一次加法，阻止了编译器进行循环流水线优化。由于指令之间有依赖关系，必须生成空的流水线槽（stalls）来等待前面的指令执行结束，这样计算的时间就变为 20 个 cycle 而不是 3 个 cycle。</li><li>函数的调用开销只能在一个 tuple 上分摊，这使得一个加法计算的成分大大增加，甚至比加法本身的代价还要高。</li></ol><p>作者还在一个商用数据库（DBMS “X”）上进行了测试，如下表，测试的结果表明执行代价跟 MySQL 差不多。此外，表中还包含了从 TPC-H 官方测试结果中找到的数据，并且把所有的测试结果归一化到 SF&#x3D;1 和单 CPU 的情况。由于测试测试条件的不同，作者还加上了测试所用 CPU 的 SPEC 分数，方便对比不同系统的表现。<br><img src="/2023/07/22/paper-reading-monetdb/query-1-performance.png" alt="Query-1 测试结果"></p><h2 id="在-MonetDB-x2F-MIL-上测试-Query-1"><a href="#在-MonetDB-x2F-MIL-上测试-Query-1" class="headerlink" title="在 MonetDB&#x2F;MIL 上测试 Query 1"></a>在 MonetDB&#x2F;MIL 上测试 Query 1</h2><p>MonetDB 是一个使用垂直分片、列式存储的数据库，每一列使用一个包含 <code>[oid, value]</code> 的二元关联表（Binary Association Table, BAT）来表示。BAT 的左列被称为 head，右列被称为 tail。</p><p>用于在 MonetDB 中进行查询的语言被称为 MIL，它是一种列代数（column-algebra）语言。与关系代数相比，MIL 的灵活性较低。MIL 的每个操作符都有固定数目和形状的输入参数，输出的数目和形状也是固定的。例如 $join(\text{BAT}[t_l, t_e] A, \text{BAT}[t_e, t_r] B) : \text{BAT}[t_l, t_r]$ 是一个对 A 的 tail 和 B 的 head 的等值 join，对于能够 join 上的 tuple，返回 A 的 head 和 B 的 tail。如果想要让 A 的 head 和 B 的 head 做等值 join，就需要先用 $reverse$ 操作符来调换 A 的 head 和 tail。对于复杂的操作，则需要使用多个语句来组合。</p><p>作者将 Query-1 转化为 MIL 在 MonetDB 上进行测试，结果如下：<br><img src="/2023/07/22/paper-reading-monetdb/MonetDB-MIL-result.png"><br>MonetDB&#x2F;MIL 的性能比 MySQL 和 DBMS X 更快，但是通过深入观察可以发现，MIL 运算符的性能主要受内存限制，而不是 CPU。例如，如果我们将 SF（缩放因子）设置为 0.001，生成的 lineitem 表的所有列以及计算中间结果都可以放在 CPU 缓存中，这可以减少对内存的访问，使 MonetDB&#x2F;MIL 的速度几乎加倍。同时，表中还列出了每个算子的带宽。多路复用的乘法操作 <a href="">*</a> 的带宽只有 500 MB&#x2F;s，这意味着它每秒只能处理 2000w 个 tuple（每次处理的输入为 16 字节，输出为 8 字节）。在一个频率为 1533 MHz 的 CPU 上，每次乘法操作需要消耗 75 个周期，这比 MySQL 的表现还要差。</p><p>作者仔细分析了这一现象，并认为 MIL 在计算时中间结果的物化占用了大量的内存。例如，计算 <code>sum(l_extendedprice * (1 - l_discount))</code> ，需要先计算 <code>1 - l_discount</code>，然后将结果物化到内存中；再计算 <code>l_extendedprice * (1 - l_discount)</code>，然后将结果物化到内存中，最后才去计算 sum。最后输出的结果 sum 在两个单字符列上做了 group by，和中间结果的大小相比非常非常小。作者认为这些中间物化占用了大量的内存带宽。</p><p>此外，由于 MonetDB 使用了列式存储，每一列属性都是单独存放的。当我们对 l_shipdate 列应用条件 l_shipdate &lt;&#x3D; date ‘1998-09-02’ 进行过滤时，要使其他列也遵守这个条件，所以需要让同一个表中的其他列与 l_shipdate 列做 join。这个步骤也会消耗很多内存带宽，然而在 Volcano-like 的执行模型中却不需要这个步骤（因为使用了行存，一行数据的所有属性都放在了一起，当谓词过滤时一个行直接就被丢掉了，不需要再去 join）。</p><h2 id="Query-1-的最优性能"><a href="#Query-1-的最优性能" class="headerlink" title="Query 1 的最优性能"></a>Query 1 的最优性能</h2><p>为了知道现代硬件在执行 Query 1 时的极限性能，作者以 UDF 的方式在 MonetDB 中实现了这个查询，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">tpch_query1</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> hi_date,</span><br><span class="hljs-params">  <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>*__restrict__ p_returnflag,</span><br><span class="hljs-params">  <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>*__restrict__ p_linestatus,</span><br><span class="hljs-params">  <span class="hljs-type">double</span>*__restrict__ p_quantity,</span><br><span class="hljs-params">  <span class="hljs-type">double</span>*__restrict__ p_extendedprice,</span><br><span class="hljs-params">  <span class="hljs-type">double</span>*__restrict__ p_discount,</span><br><span class="hljs-params">  <span class="hljs-type">double</span>*__restrict__ p_tax,</span><br><span class="hljs-params">  <span class="hljs-type">int</span>*__restrict__ p_shipdate,</span><br><span class="hljs-params">  aggr_t1*__restrict__ hashtab)</span><br>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++) &#123;<br>  <span class="hljs-keyword">if</span> (p_shipdate[i] &lt;= hi_date) &#123;<br>    aggr_t1 *entry = hashtab +<br>      (p_returnflag[i]&lt;&lt;<span class="hljs-number">8</span>) + p_linestatus[i];<br>    <span class="hljs-type">double</span> discount = p_discount[i];<br>    <span class="hljs-type">double</span> extprice = p_extendedprice[i];<br>    entry-&gt;count++;<br>    entry-&gt;sum_qty += p_quantity[i];<br>    entry-&gt;sum_disc += discount;<br>    entry-&gt;sum_base_price += extprice;<br>    entry-&gt;sum_disc_price += (extprice *= (<span class="hljs-number">1</span>-discount));<br>    entry-&gt;sum_charge += extprice*(<span class="hljs-number">1</span>-p_tax[i]);<br>&#125;&#125;&#125;<br></code></pre></td></tr></table></figure><p>BAT 以数组的形式传递给函数，并使用 <strong>restrict</strong> 指针来标记，这样 C 编译器会知道这些数组间没有重叠，从而可以采用循环流水线优化。前文测试结果的表中显示了 UDF 的性能，查询只需要 0.22 秒就能完成。同样在性能测试的结果中，X100 查询引擎实现的性能和手写代码的差距在两倍以内。下面将介绍 X100 查询引擎。</p><h1 id="X100：一个向量化的查询处理器"><a href="#X100：一个向量化的查询处理器" class="headerlink" title="X100：一个向量化的查询处理器"></a>X100：一个向量化的查询处理器</h1><p>X100 的目标是</p><ol><li>高效地在 CPU 上执行大数据查询</li><li>可以在其他应用领域（如数据挖掘和多媒体检索）上扩展，并在扩展代码上实现相同的高效率</li><li>在最底层存储（例如磁盘）上实现拓展</li></ol><p><img src="/2023/07/22/paper-reading-monetdb/X100-arch.png"></p><p>X100 的每个子系统如下：</p><ul><li><strong>磁盘</strong>：为了更高效地访问数据并且减少 IO 带宽需求，数据被垂直分片，并且在某些情况下使用了轻量的压缩。</li><li><strong>内存</strong>：内存与缓存的数据交换是通过显式的 memory-to-cache 和 cache-to-memory 过程来实现的，在这些过程中实现了特定的优化，包括 SSE 预取（prefetching）和使用汇编指令来移动数据。此外，数据在内存中也进行了垂直分片和压缩，以节省内存带宽。</li><li><strong>缓存</strong>： 查询执行模型使用类似于火山模型的向量化（vectorized）处理模型，小的数据块（例如 1000 个 value）被称为向量，是 X100 操作的基本单位，它可以驻留在缓存中。X100 查询处理器是缓存感知的（cache-conscious），可以将大的数据块分割成小的数据块，以可以保存在缓存里，并在缓存中进行随机访问。</li><li><strong>CPU</strong>：X100 的实现向编译器暴露了向量化原语(primitives)，对每个 tuple 的处理都是独立的。向量化对于某些操作（如投影）来说，实现相对容易。但对于其他一些操作（如聚集函数），则需要付出更多的努力。为了减少指令中 load&#x2F;store 的数量，X100 会尝试将一个表达式子树而不是单个算子编译成向量化的形式。</li></ul><h2 id="X100-的查询语言"><a href="#X100-的查询语言" class="headerlink" title="X100 的查询语言"></a>X100 的查询语言</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs SQL">Aggr(<br>  Project(<br>    <span class="hljs-keyword">Select</span>(<br>      <span class="hljs-keyword">Table</span>(lineitem),<br>      <span class="hljs-operator">&lt;</span>  (shipdate,  <span class="hljs-type">date</span>(’<span class="hljs-number">1998</span><span class="hljs-number">-09</span><span class="hljs-number">-03</span>’))),<br>    [  discountprice  <span class="hljs-operator">=</span>  <span class="hljs-operator">*</span>(  <span class="hljs-operator">-</span>(  flt(’<span class="hljs-number">1.0</span>’),  discount),<br>                            extendedprice)  ]),<br>[  returnflag  ],<br>[  sum_disc_price  <span class="hljs-operator">=</span>  <span class="hljs-built_in">sum</span>(discountprice)  ])<br></code></pre></td></tr></table></figure><p>上述代码展示的是使用 X100 查询语言重写的 Query-1。在执行时，Scan 算子会从 Monet BAT 中检索数据，并包装成向量的形式。Select 算子会对数据进行过滤，它不会产生新的向量，而是会生成一个 <em>selection-vector</em>，用于表示向量中的哪些位上的 value 是符合条件的。然后 Project 算子计算出哪些属性是最后聚合所需要的，然后 Aggr 使用输入的向量和 <em>selection-vector</em> 来计算聚合值。</p><h2 id="X100-的向量化原语"><a href="#X100-的向量化原语" class="headerlink" title="X100 的向量化原语"></a>X100 的向量化原语</h2><p>X100 之所以使用列式的向量布局，并不是出于优化内存布局的考虑，而是因为其低自由度的优点（参考前面对 MIL 的讨论）。在一个垂直分片的数据模型中，执行原语只知道它们执行的列而不需要知道整个表的布局（比如某个 field 在每个 record 中的 offset）。在编译时，C 编译器知道 X100 向量化原语只会在固定形状、互相不相关的数组上进行操作，因此就可以使用激进的循环流水线优化。例如，下面是一个向量化浮点数相加的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c">map_plus_double_col_double_col(<span class="hljs-type">int</span> n,<br>  <span class="hljs-type">double</span>*__restrict__ res,<br>  <span class="hljs-type">double</span>*__restrict__ col1, <span class="hljs-type">double</span>*__restrict__ col2,<br>  <span class="hljs-type">int</span>*__restrict__ sel)<br>&#123;<br>  <span class="hljs-keyword">if</span> (sel) &#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n; j++) &#123;<br>      <span class="hljs-type">int</span> i = sel[j];<br>      res[i] = col1[i] + col2[i];<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n; i++)<br>      res[i] = col1[i] + col2[i];<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><em>sel</em> 可能为 NULL，代表这两个向量没有做任何过滤。X100 的所有向量化原语都传递了这样的 selection-vector，这是因为在 selection 之后，保持子操作符输入的向量不变比复制它们的数据然后生成一个新的向量要快得多。</p><p>在 X100 中有上百个向量化原语，这些都不是手动写的，而是从原语模板（<em>primitive patterns</em>）中生成的。例如加法的模板是</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">any::<span class="hljs-number">1</span> +(any::<span class="hljs-number">1</span> x, any::<span class="hljs-number">1</span> y) plus = x + y<br></code></pre></td></tr></table></figure><p>此模板意味着，对于任何类型的加法运算，都可以使用 C 语言的 ‘+’ 运算符来实现。</p><p>还有一种原语的生成是通过映射签名请求（<em>map signature requests</em>）。例如：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">+(<span class="hljs-built_in">double</span>*, <span class="hljs-built_in">double</span>*)<br>+(<span class="hljs-built_in">double</span>, <span class="hljs-built_in">double</span>*)<br>+(<span class="hljs-built_in">double</span>*, <span class="hljs-built_in">double</span>)<br>+(<span class="hljs-built_in">double</span>, <span class="hljs-built_in">double</span>)<br></code></pre></td></tr></table></figure><p>这样的请求将生成所有可能的单值与列值之间的加法组合。此外，还可以将多个操作生成在一个函数中，例如</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">/(square(-(<span class="hljs-built_in">double</span>*, <span class="hljs-built_in">double</span>*)), <span class="hljs-built_in">double</span>*)<br></code></pre></td></tr></table></figure><p>它代表了马氏距离的计算过程，这在多媒体检索任务中是一个非常关键的操作。作者的实验发现，组合向量化算子的性能大约是单个算子性能的两倍。造成这种现象的主要原因是计算的瓶颈通常是访存，将多个操作打包到一个函数中，只需要一次访存就可以进行多次操作，一个操作的结果可以放在寄存器中作为下一个操作的输入，减少了访存的次数，从而提高了性能。</p><h2 id="数据布局"><a href="#数据布局" class="headerlink" title="数据布局"></a>数据布局</h2><p><img src="/2023/07/22/paper-reading-monetdb/storage-layout.png"><br>MonetDB&#x2F;X100 将所有表垂直分片存储后，通过ColumnBM将每个数据文件分割成较大的数据块（大于 1MB）。列式存储的一个缺点是，更新或删除数据时较为困难，因为需要读出整个列，修改后再写回磁盘。MonetDB&#x2F;X100 把列存片段当做是不变对象（immutable object），更新通过增加一个 delta structure，在 delta structure 里记录更新的数据，删除则通过维护一个 deletion list，指明列存中哪些数据已经被删除了来实现。这样做的好处就是 update 和 delete 都只需要进行一次 IO，而不用把整个列都读进来再写出去。当 delta structure 的大小超过了限制，MonetDB 就会把 delta structure 和列存数据读进内存里进行整理，然后重新写到磁盘上。<br>对列式存储的数据，MonetDB 还会进行轻量的压缩，以减少 IO 以及内存的使用量。同时，MonetDB 还会维护一个 summary，里面记录了列存片段的统计信息，例如最大最小值等等，以方便运行时 Scan 算子通过 summary 判断这些数据需不需要被读进来（例如需要查找 a &gt; 100 的数据，而某个片段的 max 为 99，那么显然就不需要读这个片段）。</p><h1 id="TPC-H-性能实验"><a href="#TPC-H-性能实验" class="headerlink" title="TPC-H 性能实验"></a>TPC-H 性能实验</h1><h2 id="性能测试结果"><a href="#性能测试结果" class="headerlink" title="性能测试结果"></a>性能测试结果</h2><p><img src="/2023/07/22/paper-reading-monetdb/X-100-performance.png"><br>上图展示了 MonetDB&#x2F;X100 与 MonetDB&#x2F;MIL 和 DB2 的性能对比结果，第一和第二列的结果对比清楚地表明，MonetDB&#x2F;X100的性能超过了MonetDB&#x2F;MIL 和 DB2。<br><img src="/2023/07/22/paper-reading-monetdb/X100-detail.png"><br>这张图揭示了 MonetDB&#x2F;X100 在运行 Query 1 时的性能表现，可以看到 X100 能够用非常低 cycle 数运行所有原语，相对复杂的原语比如聚合也只需要对每个元组也只需要 6 个 cycle。对每个元组做乘法只需要 2.2 个 cycle，这比 MySQL 的 49 cycle 要好得多。</p><p>由于被原语处理的大部分数据来自 CPU 缓存中的向量，X100 能够保持非常高的带宽。在 MonetDB&#x2F;MIL 中，乘法受内存带宽 500MB&#x2F;s 限制，而 MonetDB&#x2F;X100 在相同的运算符上超过了7.5GB&#x2F;s。</p><h2 id="向量大小对性能的影响"><a href="#向量大小对性能的影响" class="headerlink" title="向量大小对性能的影响"></a>向量大小对性能的影响</h2><p>X100默认的向量大小是 1024，但用户可以自行调整。理想情况下，所有向量加在一起应该能刚好放进 CPU 的缓存里，因此它们不应该太大。然而，如果向量真的很小，那么计算时 CPU 的并行性就会很差。在这种情况下，X100 中 next() 方法开销会增加。<br><img src="/2023/07/22/paper-reading-monetdb/vector-size.png"><br>在上述实验中，研究者在 Itanium 2 和 AthlonMP 平台上执行 Query-1，并同时调整向量大小。就像 MySQL 一样，如果MonetDB&#x2F;X100 使用 tuple-at-a-time 的处理模式（即向量大小为1），函数调用的开销也会严重影响到 MonetDB&#x2F;X100 的性能。随着向量大小的增加，执行时间快速改善。对于这个查询和这个测试平台，最优的向量大小似乎是 1000，但实际上在 128 到 8K 之间向量大小性能都不错。当查询的中间结果不能放进缓存里时，性能开始下降。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>MonetDB&#x2F;X100 这篇文章的背景主流数据库中每个算子计算时的 CPU cycle 数远高于理论的 cycle 数，究其原因是因为火山模型，特别是 tuple-at-a-time 的火山模型不能很好地利用现代超标量 CPU 高度并行化的特点，同时频繁的函数调用开销较大导致的。因此，作者设计了一个新的查询引擎，通过 vector-at-a-time 的执行方式减少了函数调用的平均开销，并且允许编译器进行 loop-pipelining 优化来充分利用超标量 CPU 的性能。</p>]]></content>
    
    
    <categories>
      
      <category>论文笔记</category>
      
      <category>数据库</category>
      
      <category>查询执行</category>
      
    </categories>
    
    
    <tags>
      
      <tag>论文笔记</tag>
      
      <tag>数据库</tag>
      
      <tag>查询执行</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>论文笔记：Apache Calcite: A Foundational Framework for Optimized Query Processing Over Heterogeneous Data Sources</title>
    <link href="/2023/07/14/paper-reading-calcite/"/>
    <url>/2023/07/14/paper-reading-calcite/</url>
    
    <content type="html"><![CDATA[<p><a href="https://15721.courses.cs.cmu.edu/spring2023/papers/17-optimizer2/p221-begoli.pdf">论文原文链接</a></p><h1 id="Calcite-介绍"><a href="#Calcite-介绍" class="headerlink" title="Calcite 介绍"></a>Calcite 介绍</h1><p>随着近些年越来越多数据处理系统的出现，出现了两个重要的问题：</p><ul><li>不同系统的开发者都遇到了类似的问题，例如需要为系统提供 SQL 的支持，以及进行查询优化。每个系统都造了自己的轮子，浪费了大量的开发精力。</li><li>某些开发者会同时使用多个数据处理系统，例如同时使用 Flink、Elasticsearch、Druid 等。我们需要构建一个系统，可以同时访问多个数据源的查询进行优化。</li></ul><p>Apache Calcite 就是为了解决上述问题而设计的，它是一个完整的查询处理系统，提供了查询执行、查询优化以及 SQL 适配等功能。除了数据存储和管理需要特定的系统实现，只要实现了 Calcite 规定的接口，任何数据存储系统都能基于 Calcite 做 SQL 查询。Calcite 既可以作为库被整合进数据库中作为查询引擎，也可以作为一个独立的查询系统，对多个数据源进行联邦查询。<br>对比其他系统，Calcite 主要有以下优势：</p><ul><li>开源。Calcite 是 Apache 基金会的一个开源产品，采用 Apache License，可以轻松地在开源产品或商业产品中使用。这意味着开发者可以自由地修改和分发 Calcite，为其项目增添强大的查询处理能力。。Calcite 使用 Java 编写，其他由 Java 编写的数据处理系统（例如 Flink，以及其他 Hadoop 生态下的数据处理系统）和用 Scala 编写的系统可以很方便地集成 Calcite。</li><li>多数据模型。Calcite 的查询语言和查询优化不仅支持常规的数据模型，也支持对流（streaming）的优化。</li><li>灵活的优化器。从规则（rules）到代价模型（cost model），Calcite 优化器中的每个部分都是可以配置的。Calcite 还支持多种规划引擎（planning model），可以将查询优化分成不同的阶段，在每个阶段选择最合适的引擎。</li><li>支持跨系统。Calcite 支持跨多个系统的数据查询。</li><li>可靠性。Calcite 已经被广泛使用多年，可靠性已经被多个平台验证过。同时 Calcite 也包含了一个可拓展的测试框架来测试每一个部件。</li><li>支持 SQL 及其拓展。Calcite 提供了 ANSI 标准 SQL，以及多种 SQL 方言（dialects）和拓展，例如对流数据的查询。</li></ul><h1 id="Calcite-的架构"><a href="#Calcite-的架构" class="headerlink" title="Calcite 的架构"></a>Calcite 的架构</h1><p><img src="/2023/07/14/paper-reading-calcite/architecture.png" alt="The Architecture of Calcite"></p><p>Calcite 包含了除存储引擎之外绝大多数数据库的功能，上图展示了其架构。在 Calcite 的优化器中，一个查询被表示成一个树形结构。优化器主要包含三个部分：优化规则、元数据服务（<em>MetadataProvider</em>）以及规划引擎（<em>PlannerEngines</em>），后文会对这三个模块进行更详细的介绍。上图中的虚线代表外部组件和 Calcite 之间的通信方式，外部总共有三种方式和 Calcite 进行通信：</p><ol><li>客户端使用 SQL 和 Calcite 通信。Calcite 可以通过 <em>SQL Parser</em> 和 <em>Validator</em> 将 SQL 转换成一个内部的树形结构并执行。由于 Calcite 本身并不存储任何的元数据，因此需要外部引擎通过适配器（<em>adapter</em>）将这些信息提供给 Calcite。</li><li>对于一些如 Hive 这样的数据存储后端，尽管它们支持 SQL，但它们的查询优化能力相对较弱。因此，它们可能希望利用 Calcite 来完成查询优化的工作。在这种情况下，Calcite 将对客户端输入的 SQL 进行优化，然后将其翻译成特定数据处理系统支持的 SQL 方言，并将其返回给该系统以执行。</li><li>此外，Calcite 还允许外部系统自行完成 SQL 的解析，然后通过 <em>ExpressionBuilder</em> 将解析后的 SQL 构建成 Calcite 内部的表达式树，然后再进行优化。</li></ol><h1 id="Calcite-的查询代数"><a href="#Calcite-的查询代数" class="headerlink" title="Calcite 的查询代数"></a>Calcite 的查询代数</h1><p>Calcite 的查询代数中，核心部件有两个：操作符（<em>Operator</em>）和特征（<em>Trait</em>）。</p><p>Calcite 支持大多数常见的关系代数算子，例如 filter, project, join 等等。除此之外，Calcite 还支持一些拓展算子，可以简洁地表示复杂的操作，或更高效地识别优化机会。例如，在 OLAP 和流处理场景中，窗口定义常被用于表示复杂的分析函数，如在一段时间或一些数据行上的计算滑动平均值。Calcite 引入了一个 window 算子，它封装了窗口定义，包括窗口的上限和下限、分区等，以及在每个滑动窗口上执行的聚合函数。</p><p>对于每种算子，Calcite 使用特征（<em>Trait</em>）来表示其物理属性。特征可以帮助优化器计算不同执行计划的代价。改变算子的特征并不会改变其逻辑属性。也就是说，算子输出的数据行仍然保持不变。在优化过程中，Calcite 试图在关系表达式上执行（enforce）某些特征，例如根据某些列进行排序。关系运算符可以实现一个转换器（<em>converter</em>）接口，表示如何将表达式的特征从一个值转换为另一个值。Calcite 包含了描述关系表达式产生的数据的常见物理属性，如排序、分组和分区。Calcite 优化器可以理解这些属性，并利用它们避免不必要操作。比如一个排序运算符的输入就是有序的（可能底层数据存储就是有序的，或者扫描的时候是根据索引来扫描的），那么这个排序运算符就可以被去除。除了常见的物理属性，Calcite 还有一个叫做 <em>calling convention</em> 的特征，这个特征主要描述一个表达式会在哪个数据处理系统上执行。<em>calling convention</em> 会被当作是一种物理属性，这使得 Calcite 可以透明地在多个存储引擎之上进行查询优化。</p><p>为了更好地说明 Calcite 的查询代数，论文中举了一个实际应用的例子，如下图，我们需要对 MySQL 中的 <em>Products</em> 表和 Splunk 中的 <em>Orders</em> 表做 join。初始化时，<em>Order</em> 表的扫描算子的 <em>calling convention</em> 指示这个算子会在 Splunk 上执行，<em>Products</em> 表的扫描算子的 <em>calling convention</em> 指示这个算子会通过 <em>jdbc-mysql</em> 执行。join 算子还是一个逻辑算子，表明系统此时没有选择这个算子的执行方式。然后，这个算子上的 where 条件会根据 <em>adapter</em> 中的 rule 被下推到 Splunk 中。对于 join 算子，一种可能的方式是使用 spark 作为计算引擎来执行，于是就将 join 算子的 <em>calling convention</em> 标记为 spark。同时，需要两个转换器，将 <em>jdbc-mysql</em> 和 <em>splunk</em> 的输入转接到 spark 中。</p><p><img src="/2023/07/14/paper-reading-calcite/optimize-process.png"></p><h1 id="适配器"><a href="#适配器" class="headerlink" title="适配器"></a>适配器</h1><p><img src="/2023/07/14/paper-reading-calcite/adapter.png"></p><p>Calcite 的适配器（<em>adapter</em>）用于描述 Calcite 如何对各种各样的数据源进行通用访问。一个适配器包含数据模型、数据模式（schema）以及模式工厂（schema factory）。数据模型用于描述被访问的数据源的物理性质，数据模式用于描述数据的格式和布局，模式工厂负责从数据模型中获取元数据信息，生成数据模型。</p><p>查询执行时，Calcite 可以通过适配器定义好的接口从数据源中读取数据。除此之外，适配器还可以定义一些优化规则并添加到规划器中。例如，可以定义一些规则来指定如何将逻辑关系表达式转化为适配器对应的数据源上的逻辑表达式。</p><p>对于一个适配器来说，所需要实现的最小接口是对表的 Scan 接口。只要适配器实现了这个接口，Calcite 就可以自行完成 SQL 中的其他操作，例如 sort、join、filtering 等。也就是说，一个存储引擎只要提供了 scan 接口，就可以通过 Calcite 执行任意的 SQL 查询。为了充分利用并拓展适配器的功能，Calcite 还定义了一个名为“可枚举调用约定”的特性（<em>enumerable calling convention</em>），拥有这个属性的关系算子可以通过一个迭代器接口对数据进行逐行的操作。这个属性使得 Calcite 可以实现在每个适配器后端不支持的操作，例如 <em>EnumerableJoin</em> 算子可以从其子节点读取数据行然后在指定属性上执行 join。对于某些不需要读取全部数据的算子来说，将全部数据都读出来是不高效的。所以 Calcite 允许适配器定义一些规则，然后在优化的时候将 Filter 下推到后端的存储引擎中，提高执行效率。</p><p>总的来说，适配器是 Calcite 对后端数据系统的一种抽象，使得 Calcite 具有强大的灵活性，不仅可以查询一个存储系统中的数据，还可以查询跨多存储系统的数据。同时，通过在适配器中定义一些规则，Calcite 的优化器会尝试尽可能地将 Filter 下推到后端系统中，提高查询的性能。</p><h1 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h1><p>这一部分是 Calcite 的核心，Calcite 使用的是 Volcano 风格的查询优化器，并没有将优化分为 Rewrite 和 PhysicalOptimize 两个阶段。优化时 Calcite 通过不断地使用定义好的规则对查询所对应的关系表达式进行变换，以选出代价更低的表达式。在变换的过程中，CBO 也会参与进来指导怎么变换才是最优的。</p><h2 id="Planner-Rules"><a href="#Planner-Rules" class="headerlink" title="Planner Rules"></a>Planner Rules</h2><p>Calcite 使用一组规划器规则（Planner Rules）来对查询表达式做变换。优化时 Calcite 会在查询树中寻找对应是否有可以应用某体规则的 pattern，找到以后就将对应的规则应用到表达式上做转换。Calcite 自身已经包含了上百条查询优化的规则，同时也允许不同的系统通过适配器加入特定的规则。</p><p>例如，Calcite 提供了对 Apache Cassandra 的适配器，后者是一个宽表存储系统。在 Cassandra 中，一个表中的数据根据一组列进行分区，每个分区中的数据再根据另一组列进行排序。如果在某个查询中有排序操作，假如想要把这个排序下推到 Cassandra 中，必须满足两个条件</p><ul><li>需要查询的数据在一个分区中（因为数据只在分区内有序）</li><li>Cassandra 在分区内对数据进行排序的列和查询排序的列有共同的前缀（例如数据按照 c1, c2, c3 排序，查询要求数据 order by c1, c2, c4）</li></ul><p>满足这些条件后就可以将表达式树中的 <em>LogicalFilter</em> 转换成 <em>CassandraFilter</em>，表示该过滤条件被下推到了 Cassandra 中执行。这样灵活的规则匹配机制使得 Calcite 在处理复杂查询的时候即可以尽可能地将过算子下推。</p><h2 id="MetdataProvider"><a href="#MetdataProvider" class="headerlink" title="MetdataProvider"></a>MetdataProvider</h2><p>MetadataProvider 主要有两个目的：</p><ul><li>引导 planner 选出低代价的查询计划</li><li>当转换规则被应用时，提供一些必要的信息</li></ul><p>MetadataProvider 主要负责向优化器提供信息。Calcite 默认的 MetadataProvider 提供的信息包括操作符树中子表达式的代价、该表达式结果的行数和数据大小，以及表达式执行时的最大并行度。它还可以提供关于查询计划结构的信息，例如某个节点下的过滤条件。</p><p>Calcite 提供了允许外围数据系统将元数据信息插入到 Calcite 中的接口，这些系统覆写（Override）现有的函数接口来编写新的 MetadataProvider，或者提供它们可能在优化阶段被用到的新函数。对于大部分系统来说，提供输入数据的统计信息就够了（比如行数和表的大小，给定列的值是否唯一等），剩下的工作 Calcite 可以通过它的默认实现来完成。因为 MetadataProvider 是可拔插的，所以 Calcite 使用一个轻量化的 Java 编译器（Janino）来编译并实例化这些 MetadataProvider。</p><h2 id="PlannerEngine"><a href="#PlannerEngine" class="headerlink" title="PlannerEngine"></a>PlannerEngine</h2><p>PlannerEngine 的目标是在输入的逻辑表达式上不断应用给定的规则，直到到达某个目标（例如代价低于某个阈值，或者优化的时间到了上限等）。Calcite 目前支持两套不同的规划引擎。</p><p>第一个引擎是一个基于代价的规划引擎，通过不断应用规则来减少表达式的整体代价。引擎的整体使用了类似于 Volcano 中的动态规划算法。优化开始，每个表达式都在 Planner 中注册，同时基于表达式的属性和其输入创建一个摘要（digest）。当一个规则应用在表达式 $e1$ 上后产生一个新的等价表达式 $e2$ 时，Planner 就会把 $e2$ 加入到 $e1$ 所属的等价表达式集合 $S_a$ 中，同时将为 $e2$ 生成一个摘要。$e2$ 的摘要将与 Planner 中已有的摘要作比较，如果发现属于集合 $S_b$ 的表达式 $e3$ 的摘要与之相似，那么 Planner 就认为 $S_a$ 和 $S_b$ 是等价的，会将其合并。这样的过程将一直持续，直到</p><ol><li>搜索空间已经被穷尽，所有的规则都已经被应用过了；</li><li>基于启发式的停止方式，在最后一次迭代中，新查询计划的代价下降没有超过阈值 $\delta$。<br>Planner 计算每个候选计划的代价函数是由 MetadataProvider 提供的，默认的代价函数包含了对 CPU、IO、内存代价的估计。</li></ol><p>第二个引擎是一个穷尽搜索（exhausetive）规划器，它将对一个表达式不断应用改写规则，直到没有任何可用的规则为止。这个引擎执行的更快，因为它无需对表达式的代价进行计算。</p><p>用户可以根据需求选择使用哪一个引擎。用户也可以选择进行多阶段（multi-stage）优化逻辑，在不同的优化阶段使用不同的规则集。</p><h2 id="Materialized-Views"><a href="#Materialized-Views" class="headerlink" title="Materialized Views"></a>Materialized Views</h2><p>数据处理系统中加速查询的一个重要手段就是对物化视图（materialized views）的预计算，Calcite 允许后端系统将物化视图暴露给优化器，这样优化器在优化时可以有机会在进行查询改写时使用物化视图来代替基表。Calcite 提供了两种对物化视图的改写算法。</p><p>第一种算法基于视图替换（view substitution），目标是将查询表达式树中的一部分使用物化视图来进行代替。算法第一步需要将物化视图的 scan 算子和物化视图的定义注册到 planner 中，第二步则是在重写阶段中通过触发改写规则将表达式树的一部分替换成物化视图。</p><p>第二种算法基于 lattices，只要数据源声明形成了一个 lattice，Calcite 就可以用 tile 来表示物化视图，并且在优化器中使用其来回应输入的查询。（这一部分没看懂）</p><h1 id="Calcite-的拓展"><a href="#Calcite-的拓展" class="headerlink" title="Calcite 的拓展"></a>Calcite 的拓展</h1><p>这部分主要介绍了Calcite如何拓展到支持除普通关系型数据外的其他数据，包括半结构化数据（例如ARRAY、MAP、MULTISET）、流数据以及空间数据。从论文中介绍的内容来看，Caclite 拓展了标准 SQL，使得这些数据的查询和操作可以在 SQL 中进行。感兴趣的朋友可以去阅读论文的原文。</p><h1 id="Calcite-的使用情况"><a href="#Calcite-的使用情况" class="headerlink" title="Calcite 的使用情况"></a>Calcite 的使用情况</h1><p><img src="/2023/07/14/paper-reading-calcite/usage.png"></p><p>上图展示了 Calcite 作为内置优化器的各种应用场景。和 Orca 相比，Calcite 的应用还是比较广泛的。Apache 基金会下很多知名的软件比如 Hive、Flink 都使用了 Calcite 作为查询优化器。此外，一些商业软件也使用了 Calcite 作为它们的优化器。</p><p><img src="/2023/07/14/paper-reading-calcite/usage-2.png"></p><p>上图展示了已实现 Calcite 适配器的各种软件，其中有一些是在大数据领域非常常用的软件，这意味着用户可以通过 Calcite 在这些软件组成的异构数据源上进行联邦查询。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Apache Calcite 是一个被广泛使用的开源查询引擎，其灵活可拓展的结构让其能被各种系统轻松集成。我感觉 Calcite 想做的事情比 Orca 更多，不仅可以做一个独立的查询引擎，还可以作为优化器嵌入到不同的系统内部，节省开发的时间。在查询优化模块，Calcite 使用了类似于 Volcano 的搜索引擎，并且可以让外部系统通过实现接口加入新的优化规则以及实现新的代价函数，提供了良好的拓展性。在查询执行上，只要后端系统提供一个 Table Scan 接口，Calcite 就可以在这个系统之上执行任意的 SQL 语句。这意味着只要我们能够做好其他数据模型到关系型模型的抽象，例如将 KV 模型映射到关系型模型，就可以通过 Calcite 向用户提供 SQL 的执行能力，这一点我觉得还是非常厉害的。</p>]]></content>
    
    
    <categories>
      
      <category>论文笔记</category>
      
      <category>数据库</category>
      
      <category>优化器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>论文笔记</tag>
      
      <tag>数据库</tag>
      
      <tag>查询优化器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>论文笔记：The MemSQL Query Optimizer: A modern optimizer for real-time analytics in a distributed database</title>
    <link href="/2023/07/08/paper-reading-memsql/"/>
    <url>/2023/07/08/paper-reading-memsql/</url>
    
    <content type="html"><![CDATA[<p>最近暑期实习的工作是和 MySQL 的查询优化器相关。过去我在 IoTDB 所做的工作主要和存储引擎相关，对于查询的了解仅限于火山模型，对查询优化的了解仅限于知道有 RBO 和 CBO。对于暑期工作的内容，我基本上需要从头开始学。我学习查询优化主要方式包括论文阅读、网络上的公开课和讲座（CMU 15-721 以及 CMU Database Group 关于 Query Optimizer 的系列讲座）以及数据库查询优化器的源代码阅读（主要是 MySQL）。目前为止看了大概有六七篇论文，对查询优化器有了一些初步的概念。有些时候我看完论文再过一段时间，就会记不清楚论文讲的一些东西了。所以我决定写一些阅读笔记来记录一下自己看的这些论文，也方便和大家的交流学习。因为在查询优化器领域我算是刚刚入门，所以论文里有些地方我可能理解的不对，如果有错误之处希望各位读者及时指出。</p><p>这篇论文发表在 VLDB 2016 上，原文链接为：<a href="https://vldb.org/pvldb/vol9/p1401-chen.pdf">https://vldb.org/pvldb/vol9/p1401-chen.pdf</a></p><h1 id="MemSQL-简介"><a href="#MemSQL-简介" class="headerlink" title="MemSQL 简介"></a>MemSQL 简介</h1><p>MemSQL 是一个分布式的、针对内存优化的数据库，擅长大规模混合实时分析和事务处理。MemSQL 在内存里用行式存储，在磁盘上使用列式存储，查询的时候可以从这两种不同格式的数据源中获取数据。MemSQL 利用了 MVCC 和针对内存优化的无锁数据结构来增加读写的并发度，从而实现了对运营数据库的实时分析。MemSQL 的设计目标是在通用计算机上进行拓展，而不需要任何特定的硬件或者指令集。</p><p><img src="/2023/07/08/paper-reading-memsql/memsql-meets-the-microservices-architecture_1.jpg"></p><p>MemSQL 的分布式架构是 Share-Nothing 架构，集群中的节点分为调度节点（aggregator nodes）和执行节点（leaf nodes）。前者的作用是作为集群和客户端之间的中介，后者则负责存储数据和执行查询。用户的查询时，查询会先发到调度节点上，被解析、优化和规划（planned）之后发送到执行节点上执行。</p><p>MemSQL 中的数据有两种分布方式，一种是对表中的每一行都根据 shard key 进行哈希，即水平分片；另一种则是对表中的内容在集群中的所有节点都进行复制。为了在集群中执行一个查询，调度节点会把 SQL 转换成一个分布式查询计划（DQEP）。一个 DQEP 里包含很多步骤，每一个步骤可以用 SQL-Like 的语法进行描述。为了描述 DQEP 中的内容，MemSQL 对标准 SQL 继续进行了拓展，往其中加入了 <em>RemoteTables</em> 和 <em>ResultTables</em> 两个关键字。</p><p>查询计划生成后被编译成机器代码并且缓存起来，以加速后续查询的执行。MemSQL 不会缓存查询的结果，只缓存查询的计划。在编译查询计划时没有指定预设参数的值，因此后续查询的参数不同也可以利用前面缓存住的查询计划。</p><h1 id="MemSQL-的优化器"><a href="#MemSQL-的优化器" class="headerlink" title="MemSQL 的优化器"></a>MemSQL 的优化器</h1><p>MemSQL 上运行的很多查询都是复杂的实时分析型查询，包括星型模型和雪花模型下的 join、排序、分组、聚集查询以及嵌套子查询等等。MemSQL 的优化器不仅要找到一个高质量的查询计划，还要保证执行查询优化本身的时间不能太长。这是因为 MemSQL 的查询延迟都需要在秒级甚至更短，如果查询优化本身的开销很大就会导致其成为查询延迟中显著的一部分。</p><p>对分布式数据库开发一个优化器是一个很难的任务，如果使用已有的查询优化器，可能无法完成前面所述的目标（高质量且耗时短），并且还会继承已有优化器的所有缺点。因此，MemSQL 决定自己从头造一个优化器。 </p><p>MemSQL 的优化器主要包含以下几个组成部分：Rewriter、Enumerator 和 Planner。下面我们逐一进行介绍。</p><h2 id="Rewriter"><a href="#Rewriter" class="headerlink" title="Rewriter"></a>Rewriter</h2><h3 id="基于分布式代价的查询重写"><a href="#基于分布式代价的查询重写" class="headerlink" title="基于分布式代价的查询重写"></a>基于分布式代价的查询重写</h3><p>Rewriter负责对查询进行等价的逻辑转换。MemSQL 的 Rewriter 把变换规则分为了两类，一类是启发式规则，即无需进行代价判断就可以直接使用规则，例如列消除（Column Elimination），一定可以减少系统的 IO 和计算；另一类是基于代价的规则，这种规则使用之后不一定可以给查询带来性能优化，所以需要通过代价来判断到底是不是有益的。例如对于一个带有多表 join 的视图，如果将它展开到上层查询中，就会在上层查询中出现一个特别大的 join，对于 Enumerator 来说比较难优化。此外，将子查询展开到上层会使得子查询在连接图（join graph）中的结构信息消失，这些结构信息对在对 join 进行优化时可能是有用的。因此，是否对子查询进行展开需要通过 cost 来判断。</p><p>Rewriter 通过 Enumerator 来计算候选查询计划的代价。由于 Rewriter 中的每条规则通常只会对一整个查询中的一部分进行修改，其他部分往往保持不变，为了减少 Enumerator 计算的开销，Enumerator 只会计算 Rewriter 改变的那一部分的代价，对于查询中其他不变的部分则不进行计算。在计算一个查询计划的代价的时候，不仅需要考虑到在单机上执行的代价，还要考虑到在分布式条件下不同节点之间数据传输的代价，这一点作者在文中有反复提到，并且给了一个例子来说明考虑数据分布代价和不考虑数据分布代价之间的区别。例如，有下面两条 SQL，它们之间是等价的：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> T1 (a <span class="hljs-type">int</span>, b <span class="hljs-type">int</span>, shard key (b));<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> T2 (a <span class="hljs-type">int</span>, b <span class="hljs-type">int</span>, shard key (a),<br>            <span class="hljs-keyword">unique</span> key (a));<br><br>Q1:<br><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">sum</span>(T1.b) <span class="hljs-keyword">AS</span> s <span class="hljs-keyword">FROM</span> T1, T2<br>    <span class="hljs-keyword">WHERE</span> T1.a <span class="hljs-operator">=</span> T2.a<br>    <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> T1.a, T1.b;<br><br>Q2:<br><span class="hljs-keyword">SELECT</span> V.s <span class="hljs-keyword">from</span> T2,<br>        (<span class="hljs-keyword">SELECT</span> a,<br>            <span class="hljs-built_in">sum</span>(b) <span class="hljs-keyword">as</span> s<br>        <span class="hljs-keyword">FROM</span> T1<br>        <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> T1.a, T1.b<br>        ) V<br>    <span class="hljs-keyword">WHERE</span> V.a <span class="hljs-operator">=</span> T2.a;<br></code></pre></td></tr></table></figure><p>假设 T1 表的行数为 $R_1 &#x3D; 200,000$，T2 的行数为 $R_2 &#x3D; 50,000$，对 <code>T1.a, T2.b</code> 进行 Group By 的过滤率为 $S_G &#x3D; \frac{1}{4}$ ，对 <code>T1.a = T2.a</code> 进行 join 之后的过滤率为 $S_J &#x3D; \frac{1}{10}$，并且假设 $S_G$ 和 $S_J$ 是独立的。假读取 <code>T2.a</code> 中的每一行的代价是 $C_J &#x3D; 1$，对每一行数据使用哈希表计算 Group By 的代价是 $C_G &#x3D; 1$，那么 Q1 和 Q2 的代价分别是$Cost_{Q1}&#x3D;R_1C_J + R_1S_JC_G &#x3D; 220,000$ 和 $Cost_{Q2}&#x3D;R_1C_G + R_1S_GC_J &#x3D; 250,000$，那么应当选择 Q1 作为最优查询计划。</p><p>但是在分布式条件下，我们需要考虑数据的分布情况。因为 T2 是在 <code>T2.a</code> 上进行分片的，但是 T1 却不是在 <code>T1.a</code> 上分片的，所以我们需要将 T1 进行 reshuffle 或者对 T2 进行广播（broadcast）。假设 T2 跟 T1 差不多大，那么对 T1 进行 reshuffle 代价是更小的。对于 Q1 来说，在 join 之后进行 group by 不需要进一步移动数据，因为 join 的结果就是根据 <code>T1.a</code> 分布的；对于 Q2 来说，在 join 之前进行 group by 也不需要移动数据，因为数据是根据 <code>T1.b</code> 进行分布的。因此，在执行时 Q1 会先对 T1 根据 <code>T1.a</code> 进行 reshuffle，再在每个分片上执行 join 和 group by；Q2 则会先在每个分片上执行 group by，再将 group by 的结果进行 reshuffle，最后在每个分片上和 T2 做 join。Q1 和 Q2 的执行计划就成了：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">Q1:<br>    Gather partitions:<span class="hljs-keyword">all</span><br>    Project [r0.s]<br>    NestedLoopJoin<br>    |<span class="hljs-comment">---IndexSeek T2, UNIQUE KEY (a) scan:[a = r0.a]</span><br>    Repartition <span class="hljs-keyword">AS</span> r0 shard_key:[a]<br>    HashGroupBy [SUM(T1.b) <span class="hljs-keyword">AS</span> s] <span class="hljs-keyword">groups</span>:[T1.a, T1.b]<br>    TableScan T1<br>Q2:<br>    Gather partitions:<span class="hljs-keyword">all</span><br>    Project [r0.s]<br>    HashGroupBy [SUM(r0.b) <span class="hljs-keyword">AS</span> s] <span class="hljs-keyword">groups</span>:[r0.a, r0.b]<br>    NestedLoopJoin<br>    |<span class="hljs-comment">---IndexSeek T2, UNIQUE KEY (a) scan:[a = r0.a]</span><br>    Repartition <span class="hljs-keyword">AS</span> r0 shard_key:[a]<br>    TableScan T1<br></code></pre></td></tr></table></figure><p>假设在网络中移动一条数据的代价是 $C_R &#x3D; 3$，那么两个查询的代价则会变成 $Cost_{Q1} &#x3D; R_1C_R + R_1C_J + R_1S_JC_G &#x3D; 620,000$ 和 $Cost_{Q2} &#x3D; R_1C_G + R_1S_GC_R + R_1S_GC_J &#x3D; 400,000$，Q2 成了更好的那一个计划。可见在分布式环境下，数据通过网络的开销会成为查询代价里的主要部分。作者在亚马逊 EC 集群上做的实验表明，执行 Q2 比执行 Q1 要快 2 倍。如果查询优化器没有将分布式代价计算到查询代价里，那么就会错误地选择 Q1 作为最优代价。</p><h3 id="浓密连接"><a href="#浓密连接" class="headerlink" title="浓密连接"></a>浓密连接</h3><p>在对 join 的连接进行搜索时，如果需要考虑各种各样的组合，那么搜索空间就会变得非常大，效率比较低。因此，一些数据库的优化器限定只考虑左深树（例如 System-R，MySQL）或者右深树来减小搜索空间。但是在一些涉及到多个星型模型或雪花模型的查询中，浓密连接（Bushy Join）比左深树或者右深树的执行效率更高。一般来说，对于 Join 顺序的确定都是在对逻辑计划向物理计划转换时完成的，对于 MemSQL 来说则是在 Enumerator 完成这一工作。MemSQL 的 Enumerator 只能生成左深树的查询计划，为了在查询计划中加入浓密连接，MemSQL 在 Rewrite 阶段通过启发式规则将多个表结合成一个 derived table 加入到查询树中。</p><p><img src="/2023/07/08/paper-reading-memsql/bushy-join.png" alt="图 2：Left-deep Join vs Bushy Join"></p><p>MemSQL 引入 Bushy Join 的方法是先构建连接图（Join Graph），然后在从连接图中寻找卫星表（satellite table）和种子表（seed table），再将种子表以及其关联的卫星表转化为一个 derived table 加入到查询树中。具体的算法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-number">1.</span> 收集查询中所有的表，并构建一个 <span class="hljs-keyword">join</span> graph，每个表是一个顶点，每个表对之间的连接谓词对应于它们的顶点之间的边<br><span class="hljs-number">2.</span> 识别候选卫星表（satellite <span class="hljs-keyword">table</span>），这些表上至少有一个选择性谓词，如 <span class="hljs-keyword">column</span> <span class="hljs-operator">=</span> const 或 <span class="hljs-keyword">column</span> <span class="hljs-keyword">IN</span> (const, ...) 形式的谓词<br><span class="hljs-number">3.</span> 从候选卫星表的列表中，识别卫星表，这些表只连接到图中的其他一张表（尽管可能有多个连接谓词）<br><span class="hljs-number">4.</span> 识别种子表（seed <span class="hljs-keyword">table</span>），这些表连接到至少两个不同的表，其中至少有一个是卫星表（注意，没有任何一个卫星表可以与超过一个种子表连接，因为卫星表只能和一个表连接）<br><span class="hljs-number">5.</span> 对于每一个种子表：<br>    a) 计算当前计划的代价 C1<br>    b) 创建一个派生表，包含种子表与其相邻的卫星表的连接。一些 <span class="hljs-keyword">SQL</span> 操作符可能阻止一些卫星表被移入子查询，在这种情况下，尽可能多的移入<br>    c) 尝试谓词下推，然后尝试列消除，把外部查询中任何可以在子查询尽早被使用的谓词移入，并且子查询不提供外部查询不需要的任何列<br>    d) 计算修改后的计划的代价 C2 。如果 C1 <span class="hljs-operator">&lt;</span> C2，丢弃在步骤（b）和（c）中做的修改，否则保留它们<br></code></pre></td></tr></table></figure><p>在上面这个过程中，产生出的派生表会被当作一个表加入到左深树中，每个派生表内部也是一个左深树，在全局上就形成了 Bushy Join。这个算法不需要获取表的基数或者谓词的选择率，只是通过连接图就可以找到可以被提取成派生表的地方。（Note：这里其实我有点没懂，在计算 Cost 的时候应该也是需要表的 cardinalities 和谓词的选择率的吧？）</p><p>论文中对这个算法举的例子来自于 TPC-DS 的第 25 个查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> …<br><span class="hljs-keyword">FROM</span> store_sales ss,<br>     store_returns sr,<br>     catalog_sales cs,<br>     date_dim d1,<br>     date_dim d2,<br>     date_dim d3,<br>     store s,<br>     item i<br><span class="hljs-keyword">WHERE</span> d1.d_moy <span class="hljs-operator">=</span> <span class="hljs-number">4</span><br>    <span class="hljs-keyword">AND</span> d1.d_year <span class="hljs-operator">=</span> <span class="hljs-number">2000</span><br>    <span class="hljs-keyword">AND</span> d1.d_date_sk <span class="hljs-operator">=</span> ss_sold_date_sk<br>    <span class="hljs-keyword">AND</span> i_item_sk <span class="hljs-operator">=</span> ss_item_sk<br>    <span class="hljs-keyword">AND</span> s_store_sk <span class="hljs-operator">=</span> ss_store_sk<br>    <span class="hljs-keyword">AND</span> ss_customer_sk <span class="hljs-operator">=</span> sr_customer_sk<br>    <span class="hljs-keyword">AND</span> ss_item_sk <span class="hljs-operator">=</span> sr_item_sk<br>    <span class="hljs-keyword">AND</span> ss_ticket_number <span class="hljs-operator">=</span> sr_ticket_number<br>    <span class="hljs-keyword">AND</span> sr_returned_date_sk <span class="hljs-operator">=</span> d2.d_date_sk<br>    <span class="hljs-keyword">AND</span> d2.d_moy <span class="hljs-keyword">BETWEEN</span> <span class="hljs-number">4</span> <span class="hljs-keyword">AND</span> <span class="hljs-number">10</span><br>    <span class="hljs-keyword">AND</span> d2.d_year <span class="hljs-operator">=</span> <span class="hljs-number">2000</span><br>    <span class="hljs-keyword">AND</span> sr_customer_sk <span class="hljs-operator">=</span> cs_bill_customer_sk<br>    <span class="hljs-keyword">AND</span> sr_item_sk <span class="hljs-operator">=</span> cs_item_sk<br>    <span class="hljs-keyword">AND</span> cs_sold_date_sk <span class="hljs-operator">=</span> d3.d_date_sk<br>    <span class="hljs-keyword">AND</span> d3.d_moy <span class="hljs-keyword">BETWEEN</span> <span class="hljs-number">4</span> <span class="hljs-keyword">AND</span> <span class="hljs-number">10</span><br>    <span class="hljs-keyword">AND</span> d3.d_year <span class="hljs-operator">=</span> <span class="hljs-number">2000</span><br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> …<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> …<br></code></pre></td></tr></table></figure><p>这个查询的连接图为<br><img src="/2023/07/08/paper-reading-memsql/join-graph.jpg"><br>其中， ss、sr、cs 是事实表，和它们对应的维度表连接后被一个谓词过滤。在分布式环境下，最优的左深树如图 2(a) 所示。所有的 join 都有连接谓词，除了 d3，因为 d3 只和 cs 有连接谓词。所以在连接到 d3 时，就会产生一个笛卡尔积，其代价是非常高的。但由于只能使用左深连接树，比起先连接 cs，由于 d3 有一个单表过滤条件，先连接 d3 会更好。</p><p>在运行浓密连接的选择算法时，先找到候选卫星表 {d1, d2, d3}，再找到卫星表，也是 {d1, d2, d}。然后再找种子表，分别是 {ss, sr, cs}。然后重写器尝试把这些表整合成派生表加入到查询树中，并计算每种组合的代价，最后得到代价最小的查询树如图 2b 所示，对应的查询语句为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> …<br><span class="hljs-keyword">FROM</span> store_sales,<br>     store_returns,<br>     date_dim d1,<br>     date_dim d2,<br>     store,<br>     item,<br>    (<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br>        <span class="hljs-keyword">FROM</span> catalog_sales,<br>             date_dim d3<br>        <span class="hljs-keyword">WHERE</span> cs_sold_date_sk <span class="hljs-operator">=</span> d3.d_date_sk<br>        <span class="hljs-keyword">AND</span> d3.d_moy <span class="hljs-keyword">BETWEEN</span> <span class="hljs-number">4</span> <span class="hljs-keyword">AND</span> <span class="hljs-number">10</span><br>        <span class="hljs-keyword">AND</span> d3.d_year <span class="hljs-operator">=</span> <span class="hljs-number">2000</span>) sub<br><span class="hljs-keyword">WHERE</span> d1.d_moy <span class="hljs-operator">=</span> <span class="hljs-number">4</span><br>    <span class="hljs-keyword">AND</span> d1.d_year <span class="hljs-operator">=</span> <span class="hljs-number">2000</span><br>    <span class="hljs-keyword">AND</span> d1.d_date_sk <span class="hljs-operator">=</span> ss_sold_date_sk<br>    <span class="hljs-keyword">AND</span> i_item_sk <span class="hljs-operator">=</span> ss_item_sk<br>    <span class="hljs-keyword">AND</span> s_store_sk <span class="hljs-operator">=</span> ss_store_sk<br>    <span class="hljs-keyword">AND</span> ss_customer_sk <span class="hljs-operator">=</span> sr_customer_sk<br>    <span class="hljs-keyword">AND</span> ss_item_sk <span class="hljs-operator">=</span> sr_item_sk<br>    <span class="hljs-keyword">AND</span> ss_ticket_number <span class="hljs-operator">=</span> sr_ticket_number<br>    <span class="hljs-keyword">AND</span> sr_returned_date_sk <span class="hljs-operator">=</span> d2.d_date_sk<br>    <span class="hljs-keyword">AND</span> d2.d_moy <span class="hljs-keyword">BETWEEN</span> <span class="hljs-number">4</span> <span class="hljs-keyword">AND</span> <span class="hljs-number">10</span><br>    <span class="hljs-keyword">AND</span> d2.d_year <span class="hljs-operator">=</span> <span class="hljs-number">2000</span><br>    <span class="hljs-keyword">AND</span> sr_customer_sk <span class="hljs-operator">=</span> cs_bill_customer_sk<br>    <span class="hljs-keyword">AND</span> sr_item_sk <span class="hljs-operator">=</span> cs_item_sk<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> …<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> …<br></code></pre></td></tr></table></figure><h2 id="Enumerator"><a href="#Enumerator" class="headerlink" title="Enumerator"></a>Enumerator</h2><h3 id="搜索过程"><a href="#搜索过程" class="headerlink" title="搜索过程"></a>搜索过程</h3><p>枚举器（Enumerator）负责连接重写器（Rewriter）和规划器（Planner），它接收重写器输出的查询操作树，然后确定查询的执行计划，包括分布式环境下数据的移动和 join 的顺序。重写器主要负责逻辑优化，而枚举器主要负责物理优化。MemSQL 的枚举器基于一个假设：将最优的串行计划做并行化并不能得到一个足够好的分布式查询计划。这个假设可以在上一节所举的例子中得到验证。因此枚举器在优化时需要考虑代价、表、网络、查询特性等等因素。枚举器其中一个关注点就在于，如何尽可能利用数据的共位连接（co-located join）以降低将数据在不同节点间传递的代价。同时，MemSQL 的枚举器需要考虑如何更好地优化同时涉及到行存和列存数据的查询。</p><p>MemSQL 的枚举器在优化时只会在一个 Query Block 里面进行优化，而不会把一个查询块里的 join 移动到另一个查询块上执行（个人理解这个操作属于逻辑优化，应该在 Rewrite 阶段通过启发式规则或者基于代价的规则完成，在 Enumerate 阶段就假设能做的都已经做完了）。在优化时采用自底向上的方式，从最小的 Expression 开始优化，再优化该表达式的上层表达式（例如对于一个嵌套查询，先优化内层的子查询，再优化外层的查询）。当最外面的一层查询被优化完后，枚举器的优化过程就结束了。</p><p>由于分布式条件下可能会涉及到不同节点间的数据移动，搜索空间会比单机查询优化的空间更大。为了限制搜索空间的大小，MemSQL 的优化器像  System-R 优化器一样，实现了一种带有 interesting properties 的动态规划算法。在 System-R 中，interesting properties 主要是算子的输出是否有序。在 MemSQL 中，interesting properties 主要是数据的分片。在进行等值 join 或者分组操作时，shard key 可能就会带来一些帮助。</p><h3 id="分布式代价计算"><a href="#分布式代价计算" class="headerlink" title="分布式代价计算"></a>分布式代价计算</h3><p>论文还介绍了一下计算分布式代价的公式，主要包括两个操作：广播（Broadcast）和分区（Partition）。前者指的是把数据传输到每个节点上，后者指的是把每个执行节点上的数据根据指定的分区键进行重新分布（reshuffle）。广播的代价为 $R \times D$，分区的代价为 $\frac{1}{N}\times(R\times D + R\times H)$，其中 $R$ 是需要移动的数据行数，$D$ 是移动每行数据所需要的代价，$N$ 是集群中节点的个数，$H$ 是对每行数据计算哈希值的代价。</p><h2 id="Planner"><a href="#Planner" class="headerlink" title="Planner"></a>Planner</h2><p>规划器（Planner）负责将枚举器输出的物理操作树变成分布式执行计划。执行计划由多个 DQEP Step 组成，每个 Step 都可以用类似 SQL 的文本表示。当调度节点将计划分发到每个执行节点上时，传输的内容就是一条条像 SQL 一样的文本。论文中解释这是因为 SQL 非常容易理解，并且使用 SQL 还可以在每个执行节点侧进行节点级别的优化和拓展。</p><h3 id="Result-Table-和-Remote-Table"><a href="#Result-Table-和-Remote-Table" class="headerlink" title="Result Table 和 Remote Table"></a>Result Table 和 Remote Table</h3><p>为了支持使用 SQL 描述 DQEP Step，MemSQL 为 SQL 增加了两个拓展：<em>Remote Table</em> 和 <em>Result Table</em>。</p><p>当一个查询需要让一个节点访问所有节点的数据时，就可以使用 <em>Remote Table</em> 关键字。例如下面这个 SQL</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> facts.id, facts.value<br><span class="hljs-keyword">FROM</span> REMOTE(facts) <span class="hljs-keyword">as</span> facts<br><span class="hljs-keyword">WHERE</span> facts.value <span class="hljs-operator">&gt;</span> <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>其中 <code>REMOTE(facts)</code> 表明 facts 表中的数据不仅来源于本地的数据分区，还来自于集群中的其他节点。</p><p>当一个集群中的所有节点都使用 Remote Table 访问数据时，很多工作会被重复多次，例如数据可能会被读或者计算多次。为了节省计算量，MemSQL 使用 <em>Result Table</em> 来让每个节点在本地保存一个临时表，表里的数据全部来源于本地分区。例如下面这个 SQL 就在每个节点上都创建了一个名为 facts_filtered 的表，每个节点上的 facts_filtered 表只包含自己本地 facts 表的数据。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">RESULT</span> <span class="hljs-keyword">TABLE</span> facts_filtered<br><span class="hljs-keyword">AS</span> <span class="hljs-keyword">SELECT</span> facts.id, facts.value<br>        <span class="hljs-keyword">FROM</span> facts<br>        <span class="hljs-keyword">WHERE</span> facts.value <span class="hljs-operator">&gt;</span> <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><h3 id="对-DQEP-的描述"><a href="#对-DQEP-的描述" class="headerlink" title="对 DQEP 的描述"></a>对 DQEP 的描述</h3><p>DQEP 中涉及到很多对数据的移动和计算，这些都需要使用 SQL 表示出来。在 MemSQL 中，这是通过在 Result Table 内将这些操作连接起来实现的。DQEP 的每个阶段都由一个计算步骤表示，这个计算步骤会从上一个执行步骤中拉取数据，中间结果会用 Result Table 保存。Resul Table 不需要被物化，可以在执行时流式地进行计算和传递结果。</p><h3 id="Broadcasts-的表示"><a href="#Broadcasts-的表示" class="headerlink" title="Broadcasts 的表示"></a>Broadcasts 的表示</h3><p>假设有这样一条 sql：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> x <span class="hljs-keyword">JOIN</span> y <span class="hljs-keyword">WHERE</span> x.a <span class="hljs-operator">=</span> y.a <span class="hljs-keyword">AND</span> x.b <span class="hljs-operator">&lt;</span> <span class="hljs-number">2</span> <span class="hljs-keyword">AND</span> y.c <span class="hljs-operator">&gt;</span> <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p>如果 x 是根据 a 进行分片的而 y 不是，那么我们要么 reshuffle y 要么就广播 x。假如经过计算我们认为广播 x 代价更低，那么整个 DQEP 可以表示为</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">(<span class="hljs-number">1</span>) <span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">RESULT</span> <span class="hljs-keyword">TABLE</span> r1 <span class="hljs-keyword">AS</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> x <span class="hljs-keyword">WHERE</span> x.b <span class="hljs-operator">&lt;</span> <span class="hljs-number">2</span> (<span class="hljs-keyword">on</span> <span class="hljs-keyword">every</span> <span class="hljs-keyword">partition</span>)<br>(<span class="hljs-number">2</span>) <span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">RESULT</span> <span class="hljs-keyword">TABLE</span> r2 <span class="hljs-keyword">AS</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> REMOTE(r1) (<span class="hljs-keyword">on</span> <span class="hljs-keyword">every</span> node)<br>(<span class="hljs-number">3</span>) <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> r2 <span class="hljs-keyword">JOIN</span> y <span class="hljs-keyword">WHERE</span> y.c <span class="hljs-operator">&gt;</span> <span class="hljs-number">5</span> <span class="hljs-keyword">AND</span> r2.a <span class="hljs-operator">=</span> y.a (<span class="hljs-keyword">on</span> <span class="hljs-keyword">every</span> <span class="hljs-keyword">partition</span>)<br></code></pre></td></tr></table></figure><p>其中（1）在每个分区本地执行；（2）在每个节点执行，但是需要读取其他分区的 Result Table r1；（3）在每个分区执行，执行后将结果传输到调度节点汇总生成最后的结果。因为 Result Table 可以流式地创建和传输，因此整个查询执行时就是流式的。在执行（2）时，x 的数据就会被广播到整个集群。</p><h3 id="Reshuffle-的表示"><a href="#Reshuffle-的表示" class="headerlink" title="Reshuffle 的表示"></a>Reshuffle 的表示</h3><p>还是前面那个查询，假如我们要 reshuffle y，那么 DQEP 可以表示为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">(<span class="hljs-number">1</span>) <span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">RESULT</span> <span class="hljs-keyword">TABLE</span> r1 <span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> (y.a) <span class="hljs-keyword">AS</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> y <span class="hljs-keyword">WHERE</span> y.c <span class="hljs-operator">&gt;</span> <span class="hljs-number">5</span> (<span class="hljs-keyword">on</span> <span class="hljs-keyword">every</span> <span class="hljs-keyword">partition</span>)<br>(<span class="hljs-number">2</span>) <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> x <span class="hljs-keyword">JOIN</span> REMOTE(r1(p)) <span class="hljs-keyword">WHERE</span> x.b <span class="hljs-operator">&lt;</span> <span class="hljs-number">2</span> <span class="hljs-keyword">AND</span> x.a <span class="hljs-operator">=</span> r1.a (<span class="hljs-keyword">on</span> <span class="hljs-keyword">every</span> <span class="hljs-keyword">partition</span>)<br></code></pre></td></tr></table></figure><p>（1）将 y 中的每一行都根据 a 进行了重新分区。（1）完成后 x 和 y 都是根据 a 进行分片的，因此（2）可以在每个分区本地执行，然后将结果汇总到调度节点中。如果 x 和 y 都不是根据 a 进行分区的，那么可以对 x 和 y 都 reshuffle：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">(<span class="hljs-number">1</span>) <span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">RESULT</span> <span class="hljs-keyword">TABLE</span> r1 <span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> (x.a) <span class="hljs-keyword">AS</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> x <span class="hljs-keyword">WHERE</span> x.b <span class="hljs-operator">&lt;</span> <span class="hljs-number">2</span> (<span class="hljs-keyword">on</span> <span class="hljs-keyword">every</span> <span class="hljs-keyword">partition</span>)<br>(<span class="hljs-number">2</span>) <span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">RESULT</span> <span class="hljs-keyword">TABLE</span> r2 <span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> (y.a) <span class="hljs-keyword">AS</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> y <span class="hljs-keyword">WHERE</span> y.c <span class="hljs-operator">&gt;</span> <span class="hljs-number">5</span> (<span class="hljs-keyword">on</span> <span class="hljs-keyword">every</span> <span class="hljs-keyword">partition</span>)<br>(<span class="hljs-number">3</span>) <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> REMOTE(r1(p)) <span class="hljs-keyword">JOIN</span> REMOTE(r2(p)) <span class="hljs-keyword">WHERE</span> r1.a <span class="hljs-operator">=</span> r2.a (<span class="hljs-keyword">on</span> <span class="hljs-keyword">every</span> <span class="hljs-keyword">partition</span>)<br></code></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>MemSQL 的查询优化器总体上就是 Rewrite + Physical Optimization + Plan Distribution。其中在 Rewrite 不仅使用了启发式规则，还使用了基于代价的规则，和 Oracle 的 CBQT 有点像。通过启发式规则在仅支持左深树的 Enumerator 的基础上引入 Bushy join 这一点比较特别。在物理优化时要考虑数据的分布和移动的情况，否则可能生成出较差的查询计划。在分发查询计划时，使用 SQL-like 的文本进行传输而不是将查询计划序列化之后分发，这一点是也是比较特别的。</p>]]></content>
    
    
    <categories>
      
      <category>论文笔记</category>
      
      <category>数据库</category>
      
      <category>优化器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>论文笔记</tag>
      
      <tag>数据库</tag>
      
      <tag>查询优化器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ShellScript 的一些实用使用方法</title>
    <link href="/2023/04/26/shell-tips/"/>
    <url>/2023/04/26/shell-tips/</url>
    
    <content type="html"><![CDATA[<p>本文章将持续更新，记录一些在开发过程中实用的 Shell 脚本。</p><h1 id="Linux-环境初始化"><a href="#Linux-环境初始化" class="headerlink" title="Linux 环境初始化"></a>Linux 环境初始化</h1><p>每次新建一个虚拟机或者登录到一个陌生的物理机时，都需要从头开始构建开发环境。这里提供一个 Shell 脚本，可以自动下载 JDK、Python、Oh-My-Zsh 等工具。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-meta">#!/bin/bash</span><br><br><span class="hljs-comment"># install tools</span><br>sudo apt-get update<br>sudo apt-get install -y python3-dev python3-pip python3-setuptools<br>pip3 install thefuck --user<br>sudo apt-get install -y zsh<br>sudo apt-get install -y openjdk-8-jdk <br><span class="hljs-comment"># install vscode</span><br>sudo apt install -y software-properties-common apt-transport-https wget<br>wget -q https://packages.microsoft.com/keys/microsoft.asc -O- | sudo apt-key add -<br>sudo add-apt-repository <span class="hljs-string">&quot;deb [arch=amd64] https://packages.microsoft.com/repos/vscode stable main&quot;</span><br>sudo apt install code<br><br><span class="hljs-comment"># ssh</span><br><span class="hljs-keyword">if</span> [ ! -e <span class="hljs-variable">$HOME</span>/.ssh ];<br><span class="hljs-keyword">then</span><br><span class="hljs-built_in">mkdir</span> -p <span class="hljs-variable">$HOME</span>/.ssh<br><span class="hljs-keyword">fi</span><br><br><span class="hljs-keyword">if</span> [ ! -e <span class="hljs-variable">$HOME</span>/.ssh/authorized_keys ];<br><span class="hljs-keyword">then</span><br><span class="hljs-built_in">touch</span> <span class="hljs-variable">$HOME</span>/.ssh/authorized_keys<br><span class="hljs-keyword">fi</span><br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;your public key&quot;</span> &gt;&gt; ~/.ssh/authorized_keys<br><br><span class="hljs-comment"># setup zsh</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;export PATH=$PATH:$HOME/.local/bin&#x27;</span> &gt;&gt; <span class="hljs-variable">$HOME</span>/.zshrc<br>chsh -s /bin/zsh<br><span class="hljs-built_in">source</span> ~/.zshrc<br><br><span class="hljs-comment"># install oh-my-zsh</span><br><span class="hljs-keyword">while</span> [ ! -e <span class="hljs-variable">$HOME</span>/.oh-my-zsh ];<br><span class="hljs-keyword">do</span><br>    sh -c <span class="hljs-string">&quot;<span class="hljs-subst">$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)</span>&quot;</span><br><span class="hljs-keyword">done</span><br><br><span class="hljs-comment"># installing oh-my-zsh-plugins</span><br><span class="hljs-keyword">while</span> [ ! -e <span class="hljs-variable">$HOME</span>/.oh-my-zsh ];<br><span class="hljs-keyword">do</span><br>    sh -c <span class="hljs-string">&quot;<span class="hljs-subst">$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)</span>&quot;</span><br><span class="hljs-keyword">done</span><br><br><span class="hljs-keyword">while</span> [ ! -e  <span class="hljs-variable">$HOME</span>/.oh-my-zsh/custom/plugins/zsh-autosuggestions ];<br><span class="hljs-keyword">do</span><br>    git <span class="hljs-built_in">clone</span> https://github.com/zsh-users/zsh-autosuggestions <span class="hljs-variable">$&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;</span>/plugins/zsh-autosuggestions<br><span class="hljs-keyword">done</span><br><br><span class="hljs-keyword">while</span> [ ! -e <span class="hljs-variable">$HOME</span>/.oh-my-zsh/custom/plugins/zsh-syntax-highlighting ];<br><span class="hljs-keyword">do</span><br>    git <span class="hljs-built_in">clone</span> https://github.com/zsh-users/zsh-syntax-highlighting.git <span class="hljs-variable">$&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;</span>/plugins/zsh-syntax-highlighting<br><span class="hljs-keyword">done</span><br><br><span class="hljs-keyword">while</span> [ ! -e <span class="hljs-variable">$HOME</span>/.oh-my-zsh/custom/plugins/zsh-z ];<br><span class="hljs-keyword">do</span><br>    git <span class="hljs-built_in">clone</span> https://github.com/agkozak/zsh-z <span class="hljs-variable">$&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;</span>/plugins/zsh-z<br><span class="hljs-keyword">done</span><br><br>sed -i <span class="hljs-string">&quot;s/plugins=.*/plugins=(git vscode zsh-autosuggestions zsh-syntax-highlighting z)/&quot;</span> <span class="hljs-variable">$HOME</span>/.zshrc<br><br><span class="hljs-built_in">source</span> ~/.zshrc<br><br></code></pre></td></tr></table></figure><h1 id="文件大小统计"><a href="#文件大小统计" class="headerlink" title="文件大小统计"></a>文件大小统计</h1><p>这个脚本用于统计在 -d 目录下符合 -p 模式文件名的文件的数目以及总大小，通常用于统计用户线上 TsFile 的总大小、总数目以及平均大小。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-meta">#!/bin/bash</span><br><br>total_files=0<br>total_size=0<br>pattern=*.tsfile<br><br><span class="hljs-keyword">while</span> <span class="hljs-built_in">getopts</span> <span class="hljs-string">&quot;d:p:&quot;</span> opt; <span class="hljs-keyword">do</span><br>  <span class="hljs-keyword">case</span> <span class="hljs-variable">$opt</span> <span class="hljs-keyword">in</span><br>    d)<br>      folders=<span class="hljs-variable">$OPTARG</span><br>      ;;<br>    p)<br>      pattern=<span class="hljs-variable">$OPTARG</span><br>      ;;<br>    *)<br>      <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Usage: <span class="hljs-variable">$0</span> -d &lt;comma-separated-directories&gt;&quot;</span><br>      <span class="hljs-built_in">exit</span> 1<br>      ;;<br>  <span class="hljs-keyword">esac</span><br><span class="hljs-keyword">done</span><br><br><span class="hljs-comment"># 使用 IFS（内部字段分隔符）分割字符串为数组</span><br>IFS=<span class="hljs-string">&#x27;,&#x27;</span> <span class="hljs-built_in">read</span> -ra folders_array &lt;&lt;&lt; <span class="hljs-string">&quot;<span class="hljs-variable">$folders</span>&quot;</span><br><br><span class="hljs-keyword">for</span> folder <span class="hljs-keyword">in</span> <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;folders_array[@]&#125;</span>&quot;</span>; <span class="hljs-keyword">do</span><br>  count=`find <span class="hljs-string">&quot;<span class="hljs-variable">$folder</span>&quot;</span> -<span class="hljs-built_in">type</span> f -name <span class="hljs-string">&quot;<span class="hljs-variable">$pattern</span>&quot;</span> -<span class="hljs-built_in">printf</span> <span class="hljs-string">&quot;%s\n&quot;</span>|<span class="hljs-built_in">wc</span> -l`<br>  res=`find <span class="hljs-string">&quot;<span class="hljs-variable">$folder</span>&quot;</span> -<span class="hljs-built_in">type</span> f -name <span class="hljs-string">&quot;<span class="hljs-variable">$pattern</span>&quot;</span> -<span class="hljs-built_in">printf</span> <span class="hljs-string">&quot;%s\n&quot;</span> | awk <span class="hljs-string">&#x27;&#123; sum += $1 &#125; END &#123; print sum &#125;&#x27;</span>`<br>  total_files=$((total_files + count))<br>  total_size=$((total_size + res))<br><span class="hljs-keyword">done</span><br><br><span class="hljs-keyword">if</span> [ <span class="hljs-string">&quot;<span class="hljs-variable">$total_files</span>&quot;</span> -ne 0 ]; <span class="hljs-keyword">then</span><br>  average_size=$((total_size / total_files))<br>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Overall Total files: <span class="hljs-variable">$total_files</span>, <span class="hljs-subst">$(echo <span class="hljs-string">&quot;scale=2; <span class="hljs-variable">$total_size</span> / 1048576&quot;</span> | bc)</span> MB&quot;</span><br>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Average file size: <span class="hljs-subst">$(echo <span class="hljs-string">&quot;scale=2; <span class="hljs-variable">$average_size</span> / 1048576&quot;</span> | bc)</span> MB&quot;</span><br><span class="hljs-keyword">else</span><br>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;No files found.&quot;</span><br><span class="hljs-keyword">fi</span><br></code></pre></td></tr></table></figure><p>用法：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ bash ./test.sh -d /data1/lxx,/data2/lxx,/data3/lxx -p <span class="hljs-string">&quot;*-*-2-*.tsfile&quot;</span><br>Overall Total files: 695, 1329241.62 MB<br>Average file size: 1912.57 MB<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Shell</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Shell</tag>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 基准测试工具：JMH</title>
    <link href="/2023/04/24/jhm-introduce/"/>
    <url>/2023/04/24/jhm-introduce/</url>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>在日常开发中，我们经常需要对一段代码进行性能测试，以验证我们的优化手段是否有效。通常我们的做法可能是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">someFunction</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">startTime</span> <span class="hljs-operator">=</span> System.nanoTime();<br>    <span class="hljs-comment">// do some execution</span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">timeCost</span> <span class="hljs-operator">=</span> System.nanoTime() - startTime;<br>    System.out.println(<span class="hljs-string">&quot;Time cost is %d ns&quot;</span>.format(timeCost));<br>&#125;<br></code></pre></td></tr></table></figure><p>如果我们需要对这段代码测试之后取平均值，那么我们还得在外面加上一个循环。如果需要计算方差等数据，还需要写更多额外的代码。如果考虑到 JIT 编译，那么我们还需要在测试之前加上 Warm up 的过程。有没有什么工具能够帮助我们完成这个过程呢？就像我们会用 JUnit 来帮助我们完成单元测试一样，Java 中的 Java Microbenchmark Harness（JMH）就是一个帮助我们完成基准测试的工具。</p><h1 id="什么是-JMH"><a href="#什么是-JMH" class="headerlink" title="什么是 JMH"></a>什么是 JMH</h1><p>JMH 是一个用于编写、执行和分析Java代码微基准测试的框架。微基准测试是一种性能测试方法，用于测量代码片段的执行时间。它们通常用于评估不同实现之间的性能差异，以确定哪个实现更适合特定场景。JMH由OpenJDK项目开发和维护，因此具有很高的可靠性和稳定性。</p><p>JMH的主要功能如下：</p><ol><li>自动执行：JMH会自动运行基准测试，控制迭代次数、预热时间等参数，以确保测试结果的准确性。</li><li>精确度：JMH通过减少常见的微基准测试陷阱（例如死代码消除、循环展开等）来提高测试的精确度。</li><li>灵活性：JMH支持多种输出格式，如CSV、JSON等，便于结果分析和可视化。同时，它还允许用户自定义基准测试的各种参数，如预热时间、迭代次数等。</li><li>注解驱动：JMH使用注解来标记基准测试方法，方便快速编写测试代码。</li></ol><h1 id="一个简单的例子"><a href="#一个简单的例子" class="headerlink" title="一个简单的例子"></a>一个简单的例子</h1><p>如果我们想要在一个 Maven 项目中使用 JMH，首先需要在 <code>pom.xml</code> 中加入</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.openjdk.jmh<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jmh-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.32<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.openjdk.jmh<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jmh-generator-annprocess<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.32<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在代码中，我们可以通过注解来指定我们要测试的内容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.openjdk.jmh.annotations.Benchmark;<br><span class="hljs-keyword">import</span> org.openjdk.jmh.annotations.BenchmarkMode;<br><span class="hljs-keyword">import</span> org.openjdk.jmh.annotations.Measurement;<br><span class="hljs-keyword">import</span> org.openjdk.jmh.annotations.Mode;<br><span class="hljs-keyword">import</span> org.openjdk.jmh.annotations.OutputTimeUnit;<br><span class="hljs-keyword">import</span> org.openjdk.jmh.annotations.Scope;<br><span class="hljs-keyword">import</span> org.openjdk.jmh.annotations.State;<br><span class="hljs-keyword">import</span> org.openjdk.jmh.annotations.Warmup;<br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><br><span class="hljs-meta">@State(Scope.Thread)</span><br><span class="hljs-meta">@BenchmarkMode(Mode.AverageTime)</span><br><span class="hljs-meta">@OutputTimeUnit(TimeUnit.NANOSECONDS)</span><br><span class="hljs-meta">@Warmup(iterations = 3, time = 1)</span><br><span class="hljs-meta">@Measurement(iterations = 3, time = 5)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JMHExample</span> &#123;<br>  <span class="hljs-meta">@Benchmark</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addArrayList</span><span class="hljs-params">()</span> &#123;<br>    List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10_0000</span>; i++) &#123;<br>      list.add(<span class="hljs-number">0</span>);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-meta">@Benchmark</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addLinkedList</span><span class="hljs-params">()</span> &#123;<br>    List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10_0000</span>; i++) &#123;<br>      list.add(<span class="hljs-number">0</span>);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在运行前，我们需要在 IDEA 中下载 JMH 插件，这个插件能够帮助我们在 IDEA 直接运行性能测试。下载成功以后，IDEA 的界面如图所示，我们直接点击左边的三个运行按钮即可运行 Benchmark。<br><img src="IDEA-plugins.png" width="50%"><br>运行结果如下：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-comment"># JMH version: 1.33</span><br><span class="hljs-comment"># VM version: JDK 11.0.2, OpenJDK 64-Bit Server VM, 11.0.2+9</span><br><span class="hljs-comment"># VM invoker: C:\Program Files\Java\jdk-11.0.2\bin\java.exe</span><br><span class="hljs-comment"># VM options: -javaagent:C:\Program Files\JetBrains\IntelliJ IDEA 2022.3.1\lib\idea_rt.jar=62315:C:\Program Files\JetBrains\IntelliJ IDEA 2022.3.1\bin -Dfile.encoding=UTF-8</span><br><span class="hljs-comment"># Blackhole mode: full + dont-inline hint (default, use -Djmh.blackhole.autoDetect=true to auto-detect)</span><br><span class="hljs-comment"># Warmup: 3 iterations, 1 s each</span><br><span class="hljs-comment"># Measurement: 3 iterations, 5 s each</span><br><span class="hljs-comment"># Timeout: 10 min per iteration</span><br><span class="hljs-comment"># Threads: 1 thread, will synchronize iterations</span><br><span class="hljs-comment"># Benchmark mode: Average time, time/op</span><br><span class="hljs-comment"># Benchmark: org.example.JMHExample.addArrayList</span><br><br><span class="hljs-comment"># Run progress: 0.00% complete, ETA 00:03:00</span><br><span class="hljs-comment"># Fork: 1 of 5</span><br><span class="hljs-comment"># Warmup Iteration   1: 339789.195 ns/op</span><br><span class="hljs-comment"># Warmup Iteration   2: 262514.212 ns/op</span><br><span class="hljs-comment"># Warmup Iteration   3: 259732.333 ns/op</span><br>Iteration   <span class="hljs-number">1</span>: <span class="hljs-number">269787.357</span> ns/op<br>Iteration   <span class="hljs-number">2</span>: <span class="hljs-number">307217.039</span> ns/op<br>Iteration   <span class="hljs-number">3</span>: <span class="hljs-number">368421.391</span> ns/op<br><br>...<br><br><br>Result <span class="hljs-string">&quot;org.example.JMHExample.addArrayList&quot;</span>:<br>  <span class="hljs-number">281986.682</span> ±(<span class="hljs-number">99.9</span>%) <span class="hljs-number">28381.842</span> ns/op [Average]<br>  (<span class="hljs-built_in">min</span>, <span class="hljs-built_in">avg</span>, <span class="hljs-built_in">max</span>) = (<span class="hljs-number">262447.982</span>, <span class="hljs-number">281986.682</span>, <span class="hljs-number">368421.391</span>), stdev = <span class="hljs-number">26548.393</span><br>  CI (<span class="hljs-number">99.9</span>%): [<span class="hljs-number">253604.840</span>, <span class="hljs-number">310368.524</span>] (assumes <span class="hljs-keyword">normal</span> distribution)<br><br><br><span class="hljs-comment"># JMH version: 1.33</span><br><span class="hljs-comment"># VM version: JDK 11.0.2, OpenJDK 64-Bit Server VM, 11.0.2+9</span><br><span class="hljs-comment"># VM invoker: C:\Program Files\Java\jdk-11.0.2\bin\java.exe</span><br><span class="hljs-comment"># VM options: -javaagent:C:\Program Files\JetBrains\IntelliJ IDEA 2022.3.1\lib\idea_rt.jar=62315:C:\Program Files\JetBrains\IntelliJ IDEA 2022.3.1\bin -Dfile.encoding=UTF-8</span><br><span class="hljs-comment"># Blackhole mode: full + dont-inline hint (default, use -Djmh.blackhole.autoDetect=true to auto-detect)</span><br><span class="hljs-comment"># Warmup: 3 iterations, 1 s each</span><br><span class="hljs-comment"># Measurement: 3 iterations, 5 s each</span><br><span class="hljs-comment"># Timeout: 10 min per iteration</span><br><span class="hljs-comment"># Threads: 1 thread, will synchronize iterations</span><br><span class="hljs-comment"># Benchmark mode: Average time, time/op</span><br><span class="hljs-comment"># Benchmark: org.example.JMHExample.addLinkedList</span><br><br><span class="hljs-comment"># Run progress: 50.00% complete, ETA 00:01:34</span><br><span class="hljs-comment"># Fork: 1 of 5</span><br><span class="hljs-comment"># Warmup Iteration   1: 349367.752 ns/op</span><br><span class="hljs-comment"># Warmup Iteration   2: 289455.708 ns/op</span><br><span class="hljs-comment"># Warmup Iteration   3: 287668.947 ns/op</span><br>Iteration   <span class="hljs-number">1</span>: <span class="hljs-number">274087.549</span> ns/op<br>Iteration   <span class="hljs-number">2</span>: <span class="hljs-number">266708.740</span> ns/op<br>Iteration   <span class="hljs-number">3</span>: <span class="hljs-number">268492.382</span> ns/op<br><br>...<br><br><br>Result <span class="hljs-string">&quot;org.example.JMHExample.addLinkedList&quot;</span>:<br>  <span class="hljs-number">266844.826</span> ±(<span class="hljs-number">99.9</span>%) <span class="hljs-number">4881.063</span> ns/op [Average]<br>  (<span class="hljs-built_in">min</span>, <span class="hljs-built_in">avg</span>, <span class="hljs-built_in">max</span>) = (<span class="hljs-number">258488.261</span>, <span class="hljs-number">266844.826</span>, <span class="hljs-number">274087.549</span>), stdev = <span class="hljs-number">4565.749</span><br>  CI (<span class="hljs-number">99.9</span>%): [<span class="hljs-number">261963.764</span>, <span class="hljs-number">271725.889</span>] (assumes <span class="hljs-keyword">normal</span> distribution)<br><br><br><span class="hljs-comment"># Run complete. Total time: 00:03:08</span><br><br>REMEMBER: The numbers below are just data. To gain reusable insights, you need <span class="hljs-built_in">to</span> follow up <span class="hljs-keyword">on</span><br>why <span class="hljs-keyword">the</span> numbers are <span class="hljs-keyword">the</span> way they are. Use profilers (see -prof, -lprof), design factorial<br>experiments, perform baseline <span class="hljs-keyword">and</span> negative tests that provide experimental control, make sure<br><span class="hljs-keyword">the</span> benchmarking environment is safe <span class="hljs-keyword">on</span> <span class="hljs-title">JVM</span>/<span class="hljs-title">OS</span>/<span class="hljs-title">HW</span> <span class="hljs-title">level</span>, <span class="hljs-title">ask</span> <span class="hljs-title">for</span> <span class="hljs-title">reviews</span> <span class="hljs-title">from</span> <span class="hljs-title">the</span> <span class="hljs-title">domain</span> <span class="hljs-title">experts</span>.<br>Do <span class="hljs-keyword">not</span> assume <span class="hljs-keyword">the</span> numbers tell you what you want them <span class="hljs-built_in">to</span> tell.<br><br>Benchmark                 Mode  Cnt       Score       Error  Units<br>JMHExample.addArrayList   avgt   <span class="hljs-number">15</span>  <span class="hljs-number">281986.682</span> ± <span class="hljs-number">28381.842</span>  ns/op<br>JMHExample.addLinkedList  avgt   <span class="hljs-number">15</span>  <span class="hljs-number">266844.826</span> ±  <span class="hljs-number">4881.063</span>  ns/op<br></code></pre></td></tr></table></figure><p>在这个例子中，我们使用注解在代码中指定了我们测试的方式。</p><p><code>@State</code> 注解指定了对象在工作线程之间的共享程度。按照示例代码中 <code>@State(Scope.Thread)</code> 的指示，JMH 会为每一个线程都创建一个 <code>JMHExample</code> 实例。如果我们将注解改为 <code>@State(Scope.Benchmark)</code>，那么 JMH 就会在多个线程之间共享一个 <code>JMHExample</code> 实例，这样可以帮助我们测试某个方法在多线程下的性能。此外，还可以选择 <code>@State(Scope.Group)</code> ，JMH 将在一个线程组内共享一个 <code>JMHExample</code> 实例。</p><p><code>@BenchmarkMode(Mode.AverageTime)</code> 注解指定了这次测试主要统计平均的响应时间，此外还有吞吐、响应时间范围、跳过 JIT 的响应时间可选。</p><p><code>@OutputTimeUnit(TimeUnit.NANOSECONDS)</code> 指定了输出结果的单位是纳秒。</p><p><code>@Warmup(iterations = 3, time = 1)</code> 指定了预热阶段的配置，每次基准测试前进行三次预热，每次预热的迭代时间为 1 秒。预热可以在测试之前提前运行代码，有利于 JVM 对待测代码进行 JIT 编译，提高代码的运行效率。</p><p><code>@Measurement(iterations = 3, time = 5)</code> 制定了基准测试的配置，基准测试总共运行 3 次，每次测试都运行 5 秒钟。</p><p><code>@Benchmark</code> 需要写在需要测试的方法前，就像 JUnit 里的 <code>@Test</code> 注解一样，框架会根据这些注解找到需要测试的函数，并根据配置运行这些函数。在同一个类里，<code>@Benchmark</code> 可以写在多个函数中，测试时 JMH 框架会依次对这些被标记的函数进行测试。</p><p>对于简单的函数，我们可以在 IDEA 中运行测试。对于一些平台依赖的代码（例如必须在 Linux 上运行的代码）或者耗时较久的代码，我们可以把代码编译成 jar 包放到服务器上运行。因此，需要在 <code>pom.xml</code> 中加入</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">finalName</span>&gt;</span>JMH-Test<span class="hljs-tag">&lt;/<span class="hljs-name">finalName</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-shade-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.4.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">executions</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>package<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>shade<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">transformers</span>&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">transformer</span></span><br><span class="hljs-tag">                                    <span class="hljs-attr">implementation</span>=<span class="hljs-string">&quot;org.apache.maven.plugins.shade.resourceManifestResourceTransformer&quot;</span>&gt;</span><br>                                <span class="hljs-tag">&lt;<span class="hljs-name">mainClass</span>&gt;</span>org.example.JMHExample<span class="hljs-tag">&lt;/<span class="hljs-name">mainClass</span>&gt;</span><br>                            <span class="hljs-tag">&lt;/<span class="hljs-name">transformer</span>&gt;</span><br>                        <span class="hljs-tag">&lt;/<span class="hljs-name">transformers</span>&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">executions</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在类 <code>JMHExmaple</code> 中加入主函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> RunnerException &#123;<br>    <span class="hljs-type">Options</span> <span class="hljs-variable">opt</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OptionsBuilder</span>()<br>        .include(JMHExample.class.getSimpleName())<br>        .result(<span class="hljs-string">&quot;result.json&quot;</span>)<br>        .resultFormat(ResultFormatType.JSON).build();<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runner</span>(opt).run();<br>&#125;<br></code></pre></td></tr></table></figure><p>然后执行 <code>mvn clean package</code>，然后将 <code>JMH-Test.jar</code> 发送到服务器上，并使用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">java -jar JMH-Test.jar<br></code></pre></td></tr></table></figure><p>命令运行即可。运行结束后，结果会保存在 <code>result.json</code> 文件中。</p><h1 id="JMH-的其他注解"><a href="#JMH-的其他注解" class="headerlink" title="JMH 的其他注解"></a>JMH 的其他注解</h1><p>我们在实例中介绍了 <code>@State</code>、<code>@BenchmarkMode</code>、<code>@OutputTimeUnit</code>、<code>@Warmup</code>、<code>@Measurement</code> 以及 <code>@Benchmark</code> 注解，JMH 中还有其他很实用的注解。</p><p>与 JUnit 类似，JMH 中的 <code>@Setup</code> 和 <code>@TearDown</code> 注解允许我们标记基准测试的初始化函数和终止函数。在这两个函数中可以处理一些资源的初始化和回收工作。</p><p><code>@Fork</code> 注解用于指定 Measurement 的次数，例如 <code>@Fork(1)</code>，对某一段代码就只会运行一次 Measurement。<code>@Fork</code> 注解必须作用于一个类上或者一个方法上。默认情况下，Fork 的值为 5，也就是对一个方法会进行 5 次的 Measurement。</p><p><code>@Threads</code> 注解可以指定某个测试的线程数，可以作用于类上或者方法上。</p><p>JMH 在运行前会对代码进行一定的优化，例如删去一些 Dead Code。例如下面这段代码，在 JMH 中的运行时间是差不多的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@State(Scope.Thread)</span><br><span class="hljs-meta">@BenchmarkMode(Mode.AverageTime)</span><br><span class="hljs-meta">@OutputTimeUnit(TimeUnit.NANOSECONDS)</span><br><span class="hljs-meta">@Warmup(iterations = 3, time = 1)</span><br><span class="hljs-meta">@Measurement(iterations = 3, time = 5)</span><br><span class="hljs-meta">@Fork(1)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JMHExample</span>  &#123;<br><br>    <span class="hljs-meta">@Benchmark</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span><br>    &#123;<br>    &#125;<br><br>    <span class="hljs-meta">@Benchmark</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test2</span><span class="hljs-params">()</span><br>    &#123;<br>        Math.log(Math.PI);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> RunnerException &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Options</span> <span class="hljs-variable">opts</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OptionsBuilder</span>()<br>                .include(JmhTestApp13_CompilerControl1.class.getSimpleName())<br>                .build();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runner</span>(opts).run();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Benchmark</span>         Mode  Cnt  Score   Error  Units<br><span class="hljs-attribute">JMHExample</span>.test1  avgt    <span class="hljs-number">3</span>  <span class="hljs-number">0</span>.<span class="hljs-number">215</span> ± <span class="hljs-number">0</span>.<span class="hljs-number">007</span>  ns/op<br><span class="hljs-attribute">JMHExample</span>.test2  avgt    <span class="hljs-number">3</span>  <span class="hljs-number">0</span>.<span class="hljs-number">214</span> ± <span class="hljs-number">0</span>.<span class="hljs-number">022</span>  ns/op<br></code></pre></td></tr></table></figure><p>原因是 JMH 识别出了 <code>test2</code> 中的 <code>Math.log(Math.PI)</code> 是一段死代码，并没有任何意义，因此没有执行。<code>@CompilerControl</code> 可以控制 JMH 的这类行为，例如在 <code>test2</code> 方法前 <code>@CompilerControl.Mode.EXCLUDE</code> 就可以令编译器不做去掉死代码的行为，得到的结果为</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Benchmark</span>         Mode  Cnt   Score   Error  Units<br><span class="hljs-attribute">JMHExample</span>.test1  avgt    <span class="hljs-number">3</span>   <span class="hljs-number">0</span>.<span class="hljs-number">213</span> ± <span class="hljs-number">0</span>.<span class="hljs-number">008</span>  ns/op<br><span class="hljs-attribute">JMHExample</span>.test2  avgt    <span class="hljs-number">3</span>  <span class="hljs-number">44</span>.<span class="hljs-number">397</span> ± <span class="hljs-number">5</span>.<span class="hljs-number">358</span>  ns/op<br></code></pre></td></tr></table></figure><p>可以看出，此时两个函数之间性能有了明显差距。<code>CompilerControl.Mode</code> 有 6 种选择，分别是</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">BREAK</span>: 在生成的代码中插入断点；<br><span class="hljs-keyword">PRINT</span>：打印代码编译后的汇编代码；<br><span class="hljs-keyword">EXCLUDE</span>：将代码从编译去除（不参与编译期的优化）；<br>INLINE：强制代码内联；<br>DONT_INLINE：强制代码不内联；<br>COMPILE_ONLY：只对这份代码做编译，不做其他事情。<br></code></pre></td></tr></table></figure><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://www.wdbyte.com/2020/08/develop/tool-jmh/">JMH - Java 代码性能基准测试</a></p><p><a href="https://blog.csdn.net/u014282578/article/details/127952593">性能调优之JMH必知必会1：什么是JMH</a></p><p><a href="https://www.cnblogs.com/54chensongxia/p/15485421.html">JMH 使用指南</a></p><p><a href="https://github.com/openjdk/jmh/tree/master/jmh-samples/src/main/java/org/openjdk/jmh/samples"> JMH 官方提供的用例</a></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LevelDB 源代码阅读（五）：SSTable</title>
    <link href="/2021/07/22/leveldb-source-code-reading-5/"/>
    <url>/2021/07/22/leveldb-source-code-reading-5/</url>
    
    <content type="html"><![CDATA[<p>在 LSM 结构的数据库中，SSTable 指的是数据落盘之后形成的文件。在 LevelDB 中，SSTable 是以 <em>.sst</em> 文件的形式存在的。本文将介绍 LevelDB 中 SSTable 的写过程和读过程。</p><h1 id="SSTable-的总体结构"><a href="#SSTable-的总体结构" class="headerlink" title="SSTable 的总体结构"></a>SSTable 的总体结构</h1><img src="SSTable-structrue.png"><p>图中所示为 SSTable 文件的整体结构。文件的前部分为数据部分（DataBlock），文件的结尾部分为数据的索引。在索引部分，又分为了 Filter Block 、 Meta Index Block 、 Index Block 以及 Footer 。下面我们依次来介绍 SSTable 中每个结构的具体细节。</p><h2 id="数据部分"><a href="#数据部分" class="headerlink" title="数据部分"></a>数据部分</h2><p>数据部分由许多个 DataBlock 组成，在 LevelDB 中，一个 DataBlock 的大小默认设置为 4 KB 。每个 DataBlock 由三个部分组成：数据部分（Data）、压缩类型（CompressionType）以及校验和（CRC）。</p><img src="SSTable-datablock-struct.png"><p>Data 中存储的即是数据库的数据内容； CompressionType 中记录了对原始数据使用的压缩方式，在 LevelDB 中默认的压缩方式是 Snappy ； CRC 部分则记录了对 Data 以及 CompressionType 进行 CRC32 计算得到的结果，用来保证数据的正确性。</p><p>Data 部分有更加细微的结构：</p><img src="SSTable-datastruct.png"><p>图中每一个 Entry 就是一组 Key-Value 对，由于 DataBlock 在写入时，在一组键之间会寻找可以共享的长度（详见后面的写入过程），因此 Entry 块的后面会有若干个 Restart Point ，每个 Restart Point 会指向一个 Entry ，这个 Entry 不会与其前面的 Entry 有共享的键内容。每次读取数据时，都要从 Restart Point 指向的某个 Entry 开始往后读，直到读到目标键值对为止。最后，Data 中还标记了 Restart Point 的个数。前面提到，在编码是会对一组 Key 进行键值共享，因此一个 Entry 的结构为</p><img src="SSTable-entrystruct.png"><h2 id="索引部分"><a href="#索引部分" class="headerlink" title="索引部分"></a>索引部分</h2><p>索引部分主要包含两大部分：数据的索引及元数据、布隆过滤器的索引及内容。</p><h3 id="Filter-Block"><a href="#Filter-Block" class="headerlink" title="Filter Block"></a>Filter Block</h3><p>Filter Block 主要装载布隆过滤器的内容，所谓布隆过滤器就是一种用于快速模糊查找的数据结构，关于布隆过滤器的详细介绍可以查看这篇<a href="https://zhuanlan.zhihu.com/p/43263751">文章</a>。</p><img src="SSTable-filter-block-struct.png"><p>Filter Block 中的 Filter Data 块保存了布隆过滤器的具体内容；绿色部分的 Offset of Filter Data $i$ 则记录了第 $i$ 个 Filter Data 的偏移量；Offset of Filter Offset 则记录了 Offset of Filter Data 1 的偏移量；Base Lg 默认值为 11 ，表示每 2 KB 的数据创建一个新的过滤器来存放过滤数据。因此，Filter Data $i$ 就记录了文件中位置位于 [2KB $\times (i-1)$, 2KB $\times i$] 范围内数据的 Filter 数据。</p><h3 id="Meta-Index-Block"><a href="#Meta-Index-Block" class="headerlink" title="Meta Index Block"></a>Meta Index Block</h3><p>Meta Index Block 用以记录 Filter Block 在整个 SSTable 中的位置，整个 Block 只记录了一组键值对，Key 为 “filter.” 与过滤器名称组成的常量字符串，值则为 Filter Block 的索引信息（包括 Filter Block 在 SSTable 中的偏移量以及 Filter Block 的数据长度）序列化后的内容。</p><h3 id="Index-Block"><a href="#Index-Block" class="headerlink" title="Index Block"></a>Index Block</h3><p>Index Block 记录了数据部分的索引信息。具体地，Index Block 由多个 &lt;Max Key&gt;&lt;Offset&gt;&lt;Length&gt; 这样的三元组构成。一个三元组对应了数据部分的一个 DataBlock ，三元组中的信息分别记录了其最大键值、在文件中的偏移量以及大小三个信息。</p><img src="SSTable-indexblock-struct.png"><p>在写入 DataBlock 的过程中，不同的 DataBlock 和 DataBlock 内部都是严格有序的（因为 MemTable 中的 SkipList 也是有序的），因此在查询时可以通过 IndexBlock 中记录的 MaxKey信息进行快速查找，然后根据 Offset 和 Length 信息将找到的 DataBlock 读取出来，再进行下一步的处理。</p><h3 id="Footer"><a href="#Footer" class="headerlink" title="Footer"></a>Footer</h3><p>Footer 的大小是固定的，为 48 个字节，其存储了 MetaIndexBlock 的 offset、 IndexBlock 的 offset 以及一串 Magic Word ，内容为 “<a href="http://code.google.com/p/leveldb/">http://code.google.com/p/leveldb/</a>“ 字符串 sha1 哈希的前 8 个字节。</p><h1 id="SSTable-的写流程"><a href="#SSTable-的写流程" class="headerlink" title="SSTable 的写流程"></a>SSTable 的写流程</h1><p>在 LevelDB 中，Level 0 级的 SSTable 由内存中的 <em>Immutable MemTable</em> 写出得到，这个过程在 <em>db_impl.cc</em> 中的 <code>WriteLevel0Table</code> 中和主线程异步地执行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// db_impl.cc</span><br><span class="hljs-function">Status <span class="hljs-title">DBImpl::WriteLevel0Table</span><span class="hljs-params">(MemTable* mem, VersionEdit* edit,</span></span><br><span class="hljs-params"><span class="hljs-function">                                Version* base)</span> </span>&#123;<br>  mutex_.<span class="hljs-built_in">AssertHeld</span>();<br>  <span class="hljs-type">const</span> <span class="hljs-type">uint64_t</span> start_micros = env_-&gt;<span class="hljs-built_in">NowMicros</span>();<br>  <span class="hljs-comment">// 生成文件元数据</span><br>  FileMetaData meta;<br>  meta.number = versions_-&gt;<span class="hljs-built_in">NewFileNumber</span>();<br>  pending_outputs_.<span class="hljs-built_in">insert</span>(meta.number);<br>  Iterator* iter = mem-&gt;<span class="hljs-built_in">NewIterator</span>();<br>  <span class="hljs-built_in">Log</span>(options_.info_log, <span class="hljs-string">&quot;Level-0 table #%llu: started&quot;</span>,<br>      (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span>)meta.number);<br><br>  Status s;<br>  &#123;<br>    mutex_.<span class="hljs-built_in">Unlock</span>();<br>    <span class="hljs-comment">// 将 Immutable MemTable 写入到文件中</span><br>    s = <span class="hljs-built_in">BuildTable</span>(dbname_, env_, options_, table_cache_, iter, &amp;meta);<br>    mutex_.<span class="hljs-built_in">Lock</span>();<br>  &#125;<br><br>  <span class="hljs-built_in">Log</span>(options_.info_log, <span class="hljs-string">&quot;Level-0 table #%llu: %lld bytes %s&quot;</span>,<br>      (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span>)meta.number, (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span>)meta.file_size,<br>      s.<span class="hljs-built_in">ToString</span>().<span class="hljs-built_in">c_str</span>());<br>  <span class="hljs-keyword">delete</span> iter;<br>  pending_outputs_.<span class="hljs-built_in">erase</span>(meta.number);<br><br>  <span class="hljs-comment">// Note that if file_size is zero, the file has been deleted and</span><br>  <span class="hljs-comment">// should not be added to the manifest.</span><br>  <span class="hljs-type">int</span> level = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">ok</span>() &amp;&amp; meta.file_size &gt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-type">const</span> Slice min_user_key = meta.smallest.<span class="hljs-built_in">user_key</span>();<br>    <span class="hljs-type">const</span> Slice max_user_key = meta.largest.<span class="hljs-built_in">user_key</span>();<br>    <span class="hljs-keyword">if</span> (base != <span class="hljs-literal">nullptr</span>) &#123;<br>      <span class="hljs-comment">// 在所有无文件和该 SSTable 不发生 key 重叠的 Level 中</span><br>      <span class="hljs-comment">// 选择一个最大的 Level 插入该文件</span><br>      level = base-&gt;<span class="hljs-built_in">PickLevelForMemTableOutput</span>(min_user_key, max_user_key);<br>    &#125;<br>    <span class="hljs-comment">// 将文件加入到文件列表中</span><br>    edit-&gt;<span class="hljs-built_in">AddFile</span>(level, meta.number, meta.file_size, meta.smallest,<br>                  meta.largest);<br>  &#125;<br><br>  CompactionStats stats;<br>  stats.micros = env_-&gt;<span class="hljs-built_in">NowMicros</span>() - start_micros;<br>  stats.bytes_written = meta.file_size;<br>  stats_[level].<span class="hljs-built_in">Add</span>(stats);<br>  <span class="hljs-keyword">return</span> s;<br>&#125;<br></code></pre></td></tr></table></figure><p>将 <em>MemTable</em> 中的内容写入到 SSTable 中的过程在 <code>BuildTable</code> 中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// builder.cc</span><br><span class="hljs-function">Status <span class="hljs-title">BuildTable</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; dbname, Env* env, <span class="hljs-type">const</span> Options&amp; options,</span></span><br><span class="hljs-params"><span class="hljs-function">                  TableCache* table_cache, Iterator* iter, FileMetaData* meta)</span> </span>&#123;<br>  Status s;<br>  meta-&gt;file_size = <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">// 移动到 SkipList 中第一个元素的位置</span><br>  iter-&gt;<span class="hljs-built_in">SeekToFirst</span>();<br><br>  <span class="hljs-comment">// 创建文件</span><br>  std::string fname = <span class="hljs-built_in">TableFileName</span>(dbname, meta-&gt;number);<br>  <span class="hljs-keyword">if</span> (iter-&gt;<span class="hljs-built_in">Valid</span>()) &#123;<br>    WritableFile* file;<br>    s = env-&gt;<span class="hljs-built_in">NewWritableFile</span>(fname, &amp;file);<br>    <span class="hljs-keyword">if</span> (!s.<span class="hljs-built_in">ok</span>()) &#123;<br>      <span class="hljs-keyword">return</span> s;<br>    &#125;<br><br>    TableBuilder* builder = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TableBuilder</span>(options, file);<br>    <span class="hljs-comment">// SkipList 中的数据是按照顺序排列的</span><br>    <span class="hljs-comment">// 因此第一个键就是其最小的键</span><br>    meta-&gt;smallest.<span class="hljs-built_in">DecodeFrom</span>(iter-&gt;<span class="hljs-built_in">key</span>());<br>    Slice key;<br>    <span class="hljs-comment">// 不断地将 SkipList 中的数据插入到 TableBuilder 中</span><br>    <span class="hljs-keyword">for</span> (; iter-&gt;<span class="hljs-built_in">Valid</span>(); iter-&gt;<span class="hljs-built_in">Next</span>()) &#123;<br>      key = iter-&gt;<span class="hljs-built_in">key</span>();<br>      builder-&gt;<span class="hljs-built_in">Add</span>(key, iter-&gt;<span class="hljs-built_in">value</span>());<br>    &#125;<br>    <span class="hljs-comment">// 最后一个键就是最大的键</span><br>    <span class="hljs-keyword">if</span> (!key.<span class="hljs-built_in">empty</span>()) &#123;<br>      meta-&gt;largest.<span class="hljs-built_in">DecodeFrom</span>(key);<br>    &#125;<br><br>    <span class="hljs-comment">// Finish and check for builder errors</span><br>    <span class="hljs-comment">// Finish 时会写入索引部分的数据</span><br>    <span class="hljs-comment">// 包括 FilterBlock、MetaIndexBlock、IndexBlock 以及 Footer</span><br>    s = builder-&gt;<span class="hljs-built_in">Finish</span>();<br>    <br>    <span class="hljs-comment">// 一些检查文件状态的代码</span><br>    ...<br>  <span class="hljs-keyword">return</span> s;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 <code>BuildTable</code> 函数中， <em>MemTable</em> 中的内容被不断添加到 <em>TableBuilder</em> 中。当 <em>MemTable</em> 中的数据都被添加到了 <em>TableBuilder</em> 中后，SSTable 中数据部分就已经写入完成了。随后调用 <em>TableBuilder</em> 的 <code>Finish</code> 函数，这个函数会写入索引部分的块，包括 FilterBlock（可选）、 MetaIndexBlock、 IndexBlock 以及 Footer 。写入完成后，程序会对新生成文件的状态进行一些检查，通过检查后文件会被添加到内存的文件列表中，供查询使用。</p><p>下面我们看看数据在 <em>TableBuilder</em> 中是如何被编码的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// table_builder.cc</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TableBuilder::Add</span><span class="hljs-params">(<span class="hljs-type">const</span> Slice&amp; key, <span class="hljs-type">const</span> Slice&amp; value)</span> </span>&#123;<br>  Rep* r = rep_;<br>  <span class="hljs-built_in">assert</span>(!r-&gt;closed);<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">ok</span>()) <span class="hljs-keyword">return</span>;<br>  <span class="hljs-comment">// 保证插入是有序的</span><br>  <span class="hljs-keyword">if</span> (r-&gt;num_entries &gt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-built_in">assert</span>(r-&gt;options.comparator-&gt;<span class="hljs-built_in">Compare</span>(key, <span class="hljs-built_in">Slice</span>(r-&gt;last_key)) &gt; <span class="hljs-number">0</span>);<br>  &#125;<br><br>  <span class="hljs-comment">// 如果当前内存中的 Block 是空的，那么就为这个 Block 生成一个 IndexKey</span><br>  <span class="hljs-comment">// 这个 IndexKey 不一定会出现在用户写入的数据中，而是根据计算得出的</span><br>  <span class="hljs-comment">// 可以将这个 Block 和上一个 Block 分开的最短的 Key</span><br>  <span class="hljs-comment">// 例如上一个 Block 的 IndexKey 是 &quot;the great&quot;， 当前 Block 插入的第一个</span><br>  <span class="hljs-comment">// key 为 &quot;the hello&quot; ，那么这个 IndexKey 需要满足</span><br>  <span class="hljs-comment">// &quot;the great&quot; &lt; IndexKey &lt;= &quot;the hello&quot;</span><br>  <span class="hljs-comment">// 例如，其值可能是 &quot;the h&quot;</span><br>  <span class="hljs-keyword">if</span> (r-&gt;pending_index_entry) &#123;<br>    <span class="hljs-built_in">assert</span>(r-&gt;data_block.<span class="hljs-built_in">empty</span>());<br>    r-&gt;options.comparator-&gt;<span class="hljs-built_in">FindShortestSeparator</span>(&amp;r-&gt;last_key, key);<br>    std::string handle_encoding;<br>    r-&gt;pending_handle.<span class="hljs-built_in">EncodeTo</span>(&amp;handle_encoding);<br>    <span class="hljs-comment">// 将这个 IndexKey 记录到 index block 中</span><br>    r-&gt;index_block.<span class="hljs-built_in">Add</span>(r-&gt;last_key, <span class="hljs-built_in">Slice</span>(handle_encoding));<br>    r-&gt;pending_index_entry = <span class="hljs-literal">false</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// 如果需要生成 BloomFilter ，则将这个数据编码进 BloomFilter 中</span><br>  <span class="hljs-keyword">if</span> (r-&gt;filter_block != <span class="hljs-literal">nullptr</span>) &#123;<br>    r-&gt;filter_block-&gt;<span class="hljs-built_in">AddKey</span>(key);<br>  &#125;<br><br>  r-&gt;last_key.<span class="hljs-built_in">assign</span>(key.<span class="hljs-built_in">data</span>(), key.<span class="hljs-built_in">size</span>());<br>  r-&gt;num_entries++;<br>  <span class="hljs-comment">// 将数据编码进 DataBlock 中</span><br>  r-&gt;data_block.<span class="hljs-built_in">Add</span>(key, value);<br><br>  <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> estimated_block_size = r-&gt;data_block.<span class="hljs-built_in">CurrentSizeEstimate</span>();<br>  <span class="hljs-comment">// 如果 DataBlock 的大小大于阈值（默认为 4KB），则将这个 DataBlock 刷到磁盘上</span><br>  <span class="hljs-keyword">if</span> (estimated_block_size &gt;= r-&gt;options.block_size) &#123;<br>    <span class="hljs-built_in">Flush</span>();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这里，数据还是没有被直接编码，而是被插入到了 <em>DataBlock</em> 中。如果一个 <em>DataBlock</em> 的大小超过了阈值（默认为 4KB），那么它就会被刷到文件中。除了插入数据，<code>Add</code> 函数还做了其他的事情：在 <em>IndexBlock</em> 中为本 <em>DataBlock</em> 生成一个 <em>IndexKey</em> ，这个 <em>IndexKey</em> 不一定会出现在用户插入的数据中，而是一个计算出来的最短的可以区别两个 <em>DataBlock</em> 的 key 。如果用户在配置中开启了布隆过滤器，那么在这个函数中也会将 key 编码到 <em>FilterBlock</em> 中。</p><p>在 <em>DataBlock</em> 的 <code>Add</code> 函数中，真正执行了对数据的编码。下面我们来看看这个函数是如何执行的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// block_builder.cc</span><br><span class="hljs-comment">// BlockBuilder 会寻找不同 key 之间可以共享的部分，以此进行压缩</span><br><span class="hljs-comment">// 压缩只会对 key 进行，不会对 value 进行</span><br><span class="hljs-comment">// 压缩后的格式为</span><br><span class="hljs-comment">// &lt;与前一个 key 的共享长度&gt;&lt;不共享的长度&gt;&lt;value 的长度&gt;&lt;key 不共享的部分&gt;&lt;value&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">BlockBuilder::Add</span><span class="hljs-params">(<span class="hljs-type">const</span> Slice&amp; key, <span class="hljs-type">const</span> Slice&amp; value)</span> </span>&#123;<br>  <span class="hljs-function">Slice <span class="hljs-title">last_key_piece</span><span class="hljs-params">(last_key_)</span></span>;<br>  <span class="hljs-built_in">assert</span>(!finished_);<br>  <span class="hljs-built_in">assert</span>(counter_ &lt;= options_-&gt;block_restart_interval);<br>  <span class="hljs-built_in">assert</span>(buffer_.<span class="hljs-built_in">empty</span>()  <span class="hljs-comment">// No values yet?</span><br>         || options_-&gt;comparator-&gt;<span class="hljs-built_in">Compare</span>(key, last_key_piece) &gt; <span class="hljs-number">0</span>);<br>  <span class="hljs-comment">// 如果当前共享内容的键数目没有达到阈值，就寻找当前键和上一个键之间重叠的部分</span><br>  <span class="hljs-type">size_t</span> shared = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">if</span> (counter_ &lt; options_-&gt;block_restart_interval) &#123;<br>    <span class="hljs-comment">// See how much sharing to do with previous string</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> min_length = std::<span class="hljs-built_in">min</span>(last_key_piece.<span class="hljs-built_in">size</span>(), key.<span class="hljs-built_in">size</span>());<br>    <span class="hljs-keyword">while</span> ((shared &lt; min_length) &amp;&amp; (last_key_piece[shared] == key[shared])) &#123;<br>      shared++;<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// Restart compression</span><br>    restarts_.<span class="hljs-built_in">push_back</span>(buffer_.<span class="hljs-built_in">size</span>());<br>    counter_ = <span class="hljs-number">0</span>;<br>  &#125;<br>  <span class="hljs-comment">// 当前键和上一个键不重叠的大小</span><br>  <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> non_shared = key.<span class="hljs-built_in">size</span>() - shared;<br><br>  <span class="hljs-comment">// 将 &quot;&lt;shared&gt;&lt;non_shared&gt;&lt;value_size&gt;&quot; 编码到 buffer_ 中</span><br>  <span class="hljs-built_in">PutVarint32</span>(&amp;buffer_, shared);<br>  <span class="hljs-built_in">PutVarint32</span>(&amp;buffer_, non_shared);<br>  <span class="hljs-built_in">PutVarint32</span>(&amp;buffer_, value.<span class="hljs-built_in">size</span>());<br><br>  <span class="hljs-comment">// 将当前键不共享的部分以及 value 的内容编码到 buffer_ 中</span><br>  buffer_.<span class="hljs-built_in">append</span>(key.<span class="hljs-built_in">data</span>() + shared, non_shared);<br>  buffer_.<span class="hljs-built_in">append</span>(value.<span class="hljs-built_in">data</span>(), value.<span class="hljs-built_in">size</span>());<br><br>  <span class="hljs-comment">// 更新 last_key_</span><br>  last_key_.<span class="hljs-built_in">resize</span>(shared);<br>  last_key_.<span class="hljs-built_in">append</span>(key.<span class="hljs-built_in">data</span>() + shared, non_shared);<br>  <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">Slice</span>(last_key_) == key);<br>  counter_++;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 <em>BlockBuilder</em> 中，所有的数据都被一起编码到一个 buffer 中。但是中编码之前，程序会对 key 进行一次压缩。这个压缩是通过寻找当前 key 和上一个 key 之间共同的长度来完成的。当然，这个共享不会无限进行下去，每隔若干个 key ，程序会就重新开始计算共享键。例如，如果系统设置的共享键数目是 16 （默认值），那么第 1 个到第 16 个 key 之间是有内容共享的，第 16 个和第 17 个键则不计算其共享的内容，第 17 个键到第 32 键之间又继续计算其共享内容。这是因为最终数据会被编码成</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-section">&lt;SharedKeyLength&gt;</span> <span class="hljs-section">&lt;NonSharedKeyLength&gt;</span> <span class="hljs-section">&lt;ValueLength&gt;</span> <span class="hljs-section">&lt;NonSharedKeyContent&gt;</span> <span class="hljs-section">&lt;ValueContent&gt;</span><br></code></pre></td></tr></table></figure><p>的形式，因此读取一个键时，只能知道它与前一个键不共享部分的内容，如果要读取其完整值，则必须知道它与前一个键共享的内容。因此，我们需要一直往前找，直到找到一个 SharedKeyLength 为 0 的 key ，然后往后读，一直读到我们需要的 key 为止。如果整个 <em>DataBlock</em> 都一起共享键，那么每次我们读取一个键都要从这个 <em>DataBlock</em> 的第一个键开始读，效率非常低。为了避免这种情况， <em>DataBlock</em> 中键值的共享在每一个 Entry 中进行，每 16 个键（默认值）保存在一个 Entry 中，并且为每个 Entry 在文件中维护了一个 Restart Point ，用于指向这个 Entry 。这样，在读取一个 Key 时，只需要找到这个 Key 所在的 Entry ，然后从这个 Entry 的第一个 Key 开始读即可。这样在读取一个 Key 时既不会读取太多其他的 Key ，也可以有效压缩 Key 的大小 。最后需要注意的是，这里通过共享值的压缩方法只会对 Key 进行，对于 Value 则是不做任何处理直接编码进 buffer 中。</p><h1 id="SSTable-的读流程"><a href="#SSTable-的读流程" class="headerlink" title="SSTable 的读流程"></a>SSTable 的读流程</h1><p><em>SSTable</em> 的读流程其实就是写流程的逆过程。读流程的入口在 <em>table_cache.cc</em> 中的 <code>FindTable</code> 函数中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// table_cache.cc</span><br><span class="hljs-function">Status <span class="hljs-title">TableCache::FindTable</span><span class="hljs-params">(<span class="hljs-type">uint64_t</span> file_number, <span class="hljs-type">uint64_t</span> file_size,</span></span><br><span class="hljs-params"><span class="hljs-function">                             Cache::Handle** handle)</span> </span>&#123;<br>  Status s;<br>  <span class="hljs-type">char</span> buf[<span class="hljs-built_in">sizeof</span>(file_number)];<br>  <span class="hljs-built_in">EncodeFixed64</span>(buf, file_number);<br>  <span class="hljs-function">Slice <span class="hljs-title">key</span><span class="hljs-params">(buf, <span class="hljs-keyword">sizeof</span>(buf))</span></span>;<br>  <span class="hljs-comment">// 在 Cache 中查找是否缓存 SSTable 的 handle</span><br>  *handle = cache_-&gt;<span class="hljs-built_in">Lookup</span>(key);<br>  <span class="hljs-keyword">if</span> (*handle == <span class="hljs-literal">nullptr</span>) &#123;<br>  <span class="hljs-comment">// 如果没有缓存，就从磁盘中打开这个 SSTable</span><br>    std::string fname = <span class="hljs-built_in">TableFileName</span>(dbname_, file_number);<br>    RandomAccessFile* file = <span class="hljs-literal">nullptr</span>;<br>    Table* table = <span class="hljs-literal">nullptr</span>;<br>    s = env_-&gt;<span class="hljs-built_in">NewRandomAccessFile</span>(fname, &amp;file);<br>    <span class="hljs-keyword">if</span> (!s.<span class="hljs-built_in">ok</span>()) &#123;<br>      std::string old_fname = <span class="hljs-built_in">SSTTableFileName</span>(dbname_, file_number);<br>      <span class="hljs-keyword">if</span> (env_-&gt;<span class="hljs-built_in">NewRandomAccessFile</span>(old_fname, &amp;file).<span class="hljs-built_in">ok</span>()) &#123;<br>        s = Status::<span class="hljs-built_in">OK</span>();<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">ok</span>()) &#123;<br>    <span class="hljs-comment">// 打开文件，读取内容</span><br>      s = Table::<span class="hljs-built_in">Open</span>(options_, file, file_size, &amp;table);<br>    &#125;<br><br>    <span class="hljs-comment">// some check codes</span><br>    ...<br>  &#125;<br>  <span class="hljs-keyword">return</span> s;<br>&#125;<br></code></pre></td></tr></table></figure><p>在读取一个文件之前，程序首先会在 <em>TableCache</em> 查找有无该文件的 handle ，如果没有，才会从磁盘中读取这个文件。 <code>Table::Open</code> 函数从磁盘上读取这个文件的 <em>Footer</em> 和 <em>IndexBlock</em> ，如果文件有 <em>FilterBlock</em>，也会将 <em>MetaIndexBlock</em> 读入内存中。当这些数据都被读完后，程序会对读取的状态进行一些检查，通过检查后这个文件的 handle 就会被缓存在 <em>TableCache</em> 中，供其他过程使用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// table.cc</span><br><span class="hljs-function">Status <span class="hljs-title">Table::Open</span><span class="hljs-params">(<span class="hljs-type">const</span> Options&amp; options, RandomAccessFile* file,</span></span><br><span class="hljs-params"><span class="hljs-function">                   <span class="hljs-type">uint64_t</span> size, Table** table)</span> </span>&#123;<br>  *table = <span class="hljs-literal">nullptr</span>;<br>  <span class="hljs-keyword">if</span> (size &lt; Footer::kEncodedLength) &#123;<br>    <span class="hljs-keyword">return</span> Status::<span class="hljs-built_in">Corruption</span>(<span class="hljs-string">&quot;file is too short to be an sstable&quot;</span>);<br>  &#125;<br><br>  <span class="hljs-comment">// 读取 footer</span><br>  <span class="hljs-type">char</span> footer_space[Footer::kEncodedLength];<br>  Slice footer_input;<br>  Status s = file-&gt;<span class="hljs-built_in">Read</span>(size - Footer::kEncodedLength, Footer::kEncodedLength,<br>                        &amp;footer_input, footer_space);<br>  <span class="hljs-keyword">if</span> (!s.<span class="hljs-built_in">ok</span>()) <span class="hljs-keyword">return</span> s;<br><br>  Footer footer;<br>  s = footer.<span class="hljs-built_in">DecodeFrom</span>(&amp;footer_input);<br>  <span class="hljs-keyword">if</span> (!s.<span class="hljs-built_in">ok</span>()) <span class="hljs-keyword">return</span> s;<br><br>  <span class="hljs-comment">// 读取 index block</span><br>  BlockContents index_block_contents;<br>  ReadOptions opt;<br>  <span class="hljs-keyword">if</span> (options.paranoid_checks) &#123;<br>    opt.verify_checksums = <span class="hljs-literal">true</span>;<br>  &#125;<br>  s = <span class="hljs-built_in">ReadBlock</span>(file, opt, footer.<span class="hljs-built_in">index_handle</span>(), &amp;index_block_contents);<br><br>  <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">ok</span>()) &#123;<br>    <span class="hljs-comment">// We&#x27;ve successfully read the footer and the index block: we&#x27;re</span><br>    <span class="hljs-comment">// ready to serve requests.</span><br>    Block* index_block = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Block</span>(index_block_contents);<br>    Rep* rep = <span class="hljs-keyword">new</span> Table::Rep;<br>    rep-&gt;options = options;<br>    rep-&gt;file = file;<br>    rep-&gt;metaindex_handle = footer.<span class="hljs-built_in">metaindex_handle</span>();<br>    rep-&gt;index_block = index_block;<br>    rep-&gt;cache_id = (options.block_cache ? options.block_cache-&gt;<span class="hljs-built_in">NewId</span>() : <span class="hljs-number">0</span>);<br>    rep-&gt;filter_data = <span class="hljs-literal">nullptr</span>;<br>    rep-&gt;filter = <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-comment">// 生成新的 Table 对象，并且读取 BloomFilter</span><br>    *table = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Table</span>(rep);<br>    (*table)-&gt;<span class="hljs-built_in">ReadMeta</span>(footer);<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> s;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面是在 <code>Open</code> 函数中读取文件 <em>Footer</em> 和 <em>IndexBlock</em> 的代码，在 <code>table-&gt;ReadMeta</code> 中会读取文件的 <em>MetaIndexBlock</em>（如果存在的话）。</p><p>至此，一个文件的索引部分（除了 FilterBlock ）已经被加载到了内存中。下面让我们看看当我们需要从已经加载到了内存中的文件里读取一个具体的 Key 需要经过怎样的流程。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// table.cc</span><br><span class="hljs-function">Status <span class="hljs-title">Table::InternalGet</span><span class="hljs-params">(<span class="hljs-type">const</span> ReadOptions&amp; options, <span class="hljs-type">const</span> Slice&amp; k, <span class="hljs-type">void</span>* arg,</span></span><br><span class="hljs-params"><span class="hljs-function">                          <span class="hljs-type">void</span> (*handle_result)(<span class="hljs-type">void</span>*, <span class="hljs-type">const</span> Slice&amp;,</span></span><br><span class="hljs-params"><span class="hljs-function">                                                <span class="hljs-type">const</span> Slice&amp;))</span> </span>&#123;<br>  Status s;<br>  <span class="hljs-comment">// 从 IndexBlock 中找到可能保存搜索键 k 的 dataBlock 对应的 IndexKey</span><br>  Iterator* iiter = rep_-&gt;index_block-&gt;<span class="hljs-built_in">NewIterator</span>(rep_-&gt;options.comparator);<br>  iiter-&gt;<span class="hljs-built_in">Seek</span>(k);<br>  <span class="hljs-keyword">if</span> (iiter-&gt;<span class="hljs-built_in">Valid</span>()) &#123;<br>    Slice handle_value = iiter-&gt;<span class="hljs-built_in">value</span>();<br>    FilterBlockReader* filter = rep_-&gt;filter;<br>    BlockHandle handle;<br>    <span class="hljs-keyword">if</span> (filter != <span class="hljs-literal">nullptr</span> &amp;&amp; handle.<span class="hljs-built_in">DecodeFrom</span>(&amp;handle_value).<span class="hljs-built_in">ok</span>() &amp;&amp;<br>        !filter-&gt;<span class="hljs-built_in">KeyMayMatch</span>(handle.<span class="hljs-built_in">offset</span>(), k)) &#123;<br>    <span class="hljs-comment">// 如果 bloomFilter 存在，并且 BloomFilter 指示不存在这个 key ，查找失败</span><br>      <span class="hljs-comment">// Not found</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 构建一个前面在 IndexBlock 中找到的目标 Block 的 iterator</span><br>      Iterator* block_iter = <span class="hljs-built_in">BlockReader</span>(<span class="hljs-keyword">this</span>, options, iiter-&gt;<span class="hljs-built_in">value</span>());<br>      <span class="hljs-comment">// 通过 block iterator 查找键</span><br>      block_iter-&gt;<span class="hljs-built_in">Seek</span>(k);<br>      <span class="hljs-keyword">if</span> (block_iter-&gt;<span class="hljs-built_in">Valid</span>()) &#123;<br>        (*handle_result)(arg, block_iter-&gt;<span class="hljs-built_in">key</span>(), block_iter-&gt;<span class="hljs-built_in">value</span>());<br>      &#125;<br>      s = block_iter-&gt;<span class="hljs-built_in">status</span>();<br>      <span class="hljs-keyword">delete</span> block_iter;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">ok</span>()) &#123;<br>    s = iiter-&gt;<span class="hljs-built_in">status</span>();<br>  &#125;<br>  <span class="hljs-keyword">delete</span> iiter;<br>  <span class="hljs-keyword">return</span> s;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Table::InternalGet</code> 函数完成了在 <em>SSTable</em> 中查找的过程。首先程序会从 <em>IndexBlock</em> 找到可能保存搜索键 k 的 <em>DataBlock</em> 的 IndexKey （因为 <em>DataBlock</em> 是有序存放的，因此用二分查找即可找到），然后检查是否有布隆过滤器，有的话检查布隆过滤器中是否编码了这个键，如果没编码，那么代表这个数据不存在于这个 <em>SSTable</em> 中，查找失败；否则，如果布隆过滤器不存在或者布隆过滤器中编码了这一个 key ，那么就对前面在 <em>IndexBlock</em> 查找到的指向的 <em>DataBlock</em> 新建一个 iterator ，然后通过这个 iterator 找到这个键。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// block.cc</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Seek</span><span class="hljs-params">(<span class="hljs-type">const</span> Slice&amp; target)</span> <span class="hljs-keyword">override</span> </span>&#123;<br>  <span class="hljs-comment">// Binary search in restart array to find the last restart point</span><br>  <span class="hljs-comment">// with a key &lt; target</span><br>  <span class="hljs-type">uint32_t</span> left = <span class="hljs-number">0</span>;<br>  <span class="hljs-type">uint32_t</span> right = num_restarts_ - <span class="hljs-number">1</span>;<br>  <span class="hljs-type">int</span> current_key_compare = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">// 如果已经进行过查找了，那么就检查上一轮查找最终结束的位置是在当前 key 的左边还是右边</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Valid</span>()) &#123;<br>    <span class="hljs-comment">// If we&#x27;re already scanning, use the current position as a starting</span><br>    <span class="hljs-comment">// point. This is beneficial if the key we&#x27;re seeking to is ahead of the</span><br>    <span class="hljs-comment">// current position.</span><br>    current_key_compare = <span class="hljs-built_in">Compare</span>(key_, target);<br>    <span class="hljs-keyword">if</span> (current_key_compare &lt; <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-comment">// key_ is smaller than target</span><br>      left = restart_index_;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (current_key_compare &gt; <span class="hljs-number">0</span>) &#123;<br>      right = restart_index_;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// We&#x27;re seeking to the key we&#x27;re already at.</span><br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// 使用二分查找寻找这个 key 所在的位置</span><br>  <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>    <span class="hljs-type">uint32_t</span> mid = (left + right + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>    <span class="hljs-type">uint32_t</span> region_offset = <span class="hljs-built_in">GetRestartPoint</span>(mid);<br>    <span class="hljs-type">uint32_t</span> shared, non_shared, value_length;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* key_ptr =<br>        <span class="hljs-built_in">DecodeEntry</span>(data_ + region_offset, data_ + restarts_, &amp;shared,<br>                    &amp;non_shared, &amp;value_length);<br>    <span class="hljs-keyword">if</span> (key_ptr == <span class="hljs-literal">nullptr</span> || (shared != <span class="hljs-number">0</span>)) &#123;<br>      <span class="hljs-built_in">CorruptionError</span>();<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-function">Slice <span class="hljs-title">mid_key</span><span class="hljs-params">(key_ptr, non_shared)</span></span>;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Compare</span>(mid_key, target) &lt; <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-comment">// Key at &quot;mid&quot; is smaller than &quot;target&quot;.  Therefore all</span><br>      <span class="hljs-comment">// blocks before &quot;mid&quot; are uninteresting.</span><br>      left = mid;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// Key at &quot;mid&quot; is &gt;= &quot;target&quot;.  Therefore all blocks at or</span><br>      <span class="hljs-comment">// after &quot;mid&quot; are uninteresting.</span><br>      right = mid - <span class="hljs-number">1</span>;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// We might be able to use our current position within the restart block.</span><br>  <span class="hljs-comment">// This is true if we determined the key we desire is in the current block</span><br>  <span class="hljs-comment">// and is after than the current key.</span><br>  <span class="hljs-built_in">assert</span>(current_key_compare == <span class="hljs-number">0</span> || <span class="hljs-built_in">Valid</span>());<br>  <span class="hljs-comment">// 如果我们当前已经在这个 RestartPoint 指向的 Entry 里了（上一次查找）</span><br>  <span class="hljs-comment">// 并且我们要找的键就在这个 Entry 中，那么我们就可以不用 seek</span><br>  <span class="hljs-type">bool</span> skip_seek = left == restart_index_ &amp;&amp; current_key_compare &lt; <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">if</span> (!skip_seek) &#123;<br>  <span class="hljs-comment">// 跳转到 key 所在的 RestartPoint 指向的 Entry</span><br>    <span class="hljs-built_in">SeekToRestartPoint</span>(left);<br>  &#125;<br>  <span class="hljs-comment">// 在一个 Entry 中从头往后读</span><br>  <span class="hljs-comment">// Linear search (within restart block) for first key &gt;= target</span><br>  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">ParseNextKey</span>()) &#123;<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Compare</span>(key_, target) &gt;= <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面这段代码就是在 <em>BlockIterator</em> 中查找搜索 key 的过程。函数的主体是一个二分搜索，找到这个 key 所在的 Entry ，然后从这个 Entry 的第一个键开始顺序地往下读，直到读到我们要查找的 key 为止。</p><p>到这里 SSTable 的读写过程就解析完了，这里值得体会的是对文件分块分层次组织的过程，从 SSTable 到 DataBlock 再到 Entry ，多个数据层次使得文件写和文件读可以更高效。同时，将索引和数据放在一个文件里，使得索引和数据在删除与移动时都是一体的。</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>源代码阅读</category>
      
      <category>LevelDB</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>LevelDB 源代码阅读（四）：MemTable</title>
    <link href="/2021/07/15/leveldb-source-code-reading-4/"/>
    <url>/2021/07/15/leveldb-source-code-reading-4/</url>
    
    <content type="html"><![CDATA[<p>在 <a href="/2021/07/08/leveldb-source-code-reading-1/" title="LevelDB 源代码阅读（一）：写流程">LevelDB 源代码阅读（一）：写流程</a> 中，我们在介绍写入时最终讲到写入的数据被编码成 internalKey 然后被插入到 <em>SkipList</em> 中。在本文中，我们将结合 LevelDB 的源代码，详细介绍 MemTable 的结构。</p><h1 id="MemTable-基本结构"><a href="#MemTable-基本结构" class="headerlink" title="MemTable 基本结构"></a>MemTable 基本结构</h1><p>代码中有关于 <em>MemTable</em> 的定义和实现在 memtable.{h&#x2F;cc} 中，我们先从 <em>MemTable</em> 的定义开始了解其基础结构和功能。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// memtable.h</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MemTable</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">MemTable</span><span class="hljs-params">(<span class="hljs-type">const</span> InternalKeyComparator&amp; comparator)</span></span>;<br><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Ref</span><span class="hljs-params">()</span> </span>&#123; ++refs_; &#125;<br><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Unref</span><span class="hljs-params">()</span> </span>&#123;<br>    --refs_;<br>    <span class="hljs-built_in">assert</span>(refs_ &gt;= <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (refs_ &lt;= <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">ApproximateMemoryUsage</span><span class="hljs-params">()</span></span>;<br>  <span class="hljs-function">Iterator* <span class="hljs-title">NewIterator</span><span class="hljs-params">()</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Add</span><span class="hljs-params">(SequenceNumber seq, ValueType type, <span class="hljs-type">const</span> Slice&amp; key,</span></span><br><span class="hljs-params"><span class="hljs-function">           <span class="hljs-type">const</span> Slice&amp; value)</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Get</span><span class="hljs-params">(<span class="hljs-type">const</span> LookupKey&amp; key, std::string* value, Status* s)</span></span>;<br>  <br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">KeyComparator</span> &#123;<br>    <span class="hljs-type">const</span> InternalKeyComparator comparator;<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">KeyComparator</span><span class="hljs-params">(<span class="hljs-type">const</span> InternalKeyComparator&amp; c)</span> : comparator(c) &#123;</span>&#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* a, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* b)</span> <span class="hljs-type">const</span></span>;<br>  &#125;;<br><br>  <span class="hljs-keyword">typedef</span> SkipList&lt;<span class="hljs-type">const</span> <span class="hljs-type">char</span>*, KeyComparator&gt; Table;<br><br>  ~<span class="hljs-built_in">MemTable</span>();<br><br>  KeyComparator comparator_;<br>  <span class="hljs-type">int</span> refs_;<br>  Arena arena_;<br>  Table table_;<br>&#125;<br></code></pre></td></tr></table></figure><p><em>MemTable</em> 是一个有引用计数的类型，当其引用计数为 0 时（除了刚创建时）就会从内存中删除。<code>Ref</code> 函数和 <code>Unref</code> 函数就是用以管理引用计数的函数。<code>ApproximateMemoryUsage</code> 函数会计算当前 <em>MemTable</em> 的内存占用值，但是这个值不是精确的。<code>NewIterator</code> 函数会返回一个 <em>Iterator</em> 对象，用以正序遍历 <em>MemTable</em> 中的数据。<code>Add</code> 函数和 <code>Get</code> 的函数则分别对应写数据和读数据，注意 <code>Add</code> 函数既包含了新增值或修改值，也包含删除值。在数据部分，<em>MemTable</em> 维护了四个私有变量：<em>comparator_<em>、</em>refs_<em>、</em>arena_</em> 和 <em>table_</em> 。<em>comparator_</em> 的定义就在 <em>MemTable</em> 中，它重载了 <code>()</code> 运算符，可以像函数一样被调用，主要用以比较 <em>MemTable</em> 中 key 的大小，以便对 key 进行排序。<em>refs_</em> 是一个整数类型的值，用以维护引用计数。<em>arena_</em> 是一个 <em>Arena</em> 对象，主要用于管理内存。<em>table_</em> 是一个 <em>SkipList</em> 类，是 <em>MemTable</em> 中实际存储数据的结构。</p><img src="Leveldb-internal_key.png" width=65%><p>在 <a href="/2021/07/08/leveldb-source-code-reading-1/" title="LevelDB 源代码阅读（一）：写流程">LevelDB 源代码阅读（一）：写流程</a> 中我们已经简要介绍过了 <em>MemTable</em> 的写入过程：写入的 key 和 value（删除则没有 value）以及写入操作对应的 sequence number 会编码成一个如图所示的 entry ，然后这个 entry 会被插入到 <em>table_</em> 中（即 SkipList 中）。关于 SkipList 的结构以及如何在 SkipList 中插入数据，我们在下面一节中描述。</p><p><em>MemTable</em> 的读操作代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// memtable.cc</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">MemTable::Get</span><span class="hljs-params">(<span class="hljs-type">const</span> LookupKey&amp; key, std::string* value, Status* s)</span> </span>&#123;<br>  Slice memkey = key.<span class="hljs-built_in">memtable_key</span>();<br>  <span class="hljs-function">Table::Iterator <span class="hljs-title">iter</span><span class="hljs-params">(&amp;table_)</span></span>;<br>  iter.<span class="hljs-built_in">Seek</span>(memkey.<span class="hljs-built_in">data</span>());<br>  <span class="hljs-keyword">if</span> (iter.<span class="hljs-built_in">Valid</span>()) &#123;<br>    <span class="hljs-comment">// entry format is:</span><br>    <span class="hljs-comment">//    klength  varint32</span><br>    <span class="hljs-comment">//    userkey  char[klength]</span><br>    <span class="hljs-comment">//    tag      uint64</span><br>    <span class="hljs-comment">//    vlength  varint32</span><br>    <span class="hljs-comment">//    value    char[vlength]</span><br>    <span class="hljs-comment">// Check that it belongs to same user key.  We do not check the</span><br>    <span class="hljs-comment">// sequence number since the Seek() call above should have skipped</span><br>    <span class="hljs-comment">// all entries with overly large sequence numbers.</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* entry = iter.<span class="hljs-built_in">key</span>();<br>    <span class="hljs-type">uint32_t</span> key_length;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* key_ptr = <span class="hljs-built_in">GetVarint32Ptr</span>(entry, entry + <span class="hljs-number">5</span>, &amp;key_length);<br>    <span class="hljs-keyword">if</span> (comparator_.comparator.<span class="hljs-built_in">user_comparator</span>()-&gt;<span class="hljs-built_in">Compare</span>(<br>            <span class="hljs-built_in">Slice</span>(key_ptr, key_length - <span class="hljs-number">8</span>), key.<span class="hljs-built_in">user_key</span>()) == <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-comment">// Correct user key</span><br>      <span class="hljs-type">const</span> <span class="hljs-type">uint64_t</span> tag = <span class="hljs-built_in">DecodeFixed64</span>(key_ptr + key_length - <span class="hljs-number">8</span>);<br>      <span class="hljs-keyword">switch</span> (<span class="hljs-built_in">static_cast</span>&lt;ValueType&gt;(tag &amp; <span class="hljs-number">0xff</span>)) &#123;<br>        <span class="hljs-keyword">case</span> kTypeValue: &#123;<br>          Slice v = <span class="hljs-built_in">GetLengthPrefixedSlice</span>(key_ptr + key_length);<br>          value-&gt;<span class="hljs-built_in">assign</span>(v.<span class="hljs-built_in">data</span>(), v.<span class="hljs-built_in">size</span>());<br>          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">case</span> kTypeDeletion:<br>          *s = Status::<span class="hljs-built_in">NotFound</span>(<span class="hljs-built_in">Slice</span>());<br>          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>代码中首先声明了一个 <em>table_</em> 的迭代器 <em>iter</em> ，然后调用迭代器的 <code>Seek</code> 函数，寻找 SkipList 中有对应 <em>Key</em> 的节点。由于 SkipList 是有序的，这里 <em>iter</em> 找到的节点是所有拥有待搜索键且其 sequence number 大于此次操作的 sequence number 的节点中 sequence number 最大的一个，因此其数据也是最新的。找到这个节点之后，将这个节点进行解析，获取其 key 的值以及节点对应的操作类型。如果节点对应的操作类型是 insert ，那么则返回 insert 对应的 value ；如果是 delete ，那么则返回空。</p><p>不难看出，<em>MemTable</em> 无论是写还是读，其涉及到的核心组件就是 SkipList 。那么 SkipList 是一种怎么样的数据结构呢，又是如何实现的呢，下面让我们一起来看一看。</p><h1 id="跳表-SkipList"><a href="#跳表-SkipList" class="headerlink" title="跳表 SkipList"></a>跳表 SkipList</h1><p>跳表的英文名称是 SkipList ，最早由 William Pugh 在论文 <a href="https://dl.acm.org/doi/abs/10.1145/78973.78977">SkipList: A Probabilistic Alternative to Balanaced Tree</a> 中提出。在 <a href="/2021/07/13/SkipList/" title="跳表：平衡树的概率替代方案">跳表：平衡树的概率替代方案</a> 一文中，笔者对 SkipList 这篇论文涉及到数据结构与算法的前半部分进行了翻译，有兴趣的读者可以自行阅读论文原文或者翻译。</p><p>简单来说，SkipList 就是有序链表加上索引。如图 1a ，这是一个顺序链表。虽然所有的元素已经排好序，但是如果我们想要从中查找一个元素，还是需要将所有元素遍历一遍，直到找到我们想要的元素为止。例如我们需要查找 19，那么总共需要遍历 7 个元素。</p><div style="font-size:11px; text-align:center; line-height: 0px"><img src="Figure1.png" width=65%><p><em>图 1</em></p></div><p>下面我们考虑给链表增加索引：如果隔一个元素，我们就增加一个索引，使其指向下一个具有索引的节点，那我们就获得了图 1b 所示的链表。在这个链表中进行查找，首先我们从高层指针开始查找，如果高层指针指向的下一个元素的值小于等于我们的预期值，那么我们就跳转到这个指针指向的元素；否则，我们就检查下一个层级的指针是否满足条件。如果我们已经在一级指针了，那么当前所在的元素就是我们要找的元素（如果元素存在）。如在图 1b 中我们要查找 19 ，那么经过的节点顺序是 头节点 -&gt; 6 -&gt; 9 -&gt; 17（17 的二级指针指向的下一个元素为 21 ，大于 19 ，因此我们转换到一级指针进行搜索）-&gt; 19 （19 的一级指针指向的下一个元素为 21 ，大于 19 ，那么此时所在的节点就是我们要搜索的节点）。不算头节点，总共遍历了 4 个元素。</p><p>那我们还可以继续优化吗？当然可以！我们先定义一个概念，一个拥有 n 个指针的链表节点称为 n 级节点。前面所述的情况有两种节点：一级节点和二级节点。我们可以在二级指针的基础上，增加一个三级指针，相当于三级索引。假如每隔 1 个元素，就有一个二级节点，其指向下一个级别大于等于二的节点；每隔三个元素，就有一个三级节点，其指向下一个为三的节点。这样，我们就得到了图 1c 的链表。搜索的顺序同样是从高级别指针开始向低级别指针搜索，在这个链表中查找 19 的路径为：头节点 -&gt; 9（在这里先检查三级指针指向的下一个元素，其值为 21 ，大于我们要搜索的 19 ，因此切换到二级指针进行检查） -&gt; 17 （在这里先检查二级指针，其指向的下一个元素的值为 21 ，大于我们要搜索的 19 ，因此切换到一级指针进行检查） -&gt; 19 （在这里检查一级指针指向的下一个元素，其值为 21 ，大于我们要搜索的 19 ，因此这个节点就是我们要搜索的节点）。加了三级指针以后，我们查找只遍历了 3 个节点。</p><p>除了三级指针，我们还可以继续加上更多级别的指针，如图 1d 就有 4 级指针，查找到 19 要遍历 3 个节点。在以上这几种情况中，拥有 50% 的结点为 1 级节点，25% 的结点为 2 级节点，12.5% 的结点为 3 级节点，6.25% 的结点为 4 级节点。我们定义一个链表的级别为其中所有节点中最高级的那个节点的级别，图 1 a-d 的四个链表分别对应了一级到四级链表。随着链表的级别升高，各种级别的节点的比例是可计算的，为 $1&#x2F;2^n$ ，其中 $n$ 为节点的级别。</p><div style="font-size:11px; text-align:center; line-height: 0px"><img src="Figure3.png" width=65%><p><em>图 2：跳表的插入流程</em></p></div><p>如果要遵循上面这种不同级别节点出现的位置都非常规律的规定（$n$ 级节点每隔 $2^n - 1$ 个节点出现一次），那么对链表进行插入和删除是非常麻烦的。跳表和这种索引链表的区别在于，跳表去掉了对不同级别的节点出现的位置的规定，仅要求它们的比例符合规定。如图 1e 就是一个跳表，其中不同级别节点出现的位置并不规定，但其总体分布遵循索引链表的分布。在插入时，一个新的节点的级别通过随机数进行生成，这个随机数的生成的分布要遵循索引链表的节点级别分布。生成节点后，我们通过搜索算法将这个节点插入，并设置好对应级别的指针，即完成了数据的插入。删除时先搜索到对应的节点并将其移除，然后设置好其他节点的指针即可。可以证明，跳表的搜索、插入和删除算法都是 $O(log(n))$ 的，其中 $n$ 为跳表中元素的数量。</p><p>跳表的理论分析就分析到这，下面让我们来看看在 LevelDB 中跳表是如何实现的。</p><h1 id="LevelDB-中的跳表"><a href="#LevelDB-中的跳表" class="headerlink" title="LevelDB 中的跳表"></a>LevelDB 中的跳表</h1><p>我们先来看看 <em>SkipList</em> 的声明：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// skiplist.h </span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Key, <span class="hljs-keyword">class</span> <span class="hljs-title class_">Comparator</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SkipList</span> &#123;<br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>;<br><br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-comment">// Create a new SkipList object that will use &quot;cmp&quot; for comparing keys,</span><br>  <span class="hljs-comment">// and will allocate memory using &quot;*arena&quot;.  Objects allocated in the arena</span><br>  <span class="hljs-comment">// must remain allocated for the lifetime of the skiplist object.</span><br>  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">SkipList</span><span class="hljs-params">(Comparator cmp, Arena* arena)</span></span>;<br><br>  <span class="hljs-built_in">SkipList</span>(<span class="hljs-type">const</span> SkipList&amp;) = <span class="hljs-keyword">delete</span>;<br>  SkipList&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> SkipList&amp;) = <span class="hljs-keyword">delete</span>;<br><br>  <span class="hljs-comment">// Insert key into the list.</span><br>  <span class="hljs-comment">// REQUIRES: nothing that compares equal to key is currently in the list.</span><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Insert</span><span class="hljs-params">(<span class="hljs-type">const</span> Key&amp; key)</span></span>;<br><br>  <span class="hljs-comment">// Returns true iff an entry that compares equal to key is in the list.</span><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Contains</span><span class="hljs-params">(<span class="hljs-type">const</span> Key&amp; key)</span> <span class="hljs-type">const</span></span>;<br><br>  <span class="hljs-comment">// Iteration over the contents of a skip list</span><br>  <span class="hljs-keyword">class</span> <span class="hljs-title class_">Iterator</span> &#123;<br>   <span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// Initialize an iterator over the specified list.</span><br>    <span class="hljs-comment">// The returned iterator is not valid.</span><br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Iterator</span><span class="hljs-params">(<span class="hljs-type">const</span> SkipList* list)</span></span>;<br><br>    <span class="hljs-comment">// Returns true iff the iterator is positioned at a valid node.</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Valid</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><br>    <span class="hljs-comment">// Returns the key at the current position.</span><br>    <span class="hljs-comment">// REQUIRES: Valid()</span><br>    <span class="hljs-function"><span class="hljs-type">const</span> Key&amp; <span class="hljs-title">key</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><br>    <span class="hljs-comment">// Advances to the next position.</span><br>    <span class="hljs-comment">// REQUIRES: Valid()</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Next</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">// Advances to the previous position.</span><br>    <span class="hljs-comment">// REQUIRES: Valid()</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Prev</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">// Advance to the first entry with a key &gt;= target</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Seek</span><span class="hljs-params">(<span class="hljs-type">const</span> Key&amp; target)</span></span>;<br><br>    <span class="hljs-comment">// Position at the first entry in list.</span><br>    <span class="hljs-comment">// Final state of iterator is Valid() iff list is not empty.</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SeekToFirst</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">// Position at the last entry in list.</span><br>    <span class="hljs-comment">// Final state of iterator is Valid() iff list is not empty.</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SeekToLast</span><span class="hljs-params">()</span></span>;<br><br>   <span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">const</span> SkipList* list_;<br>    Node* node_;<br>    <span class="hljs-comment">// Intentionally copyable</span><br>  &#125;;<br><br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-keyword">enum</span> &#123; kMaxHeight = <span class="hljs-number">12</span> &#125;;<br><br>  <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">GetMaxHeight</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> max_height_.<span class="hljs-built_in">load</span>(std::memory_order_relaxed);<br>  &#125;<br><br>  <span class="hljs-function">Node* <span class="hljs-title">NewNode</span><span class="hljs-params">(<span class="hljs-type">const</span> Key&amp; key, <span class="hljs-type">int</span> height)</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">RandomHeight</span><span class="hljs-params">()</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Equal</span><span class="hljs-params">(<span class="hljs-type">const</span> Key&amp; a, <span class="hljs-type">const</span> Key&amp; b)</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> (<span class="hljs-built_in">compare_</span>(a, b) == <span class="hljs-number">0</span>); &#125;<br><br>  <span class="hljs-comment">// Return true if key is greater than the data stored in &quot;n&quot;</span><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">KeyIsAfterNode</span><span class="hljs-params">(<span class="hljs-type">const</span> Key&amp; key, Node* n)</span> <span class="hljs-type">const</span></span>;<br><br>  <span class="hljs-comment">// Return the earliest node that comes at or after key.</span><br>  <span class="hljs-comment">// Return nullptr if there is no such node.</span><br>  <span class="hljs-comment">//</span><br>  <span class="hljs-comment">// If prev is non-null, fills prev[level] with pointer to previous</span><br>  <span class="hljs-comment">// node at &quot;level&quot; for every level in [0..max_height_-1].</span><br>  <span class="hljs-function">Node* <span class="hljs-title">FindGreaterOrEqual</span><span class="hljs-params">(<span class="hljs-type">const</span> Key&amp; key, Node** prev)</span> <span class="hljs-type">const</span></span>;<br><br>  <span class="hljs-comment">// Return the latest node with a key &lt; key.</span><br>  <span class="hljs-comment">// Return head_ if there is no such node.</span><br>  <span class="hljs-function">Node* <span class="hljs-title">FindLessThan</span><span class="hljs-params">(<span class="hljs-type">const</span> Key&amp; key)</span> <span class="hljs-type">const</span></span>;<br><br>  <span class="hljs-comment">// Return the last node in the list.</span><br>  <span class="hljs-comment">// Return head_ if list is empty.</span><br>  <span class="hljs-function">Node* <span class="hljs-title">FindLast</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><br>  <span class="hljs-comment">// Immutable after construction</span><br>  Comparator <span class="hljs-type">const</span> compare_;<br>  Arena* <span class="hljs-type">const</span> arena_;  <span class="hljs-comment">// Arena used for allocations of nodes</span><br><br>  Node* <span class="hljs-type">const</span> head_;<br><br>  <span class="hljs-comment">// Modified only by Insert().  Read racily by readers, but stale</span><br>  <span class="hljs-comment">// values are ok.</span><br>  std::atomic&lt;<span class="hljs-type">int</span>&gt; max_height_;  <span class="hljs-comment">// Height of the entire list</span><br><br>  <span class="hljs-comment">// Read/written only by Insert().</span><br>  Random rnd_;<br>&#125;;<br></code></pre></td></tr></table></figure><p>首先我们看 SkipList 暴露给外界的接口，总共只有两个：<code>Insert</code> 和 <code>Contains</code> 。因此，SkipList 实际上并不支持删除操作。在所有对外暴露的接口中，自由 <code>Insert</code> 可以修改 SkipList 的结构。一个 Node 一旦被插入了 SkipList 中，那么其就无法再被移除了。并且，在插入时要求跳表中不存在与待插入键相同键的节点。注意，这里的键并不是用户在插入时给出的原始键，而是包含了 sequence number 的 internalKey ，理论上每个 internalKey 都是独一无二的。<em>Iterator</em> 类实际上提供了遍历 SkipList 和在 SkipList 中进行搜索的功能。在 <em>MemTable</em> 的 <code>Get</code> 函数中，就是通过 <em>Iterator</em> 来实现的，因此也可以算作 SkipList 对外暴露的接口。当然，这个接口也不会修改 SkipList 内部节点的数据。</p><p>SkipList 内部的数据部分包含了六个对象：随机生成节点层级时的最大值 <em>kMaxHeight</em> 、用于比较不同键大小的比较器 <em>compare_</em> 、用于管理内存的 <em>arena_</em> 、跳表的头节点 <em>head_</em> 、当前跳表中所有节点的最高层级 <em>max_height_</em> 以及随机数生成器 <em>rnd_</em> 。在第二节中我们分析过，SkipList 的插入、删除（当然 LevelDB 中不包含删除）都是基于其查找功能实现的，因此我们就从 SkipList 查找的实现开始分析其源代码。</p><h2 id="Search"><a href="#Search" class="headerlink" title="Search"></a>Search</h2><div style="font-size:11px; text-align:center; line-height: 0px"><img src="Figure2.png" width=65%><p><em>图 3：跳表搜索算法伪代码</em></p></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// skiplist.h</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Key, <span class="hljs-keyword">class</span> <span class="hljs-title class_">Comparator</span>&gt;<br><span class="hljs-keyword">typename</span> SkipList&lt;Key, Comparator&gt;::Node*<br>SkipList&lt;Key, Comparator&gt;::<span class="hljs-built_in">FindGreaterOrEqual</span>(<span class="hljs-type">const</span> Key&amp; key,<br>                                              Node** prev) <span class="hljs-type">const</span> &#123;<br>  Node* x = head_;<br>  <span class="hljs-type">int</span> level = <span class="hljs-built_in">GetMaxHeight</span>() - <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    Node* next = x-&gt;<span class="hljs-built_in">Next</span>(level);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">KeyIsAfterNode</span>(key, next)) &#123;<br>      <span class="hljs-comment">// Keep searching in this list</span><br>      x = next;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">if</span> (prev != <span class="hljs-literal">nullptr</span>) prev[level] = x;<br>      <span class="hljs-keyword">if</span> (level == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> next;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// Switch to next list</span><br>        level--;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对比 SkipList 论文中给出的搜索算法的伪代码和 LevelDB 中 SkipList 的搜索算法，两者基本上是一致的。算法首先从头节点开始，从高级别指针开始搜索，如果当前指针指向的下一个元素小于等于待搜索的键，那么就移动到下一个节点中，继续检查这一级别的指针；如果下一个节点的值大于待搜索键，那么就搜索当前节点的下一个级别的指针。如果没有下一个级别的指针了，即 level 等于 0 ，那么当前节点就是我们要搜索的节点。如果跳表中有一个节点的键与待搜索键相同，那么这就是我们查找的结果；如果不存在这样的节点，那么最终搜索到的节点的键的值会大于待搜索键。和原始算法不一样的一点是，LevelDB 的实现中加入了一个 <em>Node</em>** 类型的 <em>prev</em> 变量。如果我们将最终搜索到的节点称为 <em>target_node</em> ，那么 <em>prev[i]</em> 就会指向跳表中位于 <em>target_node</em> 之前、距离 <em>target_node</em> 最近的级别大于等于 $i+1$ 的节点。如果在 <em>target_node</em> 之前没有级别大于 <em>prev[i]</em> 的节点，那么就会指向跳表的头节点。</p><h2 id="Insert"><a href="#Insert" class="headerlink" title="Insert"></a>Insert</h2><p>看完了 SkipList 的搜索过程，下面我们一起看看插入过程：</p><div style="font-size:11px; text-align:center; line-height: 0px"><img src="Figure4.png" width=40%><p><em>图 4：跳表插入算法伪代码</em></p></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// skiplist.h</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Key, <span class="hljs-keyword">class</span> <span class="hljs-title class_">Comparator</span>&gt;<br><span class="hljs-type">void</span> SkipList&lt;Key, Comparator&gt;::<span class="hljs-built_in">Insert</span>(<span class="hljs-type">const</span> Key&amp; key) &#123;<br>  <span class="hljs-comment">// TODO(opt): We can use a barrier-free variant of FindGreaterOrEqual()</span><br>  <span class="hljs-comment">// here since Insert() is externally synchronized.</span><br>  Node* prev[kMaxHeight];<br>  Node* x = <span class="hljs-built_in">FindGreaterOrEqual</span>(key, prev);<br><br>  <span class="hljs-comment">// Our data structure does not allow duplicate insertion</span><br>  <span class="hljs-built_in">assert</span>(x == <span class="hljs-literal">nullptr</span> || !<span class="hljs-built_in">Equal</span>(key, x-&gt;key));<br><br>  <span class="hljs-type">int</span> height = <span class="hljs-built_in">RandomHeight</span>();<br>  <span class="hljs-keyword">if</span> (height &gt; <span class="hljs-built_in">GetMaxHeight</span>()) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-built_in">GetMaxHeight</span>(); i &lt; height; i++) &#123;<br>      prev[i] = head_;<br>    &#125;<br>    <span class="hljs-comment">// It is ok to mutate max_height_ without any synchronization</span><br>    <span class="hljs-comment">// with concurrent readers.  A concurrent reader that observes</span><br>    <span class="hljs-comment">// the new value of max_height_ will see either the old value of</span><br>    <span class="hljs-comment">// new level pointers from head_ (nullptr), or a new value set in</span><br>    <span class="hljs-comment">// the loop below.  In the former case the reader will</span><br>    <span class="hljs-comment">// immediately drop to the next level since nullptr sorts after all</span><br>    <span class="hljs-comment">// keys.  In the latter case the reader will use the new node.</span><br>    max_height_.<span class="hljs-built_in">store</span>(height, std::memory_order_relaxed);<br>  &#125;<br><br>  x = <span class="hljs-built_in">NewNode</span>(key, height);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; height; i++) &#123;<br>    <span class="hljs-comment">// NoBarrier_SetNext() suffices since we will add a barrier when</span><br>    <span class="hljs-comment">// we publish a pointer to &quot;x&quot; in prev[i].</span><br>    x-&gt;<span class="hljs-built_in">NoBarrier_SetNext</span>(i, prev[i]-&gt;<span class="hljs-built_in">NoBarrier_Next</span>(i));<br>    prev[i]-&gt;<span class="hljs-built_in">SetNext</span>(i, x);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对比 SkipList 论文中给出的插入算法和 LevelDB 的实现，还是可以比较清晰地看明白的。首先找到插入的位置，并且通过 <em>prev</em>（伪代码中为 <em>update</em> ）记录各个级别的前驱节点。在 LevelDB 的实现中，不允许对同一个键进行两次插入，在断言中否定了这种情况，而在 SkipList 的伪代码中是允许这种情况的。找到待插入的位置后，为该节点分配一个级别，如果这个级别高于了当前跳表的级别，那么就需要对 <em>prev</em> 中高于跳表级别的指针进行处理，使其指向 <em>head_</em> 。完成好这些预备工作后，为当前键生成一个节点实例，然后将新节点的 $i$ 级指针设置为 $prev[i]$ 的 $i$ 级指针的值，而 $prev[i]$ 的 $i$ 级指针则更新为新生成的这个节点。处理好这些指针后，新的节点插入就算完成了。</p><h2 id="Contains"><a href="#Contains" class="headerlink" title="Contains"></a>Contains</h2><p>最后我们来看看 <code>Contains</code> 是如何实现的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// skiplist.h</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Key, <span class="hljs-keyword">class</span> <span class="hljs-title class_">Comparator</span>&gt;<br><span class="hljs-type">bool</span> SkipList&lt;Key, Comparator&gt;::<span class="hljs-built_in">Contains</span>(<span class="hljs-type">const</span> Key&amp; key) <span class="hljs-type">const</span> &#123;<br>  Node* x = <span class="hljs-built_in">FindGreaterOrEqual</span>(key, <span class="hljs-literal">nullptr</span>);<br>  <span class="hljs-keyword">if</span> (x != <span class="hljs-literal">nullptr</span> &amp;&amp; <span class="hljs-built_in">Equal</span>(key, x-&gt;key)) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个实际上就比较简单了，就是调用了搜索过程的函数，然后判断搜索到的节点的键是否等于搜索键即可。</p><p>到这里，SkipList 的基本内容就讲完了。SkipList 这个数据结构实际上就是在有序链表的基础上通过增加索引形成的一个数据结构，LevelDB 中的实现基本也是按照论文中的思路进行的。建议希望深入了解 SkipList 的读者去阅读其论文原文以及相关的研究论文。</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>源代码阅读</category>
      
      <category>LevelDB</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>跳表：平衡树的概率替代方案</title>
    <link href="/2021/07/13/SkipList/"/>
    <url>/2021/07/13/SkipList/</url>
    
    <content type="html"><![CDATA[<p>LevelDB 和一众 NoSQL 数据库都使用 LSM 树作为其存储模型，其中 MemTable 是非常重要的一个数据结构。在 LevelDB 的实现中，MemTable 是通过一种名为跳表（SkipList）来存储数据的。跳表最早由 William Pugh 在论文《SkipList: A Probabilistic Alternative to Balanaced Tree》 中提出，本文是对这篇论文前几节有关数据结构部分的翻译，有兴趣的读者可以直接去阅读<a href="https://dl.acm.org/doi/abs/10.1145/78973.78977">原文</a>。</p><h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>跳表是一种使用概率平衡而不是严格平衡的数据机构。因此，跳表的插入和删除算法都比平衡树中对应的算法都更简单且快速。</p><p><em>Skip lists are data structures that use probabilistic balancing rather than strictly enforced balancing. As a result, the algorithms for insertion and deletion in skip lists are much simpler and significantly faster than equivalent algorithms for balanced trees.</em></p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>二叉树可以用来表示如字典或者有序列表这样的抽象数据结构，当元素以随机顺序插入时它们能够运行得很好。一些如顺序插入元素这样的操作，会导致二叉树变成性能非常差的退化数据结构。如果允许讲待插入的元素列表进行随机打乱，那么二叉树在任何输入序列下大概率都会工作得很好。但是在大多数情况下，查询都必须在线返回，因此随机排列输入时不现实的。平衡树算法在执行插入操作时重新调整树的结构，以保持较好的平衡性并确保良好的性能。</p><p><em>Binary trees can be used for representing abstract data types such as dictionaries and ordered lists. They work well when the elements are inserted in a random order. Some sequences of operations, such as inserting the elements in order, produce degenerate data structures that perform very poorly. If it were possible to randomly permute the list of items to be inserted, trees would work well with high probability for any input sequence. In most cases queries must be answered online, so randomly permuting the input is impractical. Balanced tree algorithms rearrange the tree as operations are performed to maintain certain balance conditions and assure good performance.</em></p><p><strong>跳表</strong>是一种平衡树的概率替代方案，其通过查询随机数生成器来保持平衡。尽管在最坏情况下跳表的性能非常差，但是没有任何序列能一直导致跳表进入最坏的情况（就像快排的时候主元素的选择是随机的）。对于一个跳表来说，其结构变得非常不平衡的概率是非常小的（例如，对于一个有超过 250 元素的字典来说，一次搜索所花费的时间超过预期时间的三倍的可能性小于一百万分之一）。跳表拥有类似随机插入元素形成的搜索树的平衡性，但是它不需要插入时的元素是随机的。</p><p><em>Skip lists are a probabilistic alternative to balanced trees. Skip lists are balanced by consulting a random number generator. Although skip lists have bad worstcase performance, no input sequence consistently produces the worstcase performance (much like quicksort when the pivot element is chosen randomly). It is very unlikely a skip list data structure will be significantly unbalanced (e.g., for a dictionary of more than 250 elements, the chance that a search will take more than three-times the expecied time is less than one in a million). Skip lists have balance properties similar to that of search trees built by random insertions, yet do not require insertions to be random.</em></p><p>对于一个数据结构来说，保持概率性的平衡比保持严格的平衡要更加容易。对于大多数应用来说，跳表是一种比树更加自然的数据表示方式，并且使用跳表可以使算法更加简单。跳表的简洁性使得它们更容易实现，并且相较于平衡树和其他自平衡树算法，跳表提供了常数倍性能优化。跳表对空间的使用效率也非常高，它可以很轻易地通过配置来实现对平均只对 1 % （或者更少）的元素使用的指针，并且每个节点也不需要存储任何的平衡或优先级信息。</p><p><em>It is easier to balance a data structure probabilistitally than to explicitly maintain the balance. For many applications, skip lists are a more natural representation than trees, and they lead to simpler algorithms. The simplicity of skip list algorithms makes them easier to implement and provides significant constant factor speed improvements over balanced tree and self-adjusting tree algorithms. Skip lists are also very space efficient. They can easily be configured to require an average of 1% pointers per element (or even less) and do not require balance or priority information to be stored with each node.</em></p><h2 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h2><p>当我们在搜索一个链表时，有可能需要检查链表的每一个节点（如图 1a）。如果链表是按照顺序存放的，并且链表中的每两个节点都有一个指向位于它两个节点前的节点的指针（如图 1<br>b），我们就只需要检查不超过 $\lceil n &#x2F; 2 \rceil$ 个节点（其中 $n$ 是链表的长度）。同样的，假如每四个节点都有一个指针指向位于它四个节点前的节点的指针（如图 1c），那么就只需要检查 $\lceil n &#x2F; 4\rceil + 2$ 个节点。假如每 $(2^i)$ 个节点就有一个指针指向位于它 $(2^i)$ 个节点前的节点的指针，那么仅仅通过将指针数量加倍就可以使一次搜索所需要检查的节点个数可以减少到 $\lceil \log_2 n \rceil$ 。这样的一种数据结构可以用来进行快速查找，但是对它的插入和删除将变得很困难。</p><p><em>We might need to examine every node of the list when searching a linked list (Figure la). If the list is stored in sorted order and every other node of the list also has a pointer to the node two ahead of it in the list (Figure lb), we have to examine no more than $\lceil n&#x2F;2\rceil + 1$ nodes (where n is the length of the list). Also giving every fourth node a pointer four ahead (Figure lc) requires that no more than $\lceil n &#x2F; 4\rceil + 2$ nodes be examined. If every ($(2^i)$th node has a pointer $(2^i)$ nodes ahead (Figure 1d), the number of nodes that must be examined can be reduced to $\lceil \log_2 n \rceil$ while only doubling the number of pointers. This data structure could be used for fast searching, but insertion and deletion would be impractical.</em></p><div style="font-size:13px; text-align:center; line-height: 0px"><img src="Figure1.png"><p><em>Figure 1</em></p></div><p>如果一个节点拥有 k 个指向前面节点的指针，那么这个节点被称为 k 层节点。如果每 $2^i$ 个节点就有一个节点拥有一个指针指向 $2^i$ 个节点之前的那个节点，那么链表中节点的层级分布遵循这样一个简单的模式：50 % 的节点是 1 层节点，25 % 的节点是 2 层节点，12.5 % 的节点是 3 层节点，等等。假如节点的层级是随机选择的，但是所有节点的层级分布不变（如图 1e），会发生什么呢？一个节点的第 $i$ 个指针，指向了下一个 $i$ 层或高于 $i$ 层的节点，而不是位于前方 $2^{i-1}$ 节点之前的那个节点。插入或者删除只需要进行本地修改，一个节点的层级在它被插入时就被随机的选择，并且不需要再进行修改。有一些层级排布的情况会导致结构变得很差，但是我们会发现这样的情况是很少的。因为这样的数据结构是一种带着用以跳过中间节点的额外指针的链表，我把它称之为跳表。</p><p><em>A node that has k forward pointers is called a level k node. If every $(2^i)$th node has a pointer $2^i$ nodes ahead, then levels of nodes are distributed in a simple pattern: 50 percent are level 1, 25 percent are level 2, 12.5 percent are level 3 and so on. What would happen if the levels of nodes were chosen randomly, but in the same proportions (e.g., as in Figure 1e)? A node’s $i$ th forward pointer, instead of pointing $2^{i-1}$ nodes ahead, points to the next node of level $i$ or higher. Insertions or deletions would require only local modifications; the level of a node, chosen randomly when the node is inserted, need never change. Some arrangements of levels would give poor execution times, but we will see that such arrangements are rare. Because these data structures are linked lists with extra pointers that skip over intermediate nodes, I named them skip lists.</em></p><h2 id="跳表算法"><a href="#跳表算法" class="headerlink" title="跳表算法"></a>跳表算法</h2><p>这一节描述了对跳表算法来说如何进行查找，以及如何对一个字典或符号表中的元素进行插入和删除。搜索操作返回与目标键相关联的值的内容，当目标键不存在时操作会失败。插入操作将一个指定的键和一个新的值关联起来（如果这个键没有出现过，那么就将这个键插入到数据结构中）。删除操作会将指定的键删除。支持如寻找最小键或者寻找下一个键这样的附加操作是很容易的。</p><p><em>This section describes how to search for algorithms and to insert and delete elements in a dictionary or symbol table. The Search operation returns the contents of the value associated with the desired key or failure if the key is not present. The Insert operation associates a specified key with a new value (inserting the key if it had not already been present). The Delete operation deletes the specified key. It is easy to support additional operations such as “find the minimum key” or “find the next key.”</em></p><p>每个元素由一个节点表示，节点的层级在它被插入时随机地选择，选择的时候无需考虑数据结构中的元素数量。一个 $i$ 层节点有 $i$ 个前向指针（计数从 1 开始一直到 $i$）。我们不需要在节点中记录这个节点属于哪个层级，跳表的级别是表中所有节点的最大级别（如果跳表是空的，那么表的级别为 1），头节点中高于当前链表最大层级的指针指向 NIL （即尾结点，例如头节点有 10 个指针，当前跳表的级别为 6 ，那么头节点中的第 7 到 10 个指针都指向 NIL）。</p><p><em>Each element is represented by a node, the level of which is chosen randomly when the node is inserted without regard for the number of elements in the data structure. A level $i$ node has $i$ forward pointers, indexed 1 through i. We do not need to store the level of a node in the node. Levels are capped at some appropriate con- stant MaxLevel. The level of a list is the maximum level currently in the list (or 1 if the list is empty). The header of a list has forward pointers at levels one through MaxLevel. The forward pointers of the header at levels higher than the current maximum level of the list point to NIL.</em></p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>申请一个 NIL 节点，并对这个节点赋予一个比任何键都大的值。所有层级的所有跳表都以 NIL 节点作为结尾。一个新的链表被初始化成这个链表的层级是 1 ，并且链表中头节点的所有指针都指向 NIL 。</p><p><em>An element NIL is allocated and given a key greater than any legal key. All levels of all skip lists are terminated with NIL. A new list is initialized so that the level of the list is equal to 1 and all forward pointers of the list’s header point to NIL.</em></p><h3 id="搜索算法"><a href="#搜索算法" class="headerlink" title="搜索算法"></a>搜索算法</h3><p>我们通过遍历所有不超过包含待搜索元素的节点的前向指针来实现搜索（如图 2）。如果当前层级的指针无法搜索到更多的内容，那么就会进行到下一个层级。当我们在层级 1 也无法搜索到更多内容，如果包含待搜索键的节点存在，那我们必然在这个节点中。</p><p><em>We search for an element by traversing forward pointers that do not overshoot the node containing the element being searched for (Figure 2). When no more progress can be made at the current level of forward pointers, the search moves down to the next level. When we can make no more progress at level 1, we must be immediately in front of the node that contains the desired element (if it is in the list).</em></p><div style="font-size:13px; text-align:center; line-height: 0px"><img src="Figure2.png" width=80%><p><em>Figure 2</em></p></div><h3 id="插入和删除算法"><a href="#插入和删除算法" class="headerlink" title="插入和删除算法"></a>插入和删除算法</h3><div style="font-size:13px; text-align:center; line-height: 0px"><img src="Figure3.png"><p><em>Figure 3</em></p></div><p>如果要插入或者删除一个节点，我们只需要进行搜索和拼接（如图 3）。图 4 给出了插入和删除的算法。我们维护一个名为 <em>update</em> 的向量，以便当搜索完成时（并且我们已经准备好进行拼接了），<em>update[i]</em> 保存了一个指向一个层级大于等于 $i$ 的节点的指针，并且这个节点位于插入或删除节点所在位置的左半边的最右侧。如果一个插入产生了一个节点，其层级比原本链表中层级最高的节点还高，那么我们就更新链表的层级，并且初始化 <em>update</em> 向量合适的部分。在删除后，我们检查这次删除是否删掉了链表中层级最高的节点，如果是，那么就需要更新链表的层级。</p><p><em>To insert or delete a node, we simply search and splice, as shown in Figure 3. Figure 4 gives algorithms for insertion and deletion. A vector update is maintained so that when the search is complete (and we are ready to perform the splice), update[i] contains a pointer to the rightmost node of level i or higher that is to the left of the location of the insertion&#x2F;deletion. If an insertion generates a node with a level greater than the previous maximum level of the list, we update the maximum level of the list and initialize the appropriate portions of the update vector. After each deletion, we check to see if we have deleted the maximum element of the list and if so, decrease the maximum level of the list.</em></p><div style="font-size:13px; text-align:center; line-height: 0px"><img src="Figure4.png"><p><em>Figure 4</em></p></div><h3 id="选择随机层级"><a href="#选择随机层级" class="headerlink" title="选择随机层级"></a>选择随机层级</h3><p>最初，我们讨论了一个概率分布：一半具有 $i$ 层级指针的节点也有 $i+1$ 层级指针。为了避免魔法数，我们说在具有 $i$ 层级指针的节点中有比例 $p$ 的节点也拥有 $i+1$ 层级指针（我们最初假设 $p$&#x3D;1&#x2F;2 进行讨论）。层级是有和图 5 等效的算法随机生成的，并且在生成时无需考虑链表中元素的个数。</p><p><em>Initially, we discussed a probability distribution where half of the nodes that have level i pointers also have level i + 1 pointers. To get away from magic constants, we say that a fraction p of the nodes with level i pointers also have level i + 1 pointers (see p &#x3D; 1&#x2F;2 for our original discussion). Levels are generated randomly by an algorithm equivalent to the one in Figure 5. Levels are generated without reference to the number of elements in the list.</em></p><h3 id="我们在哪一个层级开始搜索？定义-L-n"><a href="#我们在哪一个层级开始搜索？定义-L-n" class="headerlink" title="我们在哪一个层级开始搜索？定义 $L(n)$"></a>我们在哪一个层级开始搜索？定义 $L(n)$</h3><p>在一个以 $p&#x3D;1&#x2F;2$ 生成的有 16 个元素的跳表中，可能有 9 个元素在层级 1 ，3 个元素在层级 2 ，3 个元素在层级 3 ，以及一个元素在层级 14（这发生的概率很小，但是还是有可能发生）。我们应该怎么处理它？如果我们使用标准算法从层级 14 开始搜索，那么就需要做很多无用功。那我们该从哪里开始搜索呢？我们的分析表明，理想情况下，我们应该从层级 L （期望有 $1&#x2F;p$  个节点）开始搜索，这在 $L &#x3D; \log_{1&#x2F;p} n$ 时成立。因为我们会经常引用这个式子，因此我们用 $L(n)$ 来代表 $\log_{1&#x2F;p} n$ 。</p><p><em>In a skip list of 16 elements generated with p &#x3D; 1&#x2F;2, we might happen to have 9 elements of level 1; 3 elements of level 2; 3 elements of level 3; and 1 element of level 14 (this would be very unlikely, but it could happen). How should we handle this? If we use the standard algorithm and start our search at level 14, we will do a lot of useless work. Where should we start the search? Our analysis suggests that ideally we would start a search at the level L where we expect 1&#x2F;p nodes. This happens when $L &#x3D; \log_{1&#x2F;p} n$. Since we will be referring frequently to this formula, we will use L(n) to denote $\log_{1&#x2F;p} n$.</em> </p><p>想要解决一个节点有异常大的层级这个问题有很多方法。别担心，我们只需要简单地从链表的最高层开始搜索即可。正如我们将在分析中所见，一个含有 n 个元素的链表中的节点的最高层级远高于 $L(n)$ 的概率是非常小的，从链表的最高层开始搜索只会对搜索的预期时间增加一个微小的常数。这种方法就是这篇论文中描述的算法所采用的方法。</p><p><em>There are a number of solutions to the problem of deciding how to handle the case where there is an element with an unusually large level in the list. Don’t worry, be happy. Simply start a search at the highest level present in the list. As we will see in our analysis, the probability that the maximum level in a list of n elements is significantly larger than L(n) is very small. Starting a search at the maximum level in the list does not add more than a small constant to the expected search time. This is the approach used in the algorithms described in this paper.</em></p><p>使用少于你获取的信息。尽管一个元素有可能包含 14 个指针的位置，我们不需要将这个 14 个都用完，我们可以选择仅使用 L(n) 层。有多种方法可以实现这一点，但它们都会使算法复杂化并且不会显着提高性能，因此不推荐使用这种方法。</p><p><em>Use less than you are given. Although an element may contain room for 14 pointers, we do not need to use all 14. We can choose to utilize only L(n) levels. There are a number of ways to implement this, but they all complicate the algorithms and do not noticeably improve performance, so this approach is not recommended.</em></p><p>固定随机数产生器。如果我们生成的随机层级比链表中的当前层级级别大一以上，我们只需使用列表中当前的最大层级加一作为新节点的层级。在实践中和直觉上，这种改变似乎运作良好。 然而，它完全破坏了我们分析结果算法的能力，因为节点的层级不再是完全随机的。 虽然程序员可能会实现这种方法，但纯粹主义者应该避免它。</p><p><em>Fix the dice. If we generate a random level that is more than one greater than the current maximum level in the list, we simply use one plus the current maximum level in the list as the level of the new node. In practice and intuitively, this change seems to work well. However, it totally destroys our ability to analyze the resulting algorithms, since the level of a node is no longer completely random. Although programmers may implement this method, purists should avoid it.</em></p><h3 id="选择最大层级"><a href="#选择最大层级" class="headerlink" title="选择最大层级"></a>选择最大层级</h3><p>由于可以在 L(n) 处限制层级的最大值，因此我们应该选择 MaxLevel &#x3D; L(N)（其中 N 是跳表中元素数量的上限）。如果 p &#x3D; 1&#x2F;2，那么使用 MaxLevel &#x3D; 16 适用于最多包含 $2^{16}$ 个元素的数据结构。</p><p><em>Since we can safely cap levels at L(n), we should choose MaxLevel &#x3D; L(N) (where N is an upper bound on the number of elements in a skip list). If p &#x3D; 1&#x2F;2, using MaxLevel &#x3D; 16 is appropriate for data structures con taining up to $2^{16}$ elements.</em></p>]]></content>
    
    
    <categories>
      
      <category>论文笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>LevelDB 源代码阅读（三）：预写日志</title>
    <link href="/2021/07/11/leveldb-source-code-reading-3/"/>
    <url>/2021/07/11/leveldb-source-code-reading-3/</url>
    
    <content type="html"><![CDATA[<p>在前面两篇文章中，我们介绍了 LevelDB 的写流程和读流程。原本准备这篇文章介绍 LevelDB 的 MemTable 结构，但是在 <a href="https://leveldb-handbook.readthedocs.io/zh/latest/index.html">LevelDB Handbook</a> 的内容编排中，MemTable 被放在了预写日志之后介绍。于是我也决定按照 Handbook 的顺序，先介绍预写日志，再介绍 MemTable 的结构。</p><h1 id="WAL：预写日志"><a href="#WAL：预写日志" class="headerlink" title="WAL：预写日志"></a>WAL：预写日志</h1><p>WAL 的英文全称为 Write-Ahead Log ，翻译过来就是预写日志。所谓预写，就是在正式地执行对数据的写操作前（插入或者删除），先将操作的内容通过日志记录下来，这么做的目的是为了防止因进程异常或者服务器异常导致的数据库异常。</p><img src="LSM.png" width=65%><p>我们考虑下面两种情况：</p><ul><li>日志未写完或者未开始写进程就异常退出</li><li>日志写完了，数据没写完或者没开始写进程异常退出</li><li>日志写完了，数据也写完了，进程异常退出</li></ul><p>第一种情况下，在数据库恢复时会看到一条不完整的日志（写到一半）或者看不到该条日志（没开始写），这种情况下可以认为这次写操作失败，数据库也不会恢复这次操作，保证了写操作的原子性。</p><p>第二种情况下，数据库在恢复时可以通过读取到的日志内容来恢复未完成的写操作，同样保证了原子性。</p><p>第三种情况就是正常的情况，数据库在恢复时无须进行任何操作。</p><p>因此，WAL 在这三种情况下都可以保证数据库写操作的原子性。对于 WAL 的更多知识，可以查看这篇<a href="https://martinfowler.com/articles/patterns-of-distributed-systems/wal.html">文章</a>。下面我们看看 WAL 在 LevelDB 中是如何实现的。</p><h1 id="LevelDB-中的-WAL-实现"><a href="#LevelDB-中的-WAL-实现" class="headerlink" title="LevelDB 中的 WAL 实现"></a>LevelDB 中的 WAL 实现</h1><h2 id="LevelDB-的日志结构"><a href="#LevelDB-的日志结构" class="headerlink" title="LevelDB 的日志结构"></a>LevelDB 的日志结构</h2><img src="Leveldb-WAL.png" width=80%><p>上图是 LevelDB 中日志的结构。日志被存储的最小单位是 Chunk，一个 Chunk 包含了四个部分：校验和 Checksum（4 个字节）、数据长度 Length （2 个字节），Chunk 类型 Type（1 个字节）以及数据内容，前三个部分被称为 ChunkHeader 。校验和是由数据类型以及数据内容计算出来的，使用的算法是 CRC 校验算法。Chunk 类型一共有 4 种：Full、First、Midlle、Last 。之所以需要有四种 Chunk 类型，是因为一条日志有可能因为大小太大而被存在多个 Chunk 当中。假如一条日志被存放在了一个 Chunk 当中，那么这个 Chunk 的类型就是 Full ；假如一条日志被存放在了多个 Chunk 当中，那么第一个 Chunk 的类型为 First ，最后一个 Chunk 的类型为 Last ，First 和 Last 之间包含了零个或多个 Middle 类型的 Chunk ，这些所有的 Chunk 中的数据组合起来就是日志的原始数据。</p><p>一个或多个 Chunk 会组成一个 Block 。一个 Block 是有大小限制的，上限是 32 KB，即 32768 个字节。当一个 Block 的大小达到了阈值后，这个 Block 就会被关闭，然后开启一个新的 Block 。如果我们往一个 Block 中写日志时，Block 中剩余的空间足够写下一个 ChunkHeader， 但无法容下这条日志的所有内容，那么就会写入一个类型为 First 的 Chunk，然后开启一个新的 Block ，将剩余的数据写在新 Block 中。我们可以推理出，假如一个 Chunk 的类型为 Middle，那么这个 Chunk 一定占据了一整个 Block （想想这是为什么）。</p><h2 id="写日志"><a href="#写日志" class="headerlink" title="写日志"></a>写日志</h2><p>LevelDB 中所有的写操作都会在 <code>DBImpl::Write</code> 函数中被处理，这当中也包含了对 WAL 的处理，代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// db_impl.cc</span><br><span class="hljs-function">Status <span class="hljs-title">DBImpl::Write</span><span class="hljs-params">(<span class="hljs-type">const</span> WriteOptions&amp; options, WriteBatch* updates)</span> </span>&#123;<br>  ... <span class="hljs-comment">// some code prepare for writing</span><br>  <span class="hljs-comment">// Write WAL</span><br>  status = log_-&gt;<span class="hljs-built_in">AddRecord</span>(WriteBatchInternal::<span class="hljs-built_in">Contents</span>(write_batch));<br>  <span class="hljs-type">bool</span> sync_error = <span class="hljs-literal">false</span>;<br>  <span class="hljs-keyword">if</span> (status.<span class="hljs-built_in">ok</span>() &amp;&amp; options.sync) &#123;<br>    status = logfile_-&gt;<span class="hljs-built_in">Sync</span>();<br>    <span class="hljs-keyword">if</span> (!status.<span class="hljs-built_in">ok</span>()) &#123;<br>      sync_error = <span class="hljs-literal">true</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (status.<span class="hljs-built_in">ok</span>()) &#123;<br>    <span class="hljs-comment">// insert the data to the memtable</span><br>    status = WriteBatchInternal::<span class="hljs-built_in">InsertInto</span>(write_batch, mem_);<br>  &#125;<br><br>  ... <span class="hljs-comment">// some code after write</span><br><br>  <span class="hljs-keyword">return</span> status;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，WAL 确实是在正式写数据之前完成的。 <code>WriteBatchInternal::Contents</code> 函数会将 WriteBatch 中的 rep_ 包装成 <em>Slice</em> 对象（关于 WriteBatch 和 Slice 的介绍，可以参考前面介绍 LevelDB 写流程的文章），然后传入 Writer 的 <code>AddRecord</code> 函数中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// log_writer.cc</span><br><span class="hljs-function">Status <span class="hljs-title">Writer::AddRecord</span><span class="hljs-params">(<span class="hljs-type">const</span> Slice&amp; slice)</span> </span>&#123;<br><span class="hljs-comment">// the data and length of the log</span><br>  <span class="hljs-type">const</span> <span class="hljs-type">char</span>* ptr = slice.<span class="hljs-built_in">data</span>();<br>  <span class="hljs-type">size_t</span> left = slice.<span class="hljs-built_in">size</span>();<br><br>  <span class="hljs-comment">// Fragment the record if necessary and emit it.  Note that if slice</span><br>  <span class="hljs-comment">// is empty, we still want to iterate once to emit a single</span><br>  <span class="hljs-comment">// zero-length record</span><br>  Status s;<br>  <span class="hljs-type">bool</span> begin = <span class="hljs-literal">true</span>;<br>  <span class="hljs-keyword">do</span> &#123;<br>    <span class="hljs-comment">// ------------ Begin of Code Fragment A -------------</span><br>  <span class="hljs-comment">// the left size of current block</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> leftover = kBlockSize - block_offset_;<br>    <span class="hljs-built_in">assert</span>(leftover &gt;= <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (leftover &lt; kHeaderSize) &#123;<br><span class="hljs-comment">// If the left space cannot write a chunk header</span><br>      <span class="hljs-comment">// Switch to a new block</span><br>      <span class="hljs-keyword">if</span> (leftover &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// Fill the trailer (literal below relies on kHeaderSize being 7)</span><br>        <span class="hljs-built_in">static_assert</span>(kHeaderSize == <span class="hljs-number">7</span>, <span class="hljs-string">&quot;&quot;</span>);<br>        dest_-&gt;<span class="hljs-built_in">Append</span>(<span class="hljs-built_in">Slice</span>(<span class="hljs-string">&quot;\x00\x00\x00\x00\x00\x00&quot;</span>, leftover));<br>      &#125;<br>      <span class="hljs-comment">// when switching to a new block, just set the offset in the block to 0</span><br>      block_offset_ = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-comment">// ------------ End of Code Fragment A -------------</span><br><br>    <span class="hljs-comment">// ------------ Begin of Code Fragment B -------------</span><br>    <span class="hljs-comment">// Invariant: we never leave &lt; kHeaderSize bytes in a block.</span><br>    <span class="hljs-built_in">assert</span>(kBlockSize - block_offset_ - kHeaderSize &gt;= <span class="hljs-number">0</span>);<br><br>    <span class="hljs-comment">// the size of space used for writing data</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> avail = kBlockSize - block_offset_ - kHeaderSize;<br>    <span class="hljs-comment">// if the fragment_length == left, current log can be completely written into this block</span><br>    <span class="hljs-comment">// else current log should be divided into several fragment</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> fragment_length = (left &lt; avail) ? left : avail;<br><br>    RecordType type;<br>    <span class="hljs-type">const</span> <span class="hljs-type">bool</span> end = (left == fragment_length);<br>    <span class="hljs-keyword">if</span> (begin &amp;&amp; end) &#123;<br>      type = kFullType;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (begin) &#123;<br>      type = kFirstType;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (end) &#123;<br>      type = kLastType;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      type = kMiddleType;<br>    &#125;<br>    <span class="hljs-comment">// ------------ End of Code Fragment B -------------</span><br><br>    <span class="hljs-comment">// ------------ Begin of Code Fragment C -------------</span><br>    <span class="hljs-comment">// write current chunk to disk</span><br>    s = <span class="hljs-built_in">EmitPhysicalRecord</span>(type, ptr, fragment_length);<br>    ptr += fragment_length;<br>    left -= fragment_length;<br>    begin = <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">// ------------ End of Code Fragment C -------------</span><br>  &#125; <span class="hljs-keyword">while</span> (s.<span class="hljs-built_in">ok</span>() &amp;&amp; left &gt; <span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">return</span> s;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码还是比较清晰的，A 段代码主要是在检查当前 Block 剩余空间大小：如果当前 Block 剩余的空间小于一个 ChunkHeader 的大小，那么就会把 Block 剩下的空间用 0 填满，然后切换到一个新的 Block 中。这里切换新 Block 的操作非常简单，就是将记录当前数据 offset 的变量置为 0 。 B 段代码则是在检查当前这条日志的写入情况：如果 Block 剩余的空间大小可以将这条日志写完，那么新加入的 Chunk 类型就为 Full ；否则一条日志可能要写在多个 Chunk 中，那么就根据当前写的情况将 Chunk 标志为 First、Middle 或者 Last 。C 段代码则是调用函数将当前这条 Chunk 提交并写入到磁盘中。值得注意的是，假如我们当前日志的内容为空，即变量 left 一开始就为 0，那么这段代码仍然会提交一个 data 段为空的 Chunk 。</p><p>下面我们来看看一个 Chunk 是如何被提交的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// log_writer.cc</span><br><span class="hljs-function">Status <span class="hljs-title">Writer::EmitPhysicalRecord</span><span class="hljs-params">(RecordType t, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* ptr,</span></span><br><span class="hljs-params"><span class="hljs-function">                                  <span class="hljs-type">size_t</span> length)</span> </span>&#123;<br>  <span class="hljs-built_in">assert</span>(length &lt;= <span class="hljs-number">0xffff</span>);  <span class="hljs-comment">// Must fit in two bytes</span><br>  <span class="hljs-built_in">assert</span>(block_offset_ + kHeaderSize + length &lt;= kBlockSize);<br><br>  <span class="hljs-comment">// Format the header</span><br>  <span class="hljs-comment">// The structure of Header</span><br>  <span class="hljs-comment">// CheckSum     4 Byte</span><br>  <span class="hljs-comment">// DataLength   2 Byte</span><br>  <span class="hljs-comment">// ChunkType    1 Byte</span><br>  <span class="hljs-type">char</span> buf[kHeaderSize];<br><span class="hljs-comment">// ------------ Start of Code Fragment A -------------</span><br>  <span class="hljs-comment">// Encode the DataLength</span><br>  buf[<span class="hljs-number">4</span>] = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">char</span>&gt;(length &amp; <span class="hljs-number">0xff</span>);<br>  buf[<span class="hljs-number">5</span>] = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">char</span>&gt;(length &gt;&gt; <span class="hljs-number">8</span>);<br>  <span class="hljs-comment">// Encode the ChunkType</span><br>  buf[<span class="hljs-number">6</span>] = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">char</span>&gt;(t);<br><br>  <span class="hljs-comment">// Compute the crc of the record type and the payload.</span><br>  <span class="hljs-type">uint32_t</span> crc = crc32c::<span class="hljs-built_in">Extend</span>(type_crc_[t], ptr, length);<br>  crc = crc32c::<span class="hljs-built_in">Mask</span>(crc);  <span class="hljs-comment">// Adjust for storage</span><br>  <span class="hljs-built_in">EncodeFixed32</span>(buf, crc);<br><span class="hljs-comment">// ------------ End of Code Fragment A -------------</span><br><br><span class="hljs-comment">// ------------ Start of Code Fragment B -------------</span><br>  <span class="hljs-comment">// Write the header and the payload</span><br>  Status s = dest_-&gt;<span class="hljs-built_in">Append</span>(<span class="hljs-built_in">Slice</span>(buf, kHeaderSize));<br>  <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">ok</span>()) &#123;<br>    s = dest_-&gt;<span class="hljs-built_in">Append</span>(<span class="hljs-built_in">Slice</span>(ptr, length));<br>    <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">ok</span>()) &#123;<br>    <span class="hljs-comment">// flush the chunk to disk</span><br>      s = dest_-&gt;<span class="hljs-built_in">Flush</span>();<br>    &#125;<br>  &#125;<br><span class="hljs-comment">// ------------ End of Code Fragment B -------------</span><br>  block_offset_ += kHeaderSize + length;<br>  <span class="hljs-keyword">return</span> s;<br>&#125;<br></code></pre></td></tr></table></figure><p>这一段代码分为两个部分：A 部分代码编码了 ChunkHeader ，我们可以看到校验和是通过 <code>crc32c::Extend</code> 和 <code>crc32c::Mask</code> 方法计算得到的，然后它们和 DataLength、 ChunkType 一起被编码进了 buf 中。B 部分将 ChunkHeader 和 Data 分别添加到了 dest_ 中。这里的 dest_ 是一个 <em>WritableFile</em> 对象，其 <code>Append</code> 的方法并不会将数据刷到文件中，而是保存在一个缓冲区中。当 Chunk Header 以及 Data 部分的数据都成功添加到了 dest_ 中后，就会调用其 <code>Flush</code> 方法，这个方法会将其缓冲区中的 Chunk 刷到磁盘上。有一点需要注意的是，在不同的操作系统下，dest_ 的具体类型会不同。<em>WritableFile</em> 是一个抽象类，在 Windows 下其实现为 <em>WindowsWritableFile</em>；在 Mac 和 Linux 系统下，其实现是 <code>PosixWritableFile</code> 。它们的区别在于写入数据时调用的系统调用不一样，编译时编译器会根据操作系统的信息来选择不同的实现。</p><h1 id="读日志"><a href="#读日志" class="headerlink" title="读日志"></a>读日志</h1><p>当系统在恢复时，需要读取硬盘上的日志然后恢复之前由于进程异常退出丢失的操作。下面我们来讲讲 LevelDB 是如何读取日志的。在前面写入日志时，代码都是中 log_writer.cc 中的。对应的，在读取日志时，也有一个 log_reader.cc 中的 <em>Reader</em> 类负责将日志读出并解析。在这个类中有一个函数 <code>ReadRecord</code> 直接读取下一条日志并返回，下面我们看看这个函数的内容</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// log_reader.cc</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Reader::ReadRecord</span><span class="hljs-params">(Slice* record, std::string* scratch)</span> </span>&#123;<br>  <span class="hljs-comment">// ------------ Start of Code Fragment A -------------</span><br>  <span class="hljs-comment">// 如果 last_record_offset_ 小于 initial_offset_</span><br>  <span class="hljs-comment">// 那么 initial_offset 大于 0，并且第一个 chunk 还没有被读取</span><br>  <span class="hljs-comment">// 所以直接跳转到第一个 chunk 开始的位置</span><br>  <span class="hljs-keyword">if</span> (last_record_offset_ &lt; initial_offset_) &#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">SkipToInitialBlock</span>()) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// scratch 用于缓存一条日志的数据</span><br>  scratch-&gt;<span class="hljs-built_in">clear</span>();<br>  record-&gt;<span class="hljs-built_in">clear</span>();<br>  <span class="hljs-type">bool</span> in_fragmented_record = <span class="hljs-literal">false</span>;<br>  <span class="hljs-comment">// Record offset of the logical record that we&#x27;re reading</span><br>  <span class="hljs-comment">// 0 is a dummy value to make compilers happy</span><br>  <span class="hljs-comment">// 记录当前正在读的这条日志在文件中的 offset</span><br>  <span class="hljs-type">uint64_t</span> prospective_record_offset = <span class="hljs-number">0</span>;<br><br>  Slice fragment;<br>  <span class="hljs-comment">// ------------ End of Code Fragment A -------------</span><br><br><br>  <span class="hljs-comment">// ------------ Start of Code Fragment B -------------</span><br>  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> record_type = <span class="hljs-built_in">ReadPhysicalRecord</span>(&amp;fragment);<br><br>    <span class="hljs-comment">// ReadPhysicalRecord may have only had an empty trailer remaining in its</span><br>    <span class="hljs-comment">// internal buffer. Calculate the offset of the next physical record now</span><br>    <span class="hljs-comment">// that it has returned, properly accounting for its header size.</span><br>    <span class="hljs-comment">// physical_record_offset 就是当前读出来的这个 chunk 在文件中开始的位置</span><br>    <span class="hljs-type">uint64_t</span> physical_record_offset =<br>        end_of_buffer_offset_ - buffer_.<span class="hljs-built_in">size</span>() - kHeaderSize - fragment.<span class="hljs-built_in">size</span>();<br><br>    <span class="hljs-keyword">if</span> (resyncing_) &#123;<br>      <span class="hljs-keyword">if</span> (record_type == kMiddleType) &#123;<br>        <span class="hljs-keyword">continue</span>;<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (record_type == kLastType) &#123;<br>        resyncing_ = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">continue</span>;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        resyncing_ = <span class="hljs-literal">false</span>;<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">switch</span> (record_type) &#123;<br>      <span class="hljs-keyword">case</span> kFullType:<br>        <span class="hljs-comment">// 如果读到了 FullType 的 Chunk,那么就已经读到了一整条日志，直接返回</span><br>        <span class="hljs-keyword">if</span> (in_fragmented_record) &#123;<br>          <span class="hljs-comment">// Handle bug in earlier versions of log::Writer where</span><br>          <span class="hljs-comment">// it could emit an empty kFirstType record at the tail end</span><br>          <span class="hljs-comment">// of a block followed by a kFullType or kFirstType record</span><br>          <span class="hljs-comment">// at the beginning of the next block.</span><br>          <span class="hljs-keyword">if</span> (!scratch-&gt;<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-built_in">ReportCorruption</span>(scratch-&gt;<span class="hljs-built_in">size</span>(), <span class="hljs-string">&quot;partial record without end(1)&quot;</span>);<br>          &#125;<br>        &#125;<br>        prospective_record_offset = physical_record_offset;<br>        scratch-&gt;<span class="hljs-built_in">clear</span>();<br>        *record = fragment;<br>        last_record_offset_ = prospective_record_offset;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>      <span class="hljs-keyword">case</span> kFirstType:<br>        <span class="hljs-comment">// 如果读到了 firstType 的 Chunk,那么就要将 in_fragmented_record 置为 true</span><br>        <span class="hljs-comment">// 然后继续往下读，直到读到了一条 Last 类型的 chunk</span><br>        <span class="hljs-keyword">if</span> (in_fragmented_record) &#123;<br>          <span class="hljs-comment">// Handle bug in earlier versions of log::Writer where</span><br>          <span class="hljs-comment">// it could emit an empty kFirstType record at the tail end</span><br>          <span class="hljs-comment">// of a block followed by a kFullType or kFirstType record</span><br>          <span class="hljs-comment">// at the beginning of the next block.</span><br>          <span class="hljs-keyword">if</span> (!scratch-&gt;<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-built_in">ReportCorruption</span>(scratch-&gt;<span class="hljs-built_in">size</span>(), <span class="hljs-string">&quot;partial record without end(2)&quot;</span>);<br>          &#125;<br>        &#125;<br>        prospective_record_offset = physical_record_offset;<br>        scratch-&gt;<span class="hljs-built_in">assign</span>(fragment.<span class="hljs-built_in">data</span>(), fragment.<span class="hljs-built_in">size</span>());<br>        in_fragmented_record = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">break</span>;<br><br>      <span class="hljs-keyword">case</span> kMiddleType:<br>        <span class="hljs-comment">// 如果读到了 Middle 类型的 Chunk,将内容添加进 scratch 中，然后接着往下读</span><br>        <span class="hljs-comment">// 直到读到了一条 Last 类型的 Chunk</span><br>        <span class="hljs-keyword">if</span> (!in_fragmented_record) &#123;<br>          <span class="hljs-built_in">ReportCorruption</span>(fragment.<span class="hljs-built_in">size</span>(),<br>                           <span class="hljs-string">&quot;missing start of fragmented record(1)&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          scratch-&gt;<span class="hljs-built_in">append</span>(fragment.<span class="hljs-built_in">data</span>(), fragment.<span class="hljs-built_in">size</span>());<br>        &#125;<br>        <span class="hljs-keyword">break</span>;<br><br>      <span class="hljs-keyword">case</span> kLastType:<br>        <span class="hljs-comment">// 读到了一条 Last 类型的日志，将这条日志的内容以及前面缓存的日志一起拼接起来</span><br>        <span class="hljs-comment">// 形成一条完整的日志并且返回</span><br>        <span class="hljs-keyword">if</span> (!in_fragmented_record) &#123;<br>          <span class="hljs-built_in">ReportCorruption</span>(fragment.<span class="hljs-built_in">size</span>(),<br>                           <span class="hljs-string">&quot;missing start of fragmented record(2)&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          scratch-&gt;<span class="hljs-built_in">append</span>(fragment.<span class="hljs-built_in">data</span>(), fragment.<span class="hljs-built_in">size</span>());<br>          *record = <span class="hljs-built_in">Slice</span>(*scratch);<br>          last_record_offset_ = prospective_record_offset;<br>          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">break</span>;<br><br>      <span class="hljs-keyword">case</span> kEof:<br>        <span class="hljs-keyword">if</span> (in_fragmented_record) &#123;<br>          <span class="hljs-comment">// This can be caused by the writer dying immediately after</span><br>          <span class="hljs-comment">// writing a physical record but before completing the next; don&#x27;t// scratch 用于缓存一条日志的数据</span><br>          <span class="hljs-comment">// treat it as a corruption, just ignore the entire logical record.</span><br>          scratch-&gt;<span class="hljs-built_in">clear</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>      <span class="hljs-keyword">case</span> kBadRecord:<br>        <span class="hljs-keyword">if</span> (in_fragmented_record) &#123;<br>          <span class="hljs-built_in">ReportCorruption</span>(scratch-&gt;<span class="hljs-built_in">size</span>(), <span class="hljs-string">&quot;error in middle of record&quot;</span>);<br>          in_fragmented_record = <span class="hljs-literal">false</span>;<br>          scratch-&gt;<span class="hljs-built_in">clear</span>();<br>        &#125;<br>        <span class="hljs-keyword">break</span>;<br><br>      <span class="hljs-keyword">default</span>: &#123;<br>        <span class="hljs-type">char</span> buf[<span class="hljs-number">40</span>];<br>        std::<span class="hljs-built_in">snprintf</span>(buf, <span class="hljs-built_in">sizeof</span>(buf), <span class="hljs-string">&quot;unknown record type %u&quot;</span>, record_type);<br>        <span class="hljs-built_in">ReportCorruption</span>(<br>            (fragment.<span class="hljs-built_in">size</span>() + (in_fragmented_record ? scratch-&gt;<span class="hljs-built_in">size</span>() : <span class="hljs-number">0</span>)),<br>            buf);<br>        in_fragmented_record = <span class="hljs-literal">false</span>;<br>        scratch-&gt;<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// ------------ End of Code Fragment B -------------</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个函数中主要分为两个部分，A 部分的代码主要是一些准备工作，例如将文件的 offset 移动到第一个 Chunk 的起始位置，清空缓冲区等；B 部分代码的工作是不断地读出下一个 Chunk 的内容，根据这个 Chunk 的类型来判断是否需要继续读下一个 Chunk（读到了 First 类型或者 Middle 类型的 Chunk）,如果一条日志的内容读取完了（读到了 Full 类型或者 Last 类型的 Chunk），就将缓冲区中的数据组装成一个 <em>Slice</em> 对象返回，这个对象中的内容就是一条逻辑日志的完整内容。</p><p>读取下一个 Chunk 的执行逻辑主要在 <code>ReadPhysicalRecord</code> 函数中，它的内容如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// log_reader.cc</span><br><span class="hljs-comment">// 从 buffer 中读取一个 Chunk，返回这个 chunk 的类型</span><br><span class="hljs-comment">// 如果当前 buffer 已经读完，则会从文件中读取下一个 Block 的内容到 buffer 中</span><br><span class="hljs-comment">// 如果文件的内容也被读完了，则返回 eof</span><br><span class="hljs-function"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-title">Reader::ReadPhysicalRecord</span><span class="hljs-params">(Slice* result)</span> </span>&#123;<br>  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-comment">// ------------ Start of Code Fragment A -------------</span><br>    <span class="hljs-comment">// 如果 buffer 中剩余的数据大小小于一个 ChunkHeader 的大小</span><br>    <span class="hljs-comment">// 则说明剩下的都是 trailer，直接跳到下一个 Block</span><br>    <span class="hljs-keyword">if</span> (buffer_.<span class="hljs-built_in">size</span>() &lt; kHeaderSize) &#123;<br>      <span class="hljs-keyword">if</span> (!eof_) &#123;<br>        <span class="hljs-comment">// Last read was a full read, so this is a trailer to skip</span><br>        buffer_.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-comment">// 读取下一个 Block</span><br>        Status status = file_-&gt;<span class="hljs-built_in">Read</span>(kBlockSize, &amp;buffer_, backing_store_);<br>        end_of_buffer_offset_ += buffer_.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span> (!status.<span class="hljs-built_in">ok</span>()) &#123;<br>          buffer_.<span class="hljs-built_in">clear</span>();<br>          <span class="hljs-built_in">ReportDrop</span>(kBlockSize, status);<br>          eof_ = <span class="hljs-literal">true</span>;<br>          <span class="hljs-keyword">return</span> kEof;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (buffer_.<span class="hljs-built_in">size</span>() &lt; kBlockSize) &#123;<br>          eof_ = <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">continue</span>;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// Note that if buffer_ is non-empty, we have a truncated header at the</span><br>        <span class="hljs-comment">// end of the file, which can be caused by the writer crashing in the</span><br>        <span class="hljs-comment">// middle of writing the header. Instead of considering this an error,</span><br>        <span class="hljs-comment">// just report EOF.</span><br>        buffer_.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-keyword">return</span> kEof;<br>      &#125;<br>    &#125;<br>    <span class="hljs-comment">// ------------ End of Code Fragment A -------------</span><br><br>    <span class="hljs-comment">// ------------ Start of Code Fragment B -------------</span><br>    <span class="hljs-comment">// Parse the header</span><br>    <span class="hljs-comment">// 获取当前 Chunk 的 type 和 data length</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* header = buffer_.<span class="hljs-built_in">data</span>();<br>    <span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span> a = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(header[<span class="hljs-number">4</span>]) &amp; <span class="hljs-number">0xff</span>;<br>    <span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span> b = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(header[<span class="hljs-number">5</span>]) &amp; <span class="hljs-number">0xff</span>;<br>    <span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> type = header[<span class="hljs-number">6</span>];<br>    <span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span> length = a | (b &lt;&lt; <span class="hljs-number">8</span>);<br><br>    <span class="hljs-comment">// 如果 Header 的大小加上数据部分的大小比 buffer 中数据的大小还大</span><br>    <span class="hljs-comment">// 说明数据的读取发生了异常，报告异常并返回</span><br>    <span class="hljs-keyword">if</span> (kHeaderSize + length &gt; buffer_.<span class="hljs-built_in">size</span>()) &#123;<br>      <span class="hljs-type">size_t</span> drop_size = buffer_.<span class="hljs-built_in">size</span>();<br>      buffer_.<span class="hljs-built_in">clear</span>();<br>      <span class="hljs-keyword">if</span> (!eof_) &#123;<br>        <span class="hljs-built_in">ReportCorruption</span>(drop_size, <span class="hljs-string">&quot;bad record length&quot;</span>);<br>        <span class="hljs-keyword">return</span> kBadRecord;<br>      &#125;<br>      <span class="hljs-comment">// If the end of the file has been reached without reading |length| bytes</span><br>      <span class="hljs-comment">// of payload, assume the writer died in the middle of writing the record.</span><br>      <span class="hljs-comment">// Don&#x27;t report a corruption.</span><br>      <span class="hljs-keyword">return</span> kEof;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (type == kZeroType &amp;&amp; length == <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-comment">// Skip zero length record without reporting any drops since</span><br>      <span class="hljs-comment">// such records are produced by the mmap based writing code in</span><br>      <span class="hljs-comment">// env_posix.cc that preallocates file regions.</span><br>      buffer_.<span class="hljs-built_in">clear</span>();<br>      <span class="hljs-keyword">return</span> kBadRecord;<br>    &#125;<br><br>    <span class="hljs-comment">// Check crc</span><br>    <span class="hljs-comment">// 检查校验和，如果校验和不对，那么也报告异常</span><br>    <span class="hljs-keyword">if</span> (checksum_) &#123;<br>      <span class="hljs-type">uint32_t</span> expected_crc = crc32c::<span class="hljs-built_in">Unmask</span>(<span class="hljs-built_in">DecodeFixed32</span>(header));<br>      <span class="hljs-type">uint32_t</span> actual_crc = crc32c::<span class="hljs-built_in">Value</span>(header + <span class="hljs-number">6</span>, <span class="hljs-number">1</span> + length);<br>      <span class="hljs-keyword">if</span> (actual_crc != expected_crc) &#123;<br>        <span class="hljs-comment">// Drop the rest of the buffer since &quot;length&quot; itself may have</span><br>        <span class="hljs-comment">// been corrupted and if we trust it, we could find some</span><br>        <span class="hljs-comment">// fragment of a real log record that just happens to look</span><br>        <span class="hljs-comment">// like a valid log record.</span><br>        <span class="hljs-type">size_t</span> drop_size = buffer_.<span class="hljs-built_in">size</span>();<br>        buffer_.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-built_in">ReportCorruption</span>(drop_size, <span class="hljs-string">&quot;checksum mismatch&quot;</span>);<br>        <span class="hljs-keyword">return</span> kBadRecord;<br>      &#125;<br>    &#125;<br>    <span class="hljs-comment">// ------------ End of Code Fragment B -------------</span><br><br>    <span class="hljs-comment">// ------------ Start of Code Fragment C -------------</span><br>    <span class="hljs-comment">// 读取成功，将当前 Block 的 offset 往前移动到下一条 Chunk 的开头</span><br>    buffer_.<span class="hljs-built_in">remove_prefix</span>(kHeaderSize + length);<br><br>    <span class="hljs-comment">// Skip physical record that started before initial_offset_</span><br>    <span class="hljs-keyword">if</span> (end_of_buffer_offset_ - buffer_.<span class="hljs-built_in">size</span>() - kHeaderSize - length &lt;<br>        initial_offset_) &#123;<br>      result-&gt;<span class="hljs-built_in">clear</span>();<br>      <span class="hljs-keyword">return</span> kBadRecord;<br>    &#125;<br><br>    *result = <span class="hljs-built_in">Slice</span>(header + kHeaderSize, length);<br>    <span class="hljs-keyword">return</span> type;<br>    <span class="hljs-comment">// ------------ End of Code Fragment C -------------</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码中，主要包含三部分逻辑。A 部分主要判断当前 Block 中是否还有下一条日志，如果没有则切换到下一个 Block 。如果无法读取下一个 Block 或者下一个 Block 的大小小于一个标准 Block 的大小（32 KB），则说明文件已经读完，将 eof 标志置为 true 。B 部分代码主要是根据还原 ChunkHeader,并且根据数据长度、校验和等信息判断 Chunk 中数据的正确性。程序运行到 C 部分代码则表示前面的读取和校验都没有问题，那么只需要将 buffer 的 offset 前移，然后将读取到的内容包装成一个 <em>Slice</em> 返回即可。以上三段代码便组成了从 Block 中读取一个 Chunk 的逻辑。</p><p>在 A 部分代码中，如果当前 buffer（即当前内存中的 Block）已经读到了末尾，那么就需要从文件中载入下一个 Block 。这里使用的函数是 <code>SequentialFile::Read</code> ，这个函数就是简单地使用系统调用从文件中读取了一段数据出来，因此也就不展开讲了。</p><p>到这里，LevelDB 的 WAL 日志就讲完了。应该说整个逻辑还是比较清晰易懂的，主要就是一些编解码的过程。仔细体会这个过程，对我们理解数据编码解码还是很有帮助的。</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>源代码阅读</category>
      
      <category>LevelDB</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>LevelDB 源代码阅读（二）：读流程</title>
    <link href="/2021/07/10/Leveldb-source-code-reading-2/"/>
    <url>/2021/07/10/Leveldb-source-code-reading-2/</url>
    
    <content type="html"><![CDATA[<p>在 <a href="/2021/07/08/leveldb-source-code-reading-1/" title="LevelDB 源代码阅读（一）：写流程">LevelDB 源代码阅读（一）：写流程</a> 中我们介绍了 LevelDB 的 LSM 树结构以及数据写入 LevelDB 的流程。本文我们将介绍从 LevelDB 中读取数据的流程。</p><h1 id="快照（Snapshot）"><a href="#快照（Snapshot）" class="headerlink" title="快照（Snapshot）"></a>快照（Snapshot）</h1><p>在介绍 LevelDB 的读流程之前，首先介绍一下<strong>快照（Snapshot）</strong>的概念。所谓快照，其实就是代表了数据库在某一个时刻的状态，LevelDB 中数据读取就是通过 Snapshot 机制来实现的。</p><p>LevelDB 的快照通过一个名为 <strong>sequence number</strong> 的整型数来实现。当数据被写入后，此次操作对应数据就不可再更改。假如我们在 LevelDB 中对一个键 <code>testkey</code> 赋一个值 <code>testvalue1</code>，那么这次操作对应的数据就会被存放在内存或磁盘上。假如我们又对 <code>testkey</code> 赋了一个新的值 <code>testvalue2</code>，那么前面操作的值无法修改，那么系统应该怎么去更新这个键所对应的值呢？答案是通过 sequence number 。LevelDB 维护了一个全局的 sequence number ，每次有写操作发生时这个 sequence number 就会加一。在写操作发生时，LevelDB 会为这个写操作分配一个 sequence number，其值就是当前系统中 sequence number 的值。在操作记录被持久化时，sequence number 也会通过一定的编码方式被持久化到数据中（详情看写流程的文章）。这样，新操作的 sequence number 永远会比旧操作的 sequence number 大。在读取数据时，我们就可以通过不同 sequence number 的值对应数据库历史上不同的状态。假如同时存在 sequence number 为 99、100、101 的三个操作记录，那么就会以 101 所对应的数据为当前数据库中所记录的数据。在进行文件合并（Compaction）时，对同一数据的不同操作记录会被消除，只保留 sequence number 最大的一条操作记录所对应的数据（假如此记录将数据从数据库中删除了，那么就无需保留任何数据）。</p><img src="leveldb-snapshot.png" width=50%><p>快照在代码中对应的类是 <em>SnapshotImpl</em> ，其内部保存了两个 SnapshotImpl 指针 prev 和 next，这和 SnapshotList 有关；另外还保存了一个 uint_64 类型的 sequence number。当用户创建一个快照时，LevelDB 会将系统中最新的 sequence number 值赋予这个 Snapshot ，这样用户通过这个 Snapshot 读取的数据就是系统中当前状态下的数据。在读数据时，所有读取到的数据会根据 Snapshot 的 sequence number 进行筛选，所有 seqnum 大于该 Snapshot 的 seqnum 的数据都会被剔除，剩下的记录中 seqnum 最大的那一个就是需要读取的数据。</p><h1 id="读操作"><a href="#读操作" class="headerlink" title="读操作"></a>读操作</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// db_impl.cc</span><br><span class="hljs-function">Status <span class="hljs-title">DBImpl::Get</span><span class="hljs-params">(<span class="hljs-type">const</span> ReadOptions&amp; options, <span class="hljs-type">const</span> Slice&amp; key,</span></span><br><span class="hljs-params"><span class="hljs-function">                   std::string* value)</span> </span>&#123;<br>  Status s;<br>  <span class="hljs-function">MutexLock <span class="hljs-title">l</span><span class="hljs-params">(&amp;mutex_)</span></span>;<br>  <span class="hljs-comment">// get the snapshot for read</span><br>  SequenceNumber snapshot;<br>  <span class="hljs-keyword">if</span> (options.snapshot != <span class="hljs-literal">nullptr</span>) &#123;<br>    snapshot =<br>        <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">const</span> SnapshotImpl*&gt;(options.snapshot)-&gt;<span class="hljs-built_in">sequence_number</span>();<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    snapshot = versions_-&gt;<span class="hljs-built_in">LastSequence</span>();<br>  &#125;<br><br>  <span class="hljs-comment">// increase the reference count for MemTable, ImmutableMemTable and Version</span><br>  MemTable* mem = mem_;<br>  MemTable* imm = imm_;<br>  Version* current = versions_-&gt;<span class="hljs-built_in">current</span>();<br>  mem-&gt;<span class="hljs-built_in">Ref</span>();<br>  <span class="hljs-keyword">if</span> (imm != <span class="hljs-literal">nullptr</span>) imm-&gt;<span class="hljs-built_in">Ref</span>();<br>  current-&gt;<span class="hljs-built_in">Ref</span>();<br><br>  <span class="hljs-type">bool</span> have_stat_update = <span class="hljs-literal">false</span>;<br>  Version::GetStats stats;<br><br>  <span class="hljs-comment">// Unlock while reading from files and memtables</span><br>  &#123;<br>    mutex_.<span class="hljs-built_in">Unlock</span>();<br>    <span class="hljs-comment">// First look in the memtable, then in the immutable memtable (if any).</span><br>    <span class="hljs-comment">// the search order is : MemTable -&gt; Immutable MemTable -&gt; SSTable</span><br>    <span class="hljs-function">LookupKey <span class="hljs-title">lkey</span><span class="hljs-params">(key, snapshot)</span></span>;<br>    <span class="hljs-keyword">if</span> (mem-&gt;<span class="hljs-built_in">Get</span>(lkey, value, &amp;s)) &#123;<br>      <span class="hljs-comment">// Done</span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (imm != <span class="hljs-literal">nullptr</span> &amp;&amp; imm-&gt;<span class="hljs-built_in">Get</span>(lkey, value, &amp;s)) &#123;<br>      <span class="hljs-comment">// Done</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      s = current-&gt;<span class="hljs-built_in">Get</span>(options, lkey, value, &amp;stats);<br>      have_stat_update = <span class="hljs-literal">true</span>;<br>    &#125;<br>    mutex_.<span class="hljs-built_in">Lock</span>();<br>  &#125;<br><br>  <span class="hljs-comment">// update the statistic info for SSTable, may run compaction in background</span><br>  <span class="hljs-keyword">if</span> (have_stat_update &amp;&amp; current-&gt;<span class="hljs-built_in">UpdateStats</span>(stats)) &#123;<br>    <span class="hljs-built_in">MaybeScheduleCompaction</span>();<br>  &#125;<br><br>  <span class="hljs-comment">// decrease the ref count</span><br>  mem-&gt;<span class="hljs-built_in">Unref</span>();<br>  <span class="hljs-keyword">if</span> (imm != <span class="hljs-literal">nullptr</span>) imm-&gt;<span class="hljs-built_in">Unref</span>();<br>  current-&gt;<span class="hljs-built_in">Unref</span>();<br>  <span class="hljs-keyword">return</span> s;<br>&#125;<br></code></pre></td></tr></table></figure><p>代码的执行流程如下：</p><ul><li>获取此次 Get 操作对应的 Snapshot 。</li><li>获取系统内存中的 MemTable、ImmutableMemtable 和 Version，前两者在 LSM 树中都有对应，Version 主要是维护 SSTable 的版本信息。获取之后增加其引用计数，这三个数据结构在引用计数为 0 时会其对应的内存会被释放。</li><li>依次从 MemTable、Immutable Memtable 和 SSTable 中查找对应的数据。</li><li>更新 SSTable 的统计信息，可能会在后台进行数据文件合并（Compaction）。</li><li>减少 MemTable、ImmutableMemTable 以及 Version 的引用计数。</li></ul><img src="leveldb-search_order.jpeg" width=70%><p>在查找时，对 MemTable 和 Immutable MemTable 都通过 SkipList 实现，这将在介绍 MemTable 的文章中解读。我们首先关注对 SSTable 的查找。对 SSTable 的查找最终会进入到 <code>ForEachOverlapping</code> 函数中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// version_set.cc</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Version::ForEachOverlapping</span><span class="hljs-params">(Slice user_key, Slice internal_key, <span class="hljs-type">void</span>* arg,</span></span><br><span class="hljs-params"><span class="hljs-function">                                 <span class="hljs-type">bool</span> (*func)(<span class="hljs-type">void</span>*, <span class="hljs-type">int</span>, FileMetaData*))</span> </span>&#123;<br>  <span class="hljs-type">const</span> Comparator* ucmp = vset_-&gt;icmp_.<span class="hljs-built_in">user_comparator</span>();<br><br>  <span class="hljs-comment">// Search level-0 in order from newest to oldest.</span><br>  std::vector&lt;FileMetaData*&gt; tmp;<br>  tmp.<span class="hljs-built_in">reserve</span>(files_[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>());<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">uint32_t</span> i = <span class="hljs-number">0</span>; i &lt; files_[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>(); i++) &#123;<br>    FileMetaData* f = files_[<span class="hljs-number">0</span>][i];<br>    <span class="hljs-comment">// search for SSTable, which may contains the key for current read</span><br>    <span class="hljs-keyword">if</span> (ucmp-&gt;<span class="hljs-built_in">Compare</span>(user_key, f-&gt;smallest.<span class="hljs-built_in">user_key</span>()) &gt;= <span class="hljs-number">0</span> &amp;&amp;<br>        ucmp-&gt;<span class="hljs-built_in">Compare</span>(user_key, f-&gt;largest.<span class="hljs-built_in">user_key</span>()) &lt;= <span class="hljs-number">0</span>) &#123;<br>      tmp.<span class="hljs-built_in">push_back</span>(f);<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (!tmp.<span class="hljs-built_in">empty</span>()) &#123;<br>  <span class="hljs-comment">// sort the selected files from new to old</span><br>    std::<span class="hljs-built_in">sort</span>(tmp.<span class="hljs-built_in">begin</span>(), tmp.<span class="hljs-built_in">end</span>(), NewestFirst);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">uint32_t</span> i = <span class="hljs-number">0</span>; i &lt; tmp.<span class="hljs-built_in">size</span>(); i++) &#123;<br>    <span class="hljs-comment">// if key are found in current file, return</span><br>    <span class="hljs-comment">// else continue to search in next file</span><br>      <span class="hljs-keyword">if</span> (!(*func)(arg, <span class="hljs-number">0</span>, tmp[i])) &#123;<br>        <span class="hljs-keyword">return</span>;<br>      &#125;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// Search other levels.</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> level = <span class="hljs-number">1</span>; level &lt; config::kNumLevels; level++) &#123;<br>    <span class="hljs-type">size_t</span> num_files = files_[level].<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">if</span> (num_files == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br><br>    <span class="hljs-comment">// Binary search to find earliest index whose largest key &gt;= internal_key.</span><br>    <span class="hljs-type">uint32_t</span> index = <span class="hljs-built_in">FindFile</span>(vset_-&gt;icmp_, files_[level], internal_key);<br>    <span class="hljs-keyword">if</span> (index &lt; num_files) &#123;<br>      FileMetaData* f = files_[level][index];<br>      <span class="hljs-keyword">if</span> (ucmp-&gt;<span class="hljs-built_in">Compare</span>(user_key, f-&gt;smallest.<span class="hljs-built_in">user_key</span>()) &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// All of &quot;f&quot; is past any data for user_key</span><br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> (!(*func)(arg, level, f)) &#123;<br>          <span class="hljs-keyword">return</span>;<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以看到，针对 SSTable 的查找分为了两个部分：对 Level-0 文件的查找以及对 Level 大于 0 的文件查找。</p><p>在对 Level-0 层的文件进行查找时，系统会将每一个有可能包含这个 key 的文件都加入到待搜查列表中，随后将选中的文件从新到旧进行排序（新文件中存储的数据才是有效的数据），再对按序对每个文件进行查找。</p><p>在对 Level-N（N&gt;0）层的文件进行查找时，系统在每一层中通过二分查找找到了一个候选文件。如果这个文件不包含当前的 key，那么这一层的查找就结束了。</p><p>之所以对 Level-0 层的查找需要选取许多候选文件进行多次搜索，而对 Level-N（N &gt; 0）层的文件查找只需一次，是因为 Level-0 层的文件都是从数据库中直接 dump 出来的，有可能存在前文所描述的数据重复的情况。而从 Level-1 层开始，数据文件都是从上一层文件中合并得到的。在合并的过程中，对同一条数据的操作只会保留一条，并且所有的文件会按照 key 的顺序排列，整个 Level-1 层及以上的文件是有序的。</p><p>到这里，LevelDB 的读流程就介绍完毕了。LevelDB 的读流程值得品味的点没有写流程的多，对 SSTable 的管理和查找处理的比较细节，当然这里也和 Compaction 模块有关，在后续的文章中会继续介绍。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://leveldb-handbook.readthedocs.io/zh/latest/">LevelDB Handbook</a></p><p><a href="https://zhuanlan.zhihu.com/p/80668555">LevelDb 源码阅读–读操作</a></p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>源代码阅读</category>
      
      <category>LevelDB</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>LevelDB 源代码阅读（一）：写流程</title>
    <link href="/2021/07/08/leveldb-source-code-reading-1/"/>
    <url>/2021/07/08/leveldb-source-code-reading-1/</url>
    
    <content type="html"><![CDATA[<p>LevelDB 是一款基于 LSM 树的嵌入式高性能 NoSQL 数据库，由 Google 的两位 Fellow （Jeff Dean 和 Sanjay Ghemawat）设计开发。LevelDB 最初使用 <a href="https://github.com/google/leveldb">C++</a> 开发，后面衍生出了不同语言版本，如 <a href="https://github.com/golang/leveldb">Go-LevelDB</a>、 <a href="https://github.com/dain/leveldb">Java-LevelDB</a> 等。本系列文章基于最新 C++ 版 LevelDB（1.23.0，截止 2021.7.8），对其结构设计进行分析，相关代码存放在<a href="https://github.com/THUMarkLau/leveldb">我的 github 仓库</a>。</p><h1 id="LSM-树结构"><a href="#LSM-树结构" class="headerlink" title="LSM 树结构"></a>LSM 树结构</h1><p>LSM 树的英文全称为 <strong>Log-Structured-Merge-Tree</strong>，翻译过来就是结构日志合并树。但是 LSM 树并不是一种严格意义上的树型数据结构，而是一种数据存储机制。这种树的机制大致如图</p><img src="LSM.png"><p>当一个数据写入时，首先记录预写日志，然后将数据插入到内存中一个名为 <strong>MemTable</strong> 的数据结构中。当 MemTable 的大小到达阈值后，就会转换为 Immutable MemTable 。MemTable 和 Immutable MemTable 的内容大致相同，但是 Immutable MemTable 无法再发生写入。因此，在 MemTable 转换为 Immutable MemTable 的同时，也会开启一个新的 MemTable 供新数据写入。</p><p>Immutable MemTable 则在后台线程中经过压缩等程序后，被写入磁盘中，成为 SSTable 。一个 SSTable 往往就是一个数据文件。SSTable 是无法被修改的，但是有时用户会写入覆盖前面数据的新数据，例如在 KV 数据库中对一个原有的 Key 赋予一个新的值。所以，新老 SSTable 之间可能存在数据重叠。同时，因为 MemTable 的大小容易受到物理内存大小的限制，一般不会太大。因此，从数据库中直接 dump 出来的 SSTable 一般比较小，数目也比较多。过多的数据文件数量会导致数据库的查询性能下降，因此在文件落盘后，数据库还会对文件进行<strong>合并（Compaction）</strong>。合并即将小的 SSTable 合并为大的 SSTable，并且在合并的过程中还可能会进行数据去重、布局优化等操作。</p><p>LevelDB 中的 Level，代表的就是其后台使用的合并策略。如图所示，在 LevelDB 中，数据文件（即 SSTable）按照层级进行管理。从数据库中直接 dump 出的数据文件为第 0 层，多个 0 层文件进行合并以后得到了 1 层文件，多个 1 层文件合并后得到 2 层文件，以此类推。多个第 N - 1 层文件进行合并会得到一个第 N 层文件，文件所在的层数也代表了其中的数据被合并的次数。同时，随着文件层数的增加，文件的大小也一般会变得越来越大。</p><p>当然，合并的策略不止 Level Compaction 这一种，学术界提出了许多种合并策略，感兴趣的读者可以自行搜索阅读，本文就不再深入。</p><h1 id="LevelDB-写入流程"><a href="#LevelDB-写入流程" class="headerlink" title="LevelDB 写入流程"></a>LevelDB 写入流程</h1><p>LevelDB 没有设计成 C&#x2F;S 模式，而是将数据库以库文件的形式提供给用户，运行时数据库需要和服务一起部署在同一台服务器上。我们简单地用下面这一段代码来说明 LevelDB 的写入过程：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//</span><br><span class="hljs-comment">// Created by lau on 2021/6/17.</span><br><span class="hljs-comment">//</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cassert&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;leveldb/db.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> leveldb;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  DB *db;<br>  Options options;<br>  options.create_if_missing = <span class="hljs-literal">true</span>;<br>  Status status = DB::<span class="hljs-built_in">Open</span>(options, <span class="hljs-string">&quot;./dbtest&quot;</span>, &amp;db);<br>  <span class="hljs-built_in">assert</span>(status.<span class="hljs-built_in">ok</span>());<br>  std::string value;<br>  std::string key1 = <span class="hljs-string">&quot;testkey1&quot;</span>;<br>  leveldb::Status s = db-&gt;<span class="hljs-built_in">Get</span>(leveldb::<span class="hljs-built_in">ReadOptions</span>(), key1, &amp;value);<br>  <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">IsNotFound</span>()) &#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;can not found for key:&quot;</span> &lt;&lt; key1 &lt;&lt; std::endl;<br>    db-&gt;<span class="hljs-built_in">Put</span>(leveldb::<span class="hljs-built_in">WriteOptions</span>(), key1, <span class="hljs-string">&quot;testvalue1&quot;</span>);<br>  &#125;<br>  s = db-&gt;<span class="hljs-built_in">Get</span>(leveldb::<span class="hljs-built_in">ReadOptions</span>(), key1, &amp;value);<br>  <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">ok</span>()) &#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;found key:&quot;</span> &lt;&lt; key1 &lt;&lt; <span class="hljs-string">&quot;,value:&quot;</span> &lt;&lt; value &lt;&lt; std::endl;<br>  &#125;<br>  s = db-&gt;<span class="hljs-built_in">Delete</span>(leveldb::<span class="hljs-built_in">WriteOptions</span>(), key1);<br>  <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">ok</span>()) &#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;delete key success which key:&quot;</span> &lt;&lt; key1 &lt;&lt; std::endl;<br>  &#125;<br>  s = db-&gt;<span class="hljs-built_in">Get</span>(leveldb::<span class="hljs-built_in">ReadOptions</span>(), key1, &amp;value);<br>  <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">IsNotFound</span>()) &#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;can not found after delete for key:&quot;</span> &lt;&lt; key1 &lt;&lt; std::endl;<br>  &#125;<br><br>  <span class="hljs-keyword">delete</span> db;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>代码的第 13 行到 17 行启动了一个 LevelDB 实例，第 18 到 20 行试图从 LevelDB 中获取键 <em>testkey1</em> 所对应的值。当获取失败后，第 23 行则会向数据库中插入键 <code>testkey1</code> 及其对应的值 <em>testvalue1</em> 。25 行到 28 行则在插入完成后重新查询该键对应的值，29 行到 32 行删除该键对应的值，33 到 36 行则尝试在删除之后再次查询。现在我们考虑第 23 行插入的过程。</p><h2 id="WriteBatch-编码规则"><a href="#WriteBatch-编码规则" class="headerlink" title="WriteBatch 编码规则"></a>WriteBatch 编码规则</h2><p>Debug 进入该函数，我们可以看到 <code>Put</code> 函数的内容</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// db_impl.cc</span><br><span class="hljs-function">Status <span class="hljs-title">DB::Put</span><span class="hljs-params">(<span class="hljs-type">const</span> WriteOptions&amp; opt, <span class="hljs-type">const</span> Slice&amp; key, <span class="hljs-type">const</span> Slice&amp; value)</span> </span>&#123;<br>  WriteBatch batch;<br>  batch.<span class="hljs-built_in">Put</span>(key, value);<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Write</span>(opt, &amp;batch);<br>&#125;<br></code></pre></td></tr></table></figure><p>首先，在进入这个函数之前，我们在 <code>main</code> 函数中以字符串形式存放的 key 和 value 被封装成了 <em>Slice</em> 对象。 Slice 类是一个简单的类，里面有存储了两个数据：以 <code>char*</code> 形式存储的 data 以及以 <code>size_t</code> 记录的 data 大小。这里在 key 对应的 Slice 里面，data 指向了 <code>testkey1</code>，size 则是 8；value 对应的 Slice 里 data 指向了 <code>testvalue</code>，size 则是 10 。</p><p><code>Put</code> 函数的第一行声明了一个 <em>WriteBatch</em> 对象。LevelDB 对外提供了两种写入接口：<code>Put</code> 和 <code>Delete</code> 。在这两种操作中，数据库都会创建一个 WriteBatch 来执行对应的操作，一个 Batch 中的操作是原子的，其是数据库执行一次操作的最小单元。在 WriteBatch 中，所有的数据在被编码后存放在了一个名为 <em>rep_</em> 的 string 中。rep_ 在初始化时会被 resize 成 12 字节大小。这 12 个字节的前 8 个字节（即 64 个 bit）存放了操作的 sequence number，后 4 个字节（32 个 bit)存放了该 Batch 中操作的数量。sequence number 本质上是一个计数器，每个操作都对应了一个 sequence number 。该计数器在 leveldb 内部维护，每进行一次操作就累加一次。由于在 leveldb 中，一次更新或者一次删除，采用的是 append 的方式，而非直接更新原数据。因此对同样一个 key，会有多个版本的数据记录，而最大的 sequence number 对应的数据记录就是最新的。</p><p>在 <code>Put</code> 函数的第二行，函数将写操作对应的 key 和 value 放入了 WriteBatch 中。我们跟着进入这个函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// write_batch.cc</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">WriteBatch::Put</span><span class="hljs-params">(<span class="hljs-type">const</span> Slice&amp; key, <span class="hljs-type">const</span> Slice&amp; value)</span> </span>&#123;<br>  <span class="hljs-comment">// set the count of operation item</span><br>  WriteBatchInternal::<span class="hljs-built_in">SetCount</span>(<span class="hljs-keyword">this</span>, WriteBatchInternal::<span class="hljs-built_in">Count</span>(<span class="hljs-keyword">this</span>) + <span class="hljs-number">1</span>);<br>  <span class="hljs-comment">// record the operation type</span><br>  rep_.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">char</span>&gt;(kTypeValue));<br>  <span class="hljs-comment">// record the key</span><br>  <span class="hljs-built_in">PutLengthPrefixedSlice</span>(&amp;rep_, key);<br>  <span class="hljs-comment">// record the value</span><br>  <span class="hljs-built_in">PutLengthPrefixedSlice</span>(&amp;rep_, value);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，这个函数主要调用了四个函数做了四件事情：</p><ul><li>第一行调用 <code>SetCount</code> 函数，修改 rep_ 的第 9 到 12 个字节中所记录的操作数量，让它在原来的基础上加一。</li><li>第二行将此次操作的类型记录进 rep_ 中，kTypeValue 是一个 enum 类型的数据，其值为 0x1，代表插入。删除所对应的类型为 kTypeDeletion，其值为 0x0 。</li><li>第三行将 key 的数据编码进了 rep_ 中。</li><li>第四行将 value 的数据编码进了 rep_ 中。</li></ul><p>在 <code>PutLengthPrefixedSlice</code> 中编码数据时，函数会先将数据的长度记录进 rep_ 中，再将数据的值记录到 rep_ 中。因此一个操作在 WriteBatch 中被编码为</p><img src="Leveldb-operation_encode.png" width=80%><p>而整个 WriteBatch 在 rep_ 中的编码为</p><img src="Leveldb-write_batch.png" width=50%><h2 id="合并写"><a href="#合并写" class="headerlink" title="合并写"></a>合并写</h2><p>回到 <em>db_impl.cc</em> 的 <code>Put</code> 函数中，其最后一个操作是将编码好的 WriteBatch 在数据库中写入。下面我们进入这个 <code>Write</code> 函数看一看。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// db_impl.cc</span><br><span class="hljs-function">Status <span class="hljs-title">DBImpl::Write</span><span class="hljs-params">(<span class="hljs-type">const</span> WriteOptions&amp; options, WriteBatch* updates)</span> </span>&#123;<br>  <span class="hljs-function">Writer <span class="hljs-title">w</span><span class="hljs-params">(&amp;mutex_)</span></span>;<br>  w.batch = updates;<br>  w.sync = options.sync;<br>  w.done = <span class="hljs-literal">false</span>;<br><br>  <span class="hljs-function">MutexLock <span class="hljs-title">l</span><span class="hljs-params">(&amp;mutex_)</span></span>;<br>  writers_.<span class="hljs-built_in">push_back</span>(&amp;w);<br>  <span class="hljs-keyword">while</span> (!w.done &amp;&amp; &amp;w != writers_.<span class="hljs-built_in">front</span>()) &#123;<br>    w.cv.<span class="hljs-built_in">Wait</span>();<br>  &#125;<br>  <span class="hljs-keyword">if</span> (w.done) &#123;<br>    <span class="hljs-keyword">return</span> w.status;<br>  &#125;<br><br>  <span class="hljs-comment">// May temporarily unlock and wait.</span><br>  Status status = <span class="hljs-built_in">MakeRoomForWrite</span>(updates == <span class="hljs-literal">nullptr</span>);<br>  <span class="hljs-type">uint64_t</span> last_sequence = versions_-&gt;<span class="hljs-built_in">LastSequence</span>();<br>  Writer* last_writer = &amp;w;<br>  <span class="hljs-keyword">if</span> (status.<span class="hljs-built_in">ok</span>() &amp;&amp; updates != <span class="hljs-literal">nullptr</span>) &#123;  <span class="hljs-comment">// nullptr batch is for compactions</span><br>    WriteBatch* write_batch = <span class="hljs-built_in">BuildBatchGroup</span>(&amp;last_writer);<br>    WriteBatchInternal::<span class="hljs-built_in">SetSequence</span>(write_batch, last_sequence + <span class="hljs-number">1</span>);<br>    last_sequence += WriteBatchInternal::<span class="hljs-built_in">Count</span>(write_batch);<br><br>    <span class="hljs-comment">// Add to log and apply to memtable.  We can release the lock</span><br>    <span class="hljs-comment">// during this phase since &amp;w is currently responsible for logging</span><br>    <span class="hljs-comment">// and protects against concurrent loggers and concurrent writes</span><br>    <span class="hljs-comment">// into mem_.</span><br>    &#123;<br>      mutex_.<span class="hljs-built_in">Unlock</span>();<br>      status = log_-&gt;<span class="hljs-built_in">AddRecord</span>(WriteBatchInternal::<span class="hljs-built_in">Contents</span>(write_batch));<br>      <span class="hljs-type">bool</span> sync_error = <span class="hljs-literal">false</span>;<br>      <span class="hljs-keyword">if</span> (status.<span class="hljs-built_in">ok</span>() &amp;&amp; options.sync) &#123;<br>        status = logfile_-&gt;<span class="hljs-built_in">Sync</span>();<br>        <span class="hljs-keyword">if</span> (!status.<span class="hljs-built_in">ok</span>()) &#123;<br>          sync_error = <span class="hljs-literal">true</span>;<br>        &#125;<br>      &#125;<br>      <span class="hljs-keyword">if</span> (status.<span class="hljs-built_in">ok</span>()) &#123;<br>        status = WriteBatchInternal::<span class="hljs-built_in">InsertInto</span>(write_batch, mem_);<br>      &#125;<br>      mutex_.<span class="hljs-built_in">Lock</span>();<br>      <span class="hljs-keyword">if</span> (sync_error) &#123;<br>        <span class="hljs-comment">// The state of the log file is indeterminate: the log record we</span><br>        <span class="hljs-comment">// just added may or may not show up when the DB is re-opened.</span><br>        <span class="hljs-comment">// So we force the DB into a mode where all future writes fail.</span><br>        <span class="hljs-built_in">RecordBackgroundError</span>(status);<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (write_batch == tmp_batch_) tmp_batch_-&gt;<span class="hljs-built_in">Clear</span>();<br><br>    versions_-&gt;<span class="hljs-built_in">SetLastSequence</span>(last_sequence);<br>  &#125;<br><br>  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    Writer* ready = writers_.<span class="hljs-built_in">front</span>();<br>    writers_.<span class="hljs-built_in">pop_front</span>();<br>    <span class="hljs-keyword">if</span> (ready != &amp;w) &#123;<br>      ready-&gt;status = status;<br>      ready-&gt;done = <span class="hljs-literal">true</span>;<br>      ready-&gt;cv.<span class="hljs-built_in">Signal</span>();<br>    &#125;<br>    <span class="hljs-keyword">if</span> (ready == last_writer) <span class="hljs-keyword">break</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// Notify new head of write queue</span><br>  <span class="hljs-keyword">if</span> (!writers_.<span class="hljs-built_in">empty</span>()) &#123;<br>    writers_.<span class="hljs-built_in">front</span>()-&gt;cv.<span class="hljs-built_in">Signal</span>();<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> status;<br>&#125;<br></code></pre></td></tr></table></figure><p>这一段代码大致可以分为几个部分：</p><ul><li>第 8 到第 15 行获取锁，为写入获取权限。</li><li>第 18 行会检查当前活动的 MemTable 是否有足够的空间供写入，以及 Level-0 的文件是否需要进行合并。如果这些检查不通过，则会在后台进行一系列的操作，使得内存中有一个合适的 MemTable 供此次写入操作执行。</li><li>第 19 行到 53 行会进行包括 WAL 和实际数据的写入。第 41 行调用的 <code>WriteBatchInternal::InsertInto</code> 函数将数据插入到了 MemTable 中。</li><li>第 56 到 70 行将 writer 从 Writer 队列中清除。</li></ul><p>在这个函数中，LevelDB 对多个并发写进行了优化，它会将同一时间内的“小写入”合并为一个“大写入”来执行，减少日志文件的小写入次数，增加整体的写入性能。假设同时有 6 个写入请求并发产生：w1，w2，w3，w4，w5，w6 。</p><p><strong>【w1 的执行】</strong> 第 8 到第 15 行代码使得 w1 拿到了写锁，进入了 Writer 队列。此时队列中只有一个 w1 ，因此顺利地进行了 <code>BuildBatchGroup</code> 。到第 31 行时，w1 会释放锁。但是此时由于 w2 到 w6 并不在队列的头部，因此其一直被阻塞，不会影响 w1 的写入。当 w1 完成写入后，在 56 到 70 行中将自己清除出 Writer 队列，然后返回。</p><p><strong>【剩余请求的执行】</strong> 假设此时 Writer 队列中的顺序为：w3，w5，w2，w4，w6 ，那么 w3 就进入 <code>BuildBatchGroup</code> ，在这一函数中 w3 会遍历 Writer 队列，在 WriteBatch 的总大小不超过一定限制的情况下，将尽可能多的写请求合并到自身的 WriteBatch ，合并的过程使用的就是前面所描述的 WriteBatch 的编码规则来进行的。假设这里 w3 将除了 w6 的所有请求都合并了，last_writer 会被置为 w4 。在 56 到 65 行，w3 会将 w5、w2、w4 都唤醒，将它们和自身一起清除出 Writer 队列，最后唤醒位于队首的 w6 。w6 会和 w1 一样执行下去，而 w5、w2、w4 则会在 13 到 15 行直接返回。</p><h2 id="MemTable-插入"><a href="#MemTable-插入" class="headerlink" title="MemTable 插入"></a>MemTable 插入</h2><p>在前文中，我们忽略了位于 <code>WriteBatchInternal::InsertInto</code> 的插入过程。本节我们来看一看数据是如何插入 MemTable 中的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// write_batch.cc</span><br><span class="hljs-function">Status <span class="hljs-title">WriteBatchInternal::InsertInto</span><span class="hljs-params">(<span class="hljs-type">const</span> WriteBatch* b, MemTable* memtable)</span> </span>&#123;<br>  MemTableInserter inserter;<br>  inserter.sequence_ = WriteBatchInternal::<span class="hljs-built_in">Sequence</span>(b);<br>  inserter.mem_ = memtable;<br>  <span class="hljs-keyword">return</span> b-&gt;<span class="hljs-built_in">Iterate</span>(&amp;inserter);<br>&#125;<br><br><span class="hljs-function">Status <span class="hljs-title">WriteBatch::Iterate</span><span class="hljs-params">(Handler* handler)</span> <span class="hljs-type">const</span> </span>&#123;<br>  <span class="hljs-function">Slice <span class="hljs-title">input</span><span class="hljs-params">(rep_)</span></span>;<br>  <span class="hljs-keyword">if</span> (input.<span class="hljs-built_in">size</span>() &lt; kHeader) &#123;<br>    <span class="hljs-keyword">return</span> Status::<span class="hljs-built_in">Corruption</span>(<span class="hljs-string">&quot;malformed WriteBatch (too small)&quot;</span>);<br>  &#125;<br><br>  input.<span class="hljs-built_in">remove_prefix</span>(kHeader);<br>  Slice key, value;<br>  <span class="hljs-type">int</span> found = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">while</span> (!input.<span class="hljs-built_in">empty</span>()) &#123;<br>    found++;<br>    <span class="hljs-type">char</span> tag = input[<span class="hljs-number">0</span>];<br>    input.<span class="hljs-built_in">remove_prefix</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">switch</span> (tag) &#123;<br>      <span class="hljs-keyword">case</span> kTypeValue:<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">GetLengthPrefixedSlice</span>(&amp;input, &amp;key) &amp;&amp;<br>            <span class="hljs-built_in">GetLengthPrefixedSlice</span>(&amp;input, &amp;value)) &#123;<br>          handler-&gt;<span class="hljs-built_in">Put</span>(key, value);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-keyword">return</span> Status::<span class="hljs-built_in">Corruption</span>(<span class="hljs-string">&quot;bad WriteBatch Put&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> kTypeDeletion:<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">GetLengthPrefixedSlice</span>(&amp;input, &amp;key)) &#123;<br>          handler-&gt;<span class="hljs-built_in">Delete</span>(key);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-keyword">return</span> Status::<span class="hljs-built_in">Corruption</span>(<span class="hljs-string">&quot;bad WriteBatch Delete&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">default</span>:<br>        <span class="hljs-keyword">return</span> Status::<span class="hljs-built_in">Corruption</span>(<span class="hljs-string">&quot;unknown WriteBatch tag&quot;</span>);<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (found != WriteBatchInternal::<span class="hljs-built_in">Count</span>(<span class="hljs-keyword">this</span>)) &#123;<br>    <span class="hljs-keyword">return</span> Status::<span class="hljs-built_in">Corruption</span>(<span class="hljs-string">&quot;WriteBatch has wrong count&quot;</span>);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">return</span> Status::<span class="hljs-built_in">OK</span>();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>函数中会新建一个 <em>MemTableInserter</em>，设置好对应的参数后由 WriteBatch 的 <code>Iterate</code> 方法来执行对 MemTable 的插入。</p><p>在 <code>Iterate</code> 方法中，首先会将 WriteBatch 自身的 rep_ 包装为一个 Slice 。前面我们解释 Slice 结构时提到过，Slice 中只有一个以 char* 记录的数据内容和以 size_t 记录的数据大小。随后，系统将 rep_ 的数据头剪切掉，只剩下操作记录的部分。随后不断获取操作记录，如果是插入（Put），则获取其 key 和 value；如果是删除（Delete），则只需要获取其 key 。获取到记录后将其通过 Handler（即前面的 MemTableInserter）插入到 MemTable 中，并记录操作记录的数目。最后检查从 rep_ 中读出的操作数记录的数目是否与 rep_ 中记录的相同。</p><p>说到这里，还是没有讲到如何在 MemTable 中插入数据。以插入数据为例，MemTableInserter 的插入函数会调用 MemTable 的 <code>Add</code> 函数，该函数的细节如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// memtable.cc</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MemTable::Add</span><span class="hljs-params">(SequenceNumber s, ValueType type, <span class="hljs-type">const</span> Slice&amp; key,</span></span><br><span class="hljs-params"><span class="hljs-function">                   <span class="hljs-type">const</span> Slice&amp; value)</span> </span>&#123;<br>  <span class="hljs-comment">// Format of an entry is concatenation of:</span><br>  <span class="hljs-comment">//  key_size     : varint32 of internal_key.size()</span><br>  <span class="hljs-comment">//  key bytes    : char[internal_key.size()]</span><br>  <span class="hljs-comment">//  value_size   : varint32 of value.size()</span><br>  <span class="hljs-comment">//  value bytes  : char[value.size()]</span><br>  <span class="hljs-type">size_t</span> key_size = key.<span class="hljs-built_in">size</span>();<br>  <span class="hljs-type">size_t</span> val_size = value.<span class="hljs-built_in">size</span>();<br>  <span class="hljs-comment">// the internal key is 8 byte bigger than origin key</span><br>  <span class="hljs-type">size_t</span> internal_key_size = key_size + <span class="hljs-number">8</span>;<br>  <span class="hljs-comment">// get the total length of new encode format</span><br>  <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> encoded_len = <span class="hljs-built_in">VarintLength</span>(internal_key_size) +<br>                             internal_key_size + <span class="hljs-built_in">VarintLength</span>(val_size) +<br>                             val_size;<br>  <span class="hljs-comment">// allocate space for new encode data</span><br>  <span class="hljs-type">char</span>* buf = arena_.<span class="hljs-built_in">Allocate</span>(encoded_len);<br>  <span class="hljs-comment">// encode the internal key size to the buffer</span><br>  <span class="hljs-type">char</span>* p = <span class="hljs-built_in">EncodeVarint32</span>(buf, internal_key_size);<br>  <span class="hljs-comment">// encode the key value to the buffer</span><br>  std::<span class="hljs-built_in">memcpy</span>(p, key.<span class="hljs-built_in">data</span>(), key_size);<br>  p += key_size;<br>  <span class="hljs-comment">// encode the sequence number and operation type into buffer</span><br>  <span class="hljs-built_in">EncodeFixed64</span>(p, (s &lt;&lt; <span class="hljs-number">8</span>) | type);<br>  p += <span class="hljs-number">8</span>;<br>  <span class="hljs-comment">// encode the value size</span><br>  p = <span class="hljs-built_in">EncodeVarint32</span>(p, val_size);<br>  <span class="hljs-comment">// encode the value data</span><br>  std::<span class="hljs-built_in">memcpy</span>(p, value.<span class="hljs-built_in">data</span>(), val_size);<br>  <span class="hljs-built_in">assert</span>(p + val_size == buf + encoded_len);<br>  <span class="hljs-comment">// insert the encoded data to skip list</span><br>  <span class="hljs-comment">// skip list is the data structure which used by memtable to store data</span><br>  table_.<span class="hljs-built_in">Insert</span>(buf);<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个函数中，原本的 key 被重新编码为 internal_key，然后重新和 value 编码到 buffer 中。internal_key 在 key_len 和 key_data 的后面追加了 7 个字节的 seqence number 和一个字节的 operation type 。</p><img src="Leveldb-internal_key.png" width=65%><p>编码完成后，这个 buffer 会被插入到一个名为 SkipList 的数据结构中。SkipList 是 MemTable 内部用以存放数据的数据结构，其结构比较复杂，本文就不展开讲了，后面的文章会介绍这个 MemTable 的结构和实现。</p><p>至此，LevelDB 的写流程就介绍结束了。LevelDB 写流程主要有两个点值得我们注意：</p><ul><li>不同操作（写入、删除）在内存中的编码方式</li><li>对并发写的合并</li></ul><p>前者在用尽量少的空间优雅地编码了一个或多个操作记录，后者则巧妙地将多个并发写合并为了一个原子写，这两点非常值得我们反复品味。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://leveldb-handbook.readthedocs.io/zh/latest/">LevelDB Handbook</a></p><p><a href="https://blog.csdn.net/weixin_30871293/article/details/98269550">LevelDB 合并写详情</a></p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>源代码阅读</category>
      
      <category>LevelDB</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>操作系统（三）：进程间通信</title>
    <link href="/2021/03/23/OS-IPC/"/>
    <url>/2021/03/23/OS-IPC/</url>
    
    <content type="html"><![CDATA[<p>在现代操作系统中，使用多个进程来实现应用和系统是一种广泛使用的方法。<strong>进程间通信(Inter-Process Communication)</strong> 是多进程协作的基础。</p><p>一般来说，IPC 至少需要两个进程参与。根据信息流动的方向，这两方可以被称为<strong>发送者</strong>和<strong>接收者</strong>。在实际使用中，IPC 常被用于服务调用，因此参与 IPC 的双方又被称为<strong>调用者</strong>和<strong>被调用者</strong>，或者<strong>客户端</strong>和<strong>服务端</strong>。</p><p>为了有效地协同工作，进程间通信一般伴随着数据的传输。一种常用的通信数据的抽象是**消息(message)<strong>。消息一般包含一个</strong>头部(header)<strong>和一个</strong>数据段(payload)**。头部中通常含有魔数、消息长度、校验码等信息，而数据段中则既可以包含“纯”数据，也可以包含系统资源（如文件描述符等）。</p><p>下面，本文将简略地介绍 IPC 的相关内容。</p><h1 id="一个简单的-IPC-设计"><a href="#一个简单的-IPC-设计" class="headerlink" title="一个简单的 IPC 设计"></a>一个简单的 IPC 设计</h1><p>考虑一个简单的 IPC，内核将两个进程的一段虚拟地址映射到同一段物理地址上，即两个进程之间有一段共享内存。在通信时，发送者将要传输的数据内容拷贝到<strong>发送者消息</strong>上，然后依次设置头部中的状态（设置为“准备就绪”）等信息。接收者会不停地轮询发送者消息的状态，一旦观测到状态信息为“准备就绪”，就表示发送者发出了一个消息。发送者一发送完消息，就开始轮询<strong>接收者消息</strong>的状态，等待其变成“准备就绪”。接收者在读取到发送者的消息后，处理请求，并在接收者消息上准备返回结果。当发送者观测到接收者消息的状态为“准备就绪”后，即表示收到了返回的结果。</p><p>这样，我们就利用共享内存+轮询完成了一个简单的 IPC。但是这个 IPC 有许多缺点，例如：轮询时会浪费 CPU 资源、多个线程进行通信时共享内存较为不方便等。</p><h1 id="IPC-基础"><a href="#IPC-基础" class="headerlink" title="IPC 基础"></a>IPC 基础</h1><h2 id="数据传递"><a href="#数据传递" class="headerlink" title="数据传递"></a>数据传递</h2><p>从以上简单的 IPC 方案可以看出，IPC 的一个重要功能是在进程间传递数据。消息传递(message passing)是 IPC 中常用的数据传递方式：将数据抽象成一个个的消息进行传递。消息传递往往需要一个“中间人”（如共享内存、内核等）。消息传递的基本接口有以下四个：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">发送消息：<span class="hljs-constructor">Send(<span class="hljs-params">message</span>)</span><br>接收消息：<span class="hljs-constructor">Recv(<span class="hljs-params">message</span>)</span><br>远程过程调用：<span class="hljs-constructor">RPC(<span class="hljs-params">req_message</span>, <span class="hljs-params">recv_message</span>)</span><br>回复消息：<span class="hljs-constructor">Reply(<span class="hljs-params">resp_message</span>)</span><br></code></pre></td></tr></table></figure><p>发送消息和接收消息的语义比较直接，远程过程调用（Remote Procedure Call，RPC）可以理解为发送端调用 <code>Send</code> 接口后紧接着调用 <code>Recv</code> 接口。<code>Reply</code> 通常用于回复一个远程过程调用。</p><h3 id="基于共享内存的消息传递"><a href="#基于共享内存的消息传递" class="headerlink" title="基于共享内存的消息传递"></a>基于共享内存的消息传递</h3><p>在前面简单的 IPC 方案中，我们已经看到了进程是如何使用共享内存来进行通信的。这种方式的一个特点是：操作系统在通信过程中不干预数据传输。从操作系统的角度看，共享内存为两个（或多个）进程在其虚拟地址空间中映射了同一段物理内存，这些方案里操作系统通常不参与后续的通信过程。</p><h3 id="操作系统辅助的消息传递"><a href="#操作系统辅助的消息传递" class="headerlink" title="操作系统辅助的消息传递"></a>操作系统辅助的消息传递</h3><p>操作系统辅助的消息传递指内核对用户态提供通信的接口，如 <code>Send</code> 或 <code>Recv</code> 等。进程可以直接使用这些接口，将消息传递给另一个进程，而不需要建立共享内存和执行轮询内存数据等操作。</p><p>当两个进程 $P$ 和 $Q$ 通过内核接口进行 IPC 时，其需要</p><ol><li>通过特定的内核接口建立一个通信连接。这里的建立通信链接更多的是一个抽象的建立过程，具体的形式由内核决定，如内核可以通过维护一个数据结构来记录建立好连接的进程对。</li><li>通过 <code>Send</code> 和 <code>Recv</code> 接口传递消息。</li></ol><h3 id="共享内存和操作系统辅助传递的对比"><a href="#共享内存和操作系统辅助传递的对比" class="headerlink" title="共享内存和操作系统辅助传递的对比"></a>共享内存和操作系统辅助传递的对比</h3><p>从性能的角度来看，共享内存在传递消息时可以实现理论上的零内存拷贝传输。这里的内存拷贝，指的是将数据从内存的一片区域拷贝到内存中的另一片区域。而在操作系统辅助传递方式中，通常需要将数据从发送者的用户态内存拷贝到内核内存，然后将数据从内核内存拷贝到接收者的用户态内存，这个过程包含两次拷贝。</p><p>当然，操作系统辅助传递也有优点。第一，操作系统辅助传递的抽象更简单，内核可以保证每一次通信接口的调用都是一个消息被发送或接收，并且可以很好地支持变长消息，而共享内存则需要用户态软件来封装实现这一功能。第二，操作系统辅助传递的安全性更强，可以保证进程之间的隔离性。第三，在多方通信时，在多个进程之间共享内存是不安全的，而操作系统辅助传递则没有这个问题。</p><h2 id="控制流转移"><a href="#控制流转移" class="headerlink" title="控制流转移"></a>控制流转移</h2><p>对内核来说，实现消息传递机制除了要考虑数据的传输，往往还要附带<strong>控制流转移</strong>的功能：当一个通信发生时，内核将控制流从发送者进程切换到接收者进程（返回时类似）。在共享内存的方案中，如果没有控制流转移的功能，只能通过不断地轮询来检查是否有消息到来，而这可能会浪费大量 CPU 资源。</p><p>一个常见的流程如下：<br>首先，接收者进程完成初始化后将自己阻塞起来等待消息的到来（如执行阻塞的 <code>Recv</code>）。<br>之后，发送者进程发起通信（RPC）。在处理该操作时，内核首先将发送者的消息传递给接收者，然后令发送者进程进入阻塞状态，并将接收者进程从阻塞状态唤醒为预备状态。对接收者进程而言，会从阻塞的 <code>Recv</code> 函数中返回一个消息，表明收到了发送者的一个消息。<br>接收者完成处理，发送消息，然后自己进入阻塞状态。内核将数据传送到发送者进程，并将其唤醒。</p><p>结合内核中的调度以及对进程的调度状态的修改，控制流转移可以避免轮询操作，从而将消息高效地进行传递。</p><h2 id="单向通信与双向通信"><a href="#单向通信与双向通信" class="headerlink" title="单向通信与双向通信"></a>单向通信与双向通信</h2><p>IPC 通常包含三种可能的方向：仅支持单向通信、仅支持双向通信、单向和双向通信均可。</p><p>通常来说，单向通信其实是系统软件实现 IPC 的一个基本单元，双向通信时可以基于单向 IPC 来搭建的。在接口上，如果通信建立后，通信的双方分别只能使用 <code>Send</code> 和 <code>Recv</code> 接口，那么这通常对应于单向通信。实际中，很多系统选择的是单向和双向皆可的策略，这样可以比较好地支持各种场景。当然，如管道、信号等只支持单向通信的机制在实际中同样有较多应用。</p><h2 id="同步与异步-IPC"><a href="#同步与异步-IPC" class="headerlink" title="同步与异步 IPC"></a>同步与异步 IPC</h2><p>IPC 的另一种分类是：同步 IPC 和异步 IPC。简单来说，同步 IPC 在操作时会阻塞进程直到该操作完成；而异步 IPC 则通常是非阻塞的，进程只需要发起一次操作即可返回，而不需要等待其完成。异步 IPC 通常通过轮询内存状态或注册回调函数（如果内核支持）来获取返回结果。</p><p>同步 IPC 往往是双向 IPC（或 RPC），即发送者需要等待返回的结果。不过也存在单向 IPC 是同步的，这种情况下发送者虽然不会等待接收者返回结果，但是其会等待接收者接收消息。</p><p>在早期的微内核系统中，同步 IPC 往往是唯一的 IPC 方式。这是因为相比异步 IPC，同步 IPC 有更好的编程抽象。例如使用同步 RPC 时，调用者可以将进程间通信看作是一种函数调用，调用返回时也意味着结果返回了。但是同步 IPC 在操作系统发展的过程中，逐渐表现出一些不足。一个典型的问题是并发。当一个服务进程要响应很多客户进程的通信时，在同步 IPC 的实现下为了服务进程往往需要创建大量工作线程去响应不同的客户进程，否则可能出现客户进程阻塞的现象。但是这里也有一个问题，过多的工作线程会浪费系统资源。而使用异步 IPC 则可以在并发通信时避免这些问题。总的来看，目前大部分操作系统都会选择同时实现同步和异步的 IPC，以满足不同的应用需求。</p><h2 id="超时机制"><a href="#超时机制" class="headerlink" title="超时机制"></a>超时机制</h2><p>由于进程间有隔离性，因此有一个问题时：通信的双方很难确认对方的状态。例如在同步 IPC 中，当控制流从调用者传递到被调用者后，如果被调用者恶意地不返回到调用者，那么就会使得调用者无法继续执行。异步 IPC 也有类似的问题。即使控制流不会被被调用者恶意地抢占，调用者仍然有可能花费很长时间等待一个请求的处理，例如当被调用者十分忙碌时。</p><p>为了解决这个问题，IPC 的设计中引入了<strong>超时机制</strong>。超时机制扩展了 IPC 通信双方的接口，允许发送者&#x2F;接收者指定它们发送&#x2F;接收请求的等待时间。例如，一个用户进程可以花费 5 秒等待文件系统进程的 IPC 请求处理操作。如果超过这个时间仍没有反馈，则由操作系统内核结束这次 IPC 调用，返回一个超时错误。超时机制允许进程为一次通信的等待时间设置一个上限，从而避免类似<strong>拒绝服务</strong>的攻击情况出现。</p><p>但是在实际中，大部分进程难以决定一个合理的超时。例如前面等待文件系统进程的 5 秒，当处理的数据量非常大时，5 秒可能不够文件系统进程处理请求。一个过短的超时显然不行，但是一个过长的超时又容易使得调用者无法察觉被调用者的异常。因此，内核常引入两个特殊的超时选择：“永不返回”和“立即返回”。“永不返回”和引入超时机制之前的状态类似；而“立即返回”则是说只有当前被调用者处于可以立即响应的状态才会真的发起通信，否则就直接返回。更注重安全性时应该选择“立即返回”，更注重功能性时则应选择“永不返回”，这由发送者决定。</p><h2 id="直接通信与间接通信"><a href="#直接通信与间接通信" class="headerlink" title="直接通信与间接通信"></a>直接通信与间接通信</h2><p>在建立一个连接时，虽然不同的系统有不同的实现，但是通常可以分成两类：<strong>直接通信</strong>和<strong>间接通信</strong>。在直接通信中，通信的进程一方需要显式地标识另一方。例如，<code>Send(P,message)</code> 代表向 $P$ 进程发送一则消息；<code>Recv(Q, message)</code> 代表从 $Q$ 进程接收一则消息。直接通信下连接的建立是自动的，在具体交互时通过标识的名称完成。这就意味着，一个连接会唯一地对应一对进程。连接本身可以是单向的，也可以是双向的。</p><p>在间接通信中，消息传递通过一个中间的信箱来完成。每个信箱有其唯一的标识符，而进程间通过同一个信箱来交换消息。也就是说，进程间连接的建立发生在共享一个信箱时。而每对进程可以通过共享多个信箱来建立多个连接。连接同样可以时单向的或双向的。</p><h2 id="权限检查"><a href="#权限检查" class="headerlink" title="权限检查"></a>权限检查</h2><p>进程间的通信通常依赖于一套权限检查的机制来保证连接的安全性。在如 Linux 这样的宏内核系统中，通常将安全检查机制和文件的权限检查机制结合在一起。一个进程和其他进程通信，必须要通过权限的检查。例如，seL4 等微内核系统中的 Capability 机制，会将所有的通信连接抽象成一个个的内核对象。而每个进程对内核对象的访问权限由 Capability 来刻画。在宏内核系统中，如 Linux 中，通常会复用其有效用户&#x2F;有效组的文件权限，以刻画进程对某个连接的权限。</p><h2 id="命名服务"><a href="#命名服务" class="headerlink" title="命名服务"></a>命名服务</h2><p>权限检查机制带来了安全性，但是权限如何分发呢？通常，权限的分发会通过一个用户态的服务——**命名服务(naming server)**来处理。命名服务进程则指代提供该服务的具体进程。</p><p>命名服务就像一个全局看板，可以协调服务端进程和客户端进程之间的通信。简单来说，服务端进程可以将自己提供的服务告诉命名服务进程，例如文件系统进程可以注册一个“文件系统服务”。客户端进程可以去命名服务上查询当前服务，并选择自己希望建立连接的服务去尝试获取权限。具体是否分发权限给对应的客户端进程，是由命名服务和对应的服务端进程根据特定的策略来判断的，例如文件系统进程可能允许任意线程进行连接，一个数据库进程则可能需要客户端提供私钥签名的证书。使用命名服务有很多的好处，比如各个服务不再是内核中的 ID 等抽象的表示，而是对应用更加友好的“名字”。</p><h1 id="宏内核系统中的-IPC"><a href="#宏内核系统中的-IPC" class="headerlink" title="宏内核系统中的 IPC"></a>宏内核系统中的 IPC</h1><p>一般来说，宏内核系统中 IPC 的方式主要有：管道、消息队列、信号量、共享内存、信号、套接字。</p><h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><p><strong>管道（pipe）</strong>是宏内核场景下重要的进程间通信机制。正如其名，管道是两个进程间的一条通道，一端负责投递，一端负责接收。例如，我们执行 Linux 下的 shell 命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ps aux | grep target<br></code></pre></td></tr></table></figure><p>来查看是否含有关键字为 target 的进程在运行。这里其实有两个命令：ps 和 grep，通过 shell 的管道接口 |，将第一个命令的输出投递到一个管道中，而这条管道的出口则是第二个命令的输入。</p><p>管道是单向的 IPC，内核中通常有一定的缓冲区来缓冲消息，而通信的数据（消息抽象）是字节流，需要应用自己去对数据进行解析。</p><p>具体实现上，管道在 UNIX 系列的系统中会被当作一个文件。内核会为用户态提供代表管道的文件描述符，让其可以通过文件系统相关的系统调用来使用。管道的行为和 FIFO 队列非常像，最早传入的数据会被最先读出来。</p><p>当一个进程尝试在输出端对一个空管道进行读取时，会有两种情况：如果系统发现还没有任何进程有这个管道的写端口，就会得到 EOF（End-of-File）；否则，进程会阻塞在这个系统调用上，直到数据到来。第一种情况发生的可能是，管道的两个端口在 UNIX 系列系统的内核中以两个独立的文件描述符存在的，写端口有可能被进程给主动关闭了。对于第二种情况，进程可以通过配置非阻塞来避免阻塞。</p><h3 id="命名管道和匿名管道"><a href="#命名管道和匿名管道" class="headerlink" title="命名管道和匿名管道"></a>命名管道和匿名管道</h3><p>在经典的 UNIX 实现中，管道有两类：命名管道和匿名管道。主要区别在于它们的创建方式。匿名管道通过 <code>pipe</code> 的系统调用创建，在创建的同时进程会拿到读写的端口（两个文件描述符）。由于整个管道没有全局的“名字”，因此只能通过这两个文件描述符来使用它。这种情况下，通常结合 <code>fork</code> 的使用，即继承的方式来建立父子进程间的连接。例如，父进程创建好了一个管道，然后使用 <code>fork</code> 创建子进程。子进程会有用父进程的系统资源，也就有了该管道的读写端口，因此可以和父进程通过该管道进行通信。这种方式对于父子进程等有着创建关系的进程间通信比较方便，但是对于两个关系较远的进程就不太适用。</p><p>命名管道通过 <code>mkfifo</code> 来创建，在创建时会指定一个全局的文件名，由这个文件名（例如 &#x2F;tmp&#x2F;namedpipe）来指代一个具体的管道。通过这种方式，只要两个进程通过一个相同的管道名进行创建（并且都拥有权限），就可以实现在任意两个进程间建立管道的通信连接。</p><h2 id="System-V-消息队列"><a href="#System-V-消息队列" class="headerlink" title="System V 消息队列"></a>System V 消息队列</h2><p>相比于本文介绍的其他宏内核通信机制，  消息队列是唯一一个以消息为数据抽象的通信机制。应用可以通过消息队列来发送或接收消息，发送和接收的接口是由内核提供的。消息队列是一种非常灵活的通信方式，可以有多个发送者和多个接收者。并且在 Linux 中，消息队列中的每个消息都有其类型抽象，使得发送者和接受者可以根据消息的类型来选择性地处理消息。</p><h3 id="消息队列的结构"><a href="#消息队列的结构" class="headerlink" title="消息队列的结构"></a>消息队列的结构</h3><p>消息队列在 Linux 内核中的实现形式是消息链表。当创建新的消息队列时，操作系统将在内核中新建一个消息链表，作为消息队列的内核对象。队列的消息有一个消息头部指针，即链表中的头结点，它指向队列中的第一个消息（或者为空）。每个消息都会有指向下一个消息的指针（或者为空）。</p><p>在消息结构体中，除了指针外，就是消息的内容。消息的内容有两个部分：类型和数据。数据是一段内存数据，和管道中的字节流类似。类型是用户态程序为每个消息指定的。在消息队列的设计中，内核不需要知道类型的语义，仅仅是保存，以及基于类型进行简单的查找。</p><h3 id="消息队列的基本操作"><a href="#消息队列的基本操作" class="headerlink" title="消息队列的基本操作"></a>消息队列的基本操作</h3><p>消息队列一般有四个基本操作：<code>msgget</code>、<code>msgsnd</code>、<code>msgrcv</code>、<code>msgctl</code>，这四个操作在 Linux 上被实现为系统调用。</p><p><code>msgget</code> 允许进程获取已有的消息队列的连接，或者创建一个新的消息队列。只要有对应的权限，消息队列允许任意数量的进程连接到同一通信连接上（即同一队列上）。<br><code>msgctl</code> 可以控制和管理一个消息队列，如修改消息队列的权限信息或删除消息队列。<br><code>msgsnd</code> 可以往消息队列上发送消息，<code>msgrcv</code> 可以从消息队列上接收消息。多个进程可以同时往消息队列上发送和从消息队列上接收消息。大部分情况下这两个过程是非阻塞的：对发送者来说，只要队列有空闲的空间就可以向其发送消息；对接收者来说，只要队列中有未读消息就可以从队列中读取消息。如果发送消息时队列中没有空间或者读取消息时队列中没有消息可以读，默认的操作是阻塞进程，直到有空间腾出或者有新的消息到达。</p><h3 id="Linux-中的消息队列"><a href="#Linux-中的消息队列" class="headerlink" title="Linux 中的消息队列"></a>Linux 中的消息队列</h3><p>在 Linux 中，一个消息队列如果被创建，除非显式地将其删除，否则其生命周期是和内核一致的。其次，消息队列的内存空间是有限制的，因此消息队列并不适合传递长消息，一般建议用共享内存来传递长消息。最后，消息在用户态和内核态之间传递，会有内存拷贝的开销。</p><h2 id="System-V-信号量"><a href="#System-V-信号量" class="headerlink" title="System V 信号量"></a>System V 信号量</h2><p>和其他 IPC 机制传递数据的方案不同，信号量在实际的使用中主要是用作进程间的“同步”。有些场景下，多个进程需要依赖于进程间通信来同步彼此的状态，如执行的顺序等。信号量本身能传递的数据量很少，一般来说仅有一个共享的整形计数器，该计数器通常由内核维护，而对信号量的操作则需要经过内核系统调用。</p><p>信号量的主要操作有两个原语：P 和 V。P 是荷兰语 Probeer（尝试）的缩写，表示尝试一个操作（在信号量中通常是将一个计数器减 1），该操作的失败会将该进程切换到阻塞状态，直到其他进程执行了 V 操作。<br>V 是荷兰语 Verhoog（增加）的缩写，在信号量中是将一个计数器加 1。V 可能会唤醒一个因 P 操作而陷入阻塞的进程。P 和 V 的操作都是在信号量结构上进行的，该结构会封装一个计数器。</p><p>信号量的一个简单的使用是将其值的范围限定在 0 到 1 之间。但执行 P 原语时，会将计数器减 1；当执行 V 原语时，会将计数器加 1。如果计数器被 P 原语减为负数，则会阻塞该进程，直到其他进程使用 V 原语将计数器修改成非负数时，则会唤醒该进程。</p><p>信号量一种用途是同步进程之间的操作。例如将一个信号量限定在 0 到 1 之间，初始值为 0。进程 A 在执行之前调用 P 原语，此时信号量的计数器减去 1，变成 -1，进程 A 被阻塞。进程 B 在执行结束后使用 V 原语，将信号量的计数器增加为 0，此时进程 A 被唤醒。这样，我们就使用一个信号量，保证进程 A 和 B 的执行顺序为先 B 后 A。</p><p>信号量的另一种典型用途是控制共享资源的访问，此时 P 原语和 V 原语必须成对出现，在获取资源时调用 P 原语，在释放资源时调用 V 原语。例如，某个资源对应的信号量范围在 0 到 1 之间，初始值为 1。进程 A 先访问该资源，调用 P 原语，将信号量的计数器修改为 0，成功获取资源并执行。进程 B 随后访问该资源，调用 P 原语，信号量的计数器修改为 -1，此时进程 B 被阻塞。过后一段时间，进程 A 释放资源，调用 V 原语，将进程 B 唤醒，进程 B 此时获取了资源并开始执行。进程 B 执行完成后，调用 V 原语释放资源，此时信号量的计数器恢复为 1。</p><h2 id="System-V-共享内存"><a href="#System-V-共享内存" class="headerlink" title="System V 共享内存"></a>System V 共享内存</h2><p>对于消息队列、管道、信号量等机制，内核都提供了完整的接口。虽然这些完善的抽象方便了用户进程的使用，但是其中涉及的数据拷贝和控制流转移等处理逻辑影响了这些抽象的性能。共享内存将两个（或多个）进程中的一片虚拟地址空间映射到同一片物理地址空间上，当映射建立完成后，内核就不再参与进程间的通信。这样，在通信时就不存在将数据从用户态内存拷贝到内核态内存的过程，也就增强了 IPC 的性能。因此，共享内存适用于需要传递长消息的场景。</p><h2 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h2><p>管道、消息队列、共享内存等方式主要关注数据传输的设计，而<strong>信号(signal)<strong>的一个特点是</strong>单向的事件通知</strong>。信号量也有通知能力，但是需要进程主动查询计数器或者陷入阻塞状态等待通知。使用信号，一个进程可以随时发送一个事件到特定的进程、线程或进程组等。接收事件的进程不需要阻塞等待该事件，内核会帮助其切换到对应的处理函数中响应信号事件，并且在处理完成后恢复之前的上下文。</p><p>信号传递的信息很短，只有一个编号（信号类型）。例如我们在 Shell 中使用 Ctrl + C 中止一个运行中的进程，就是 Shell 发出了一个 <code>SIGINT</code> 信号，使得进程中止。</p><p>在通信的场景下，一个进程会为一些特定的信号注册处理函数。当进程接收到对应的信号时，内核会自动地将用户的控制流切换到对应的处理函数中。</p><p>在 Linux 中，其早期有 31 个信号（1 ~ 31 号），后续 POSIX 标准又引入了编号从 32 到 64 的其他信号。Linux 传统信号被称为常规信号，POSIX 引入的信号称为实时信号。一个进程如果多次收到某个常规信号，内核只会记录一次，而多个相同的实时信号则不会被丢弃。</p><h3 id="发送信号"><a href="#发送信号" class="headerlink" title="发送信号"></a>发送信号</h3><p>信号的发送者可以是用户态进程，也可以是内核。一个用户态进程可以通过调用内核提供的系统接口，如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">kill(<span class="hljs-type">pid_t</span> pid, <span class="hljs-type">int</span> sig)<br>tgkill(<span class="hljs-type">int</span> tgid, <span class="hljs-type">int</span> tid, <span class="hljs-type">int</span> sig)<br></code></pre></td></tr></table></figure><p>向进程或线程发送特定的信号。内核通过不同的系统调用及其参数，来确定接收信号的目标进程或线程，将信号事件添加到其等待队列上。添加操作需要区别实时信号和常规信号，当发送的信号是非实时的信号，并且现在还未处理该信号时，内核会忽略掉这个事件。</p><h3 id="处理信号"><a href="#处理信号" class="headerlink" title="处理信号"></a>处理信号</h3><p>Linux 提供了一个 <code>sigprocmask</code> 系统调用，允许用户设置队特定信号的阻塞状态。当一个信号被阻塞后，Linux 将不会再触发这个信号的响应函数，直到该信号被解除阻塞。信号被阻塞并不会影响其被添加到等待队列上，当进程解除了对这个信号的阻塞时，其可能需要处理在阻塞期间收到的信号。很多重要的信号是不能被阻塞的，例如 SIGKILL。</p><p>在 Linux 等 UNIX 系统的设计中，信号得到处理的时机通常是内核执行完异常、中断或系统调用等返回到用户态的时刻，此时内核会检查一个状态位来判断是否有信号需要处理。如果有，则先去处理该信号事件。Linux 提供了 <code>signal</code>、<code>sigaction</code> 等系统调用，允许用户为特定的信号注册一个用户态响应函数。</p><h3 id="可重入处理函数"><a href="#可重入处理函数" class="headerlink" title="可重入处理函数"></a>可重入处理函数</h3><p>在信号处理函数执行的过程中，如果其他进程又发送了一个该信号事件过来，并且当前进程由于中断等下陷到内核，那么当前进程可能会暂停当前信号处理函数的执行，并且重新切换到处理函数的开头去处理新的信号事件，然后再回到原来的地方继续执行原本的信号响应函数。这种嵌套需要信号处理函数是<strong>可重入</strong>的。简单来说，就是在信号处理的过程中，有可能会产生并发，并且调用的函数就是信号处理函数本身。假如此时在信号处理函数中使用了全局锁保护一段关键操作时，就有可能导致死锁：信号处理函数在第一次被调用时获得了全局锁，在进行到一半时又被从头执行，此时原本的信号处理函数没有释放获得的锁，因而新的处理函数无法获取全局锁，进而造成死锁的局面。</p><p><strong>可重入（reentrant）</strong>函数允许多个任务并发使用，而不用担心共享数据的错误。一般来说，实现一个可重入函数有以下几个要求：</p><ul><li>不使用静态数据，或者静态数据都是只读的。</li><li>尽量只使用本地数据。</li><li>在必须使用全局共享数据的情况下，需要保护对全局数据的访问（也需要避免死锁）。</li><li>避免在函数中修改自己的代码。</li><li>不调用不可重入的函数，很多库函数的实现（例如 <code>malloc</code>）是不可重入的，需要注意。</li></ul><h2 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h2><p>**套接字(Socket)**是一种既可用于本地，又可跨网络使用的通信机制。因此应用程序可以使用 Socket 来实现本地进程间的通信和跨机器的通信。在进行本地通信时，通信双方通常使用本地回环地址（127.0.0.1），然后各自绑定在不同的端口上。操作系统网络协议栈会识别回环地址，将通信消息转发到目标端口对应的进程。此外，也可以用本地文件系统的一个路径作为地址，这通常被叫做 UNIX domain socket。使用套接字通常有两种协议，TCP 和 UDP。TCP 传输可以保证数据的正确性，UDP 则在传输性能上更佳。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://book.douban.com/subject/35208251/">《现代操作系统：原理与实现》</a>，陈海波，夏虞斌等著，机械工业出版社</p>]]></content>
    
    
    <categories>
      
      <category>计算机科学</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>操作系统（二）：进程与线程</title>
    <link href="/2021/03/12/OS-process-and-thread/"/>
    <url>/2021/03/12/OS-process-and-thread/</url>
    
    <content type="html"><![CDATA[<h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><p>为了管理操作系统中各种各样的程序，操作系统定义了进程（Process）的抽象：每个进程都对应于一个运行中的程序。为了使得多个进程可以同时执行，操作系统提出了上下文切换机制，通过保存和恢复进程在运行过程中的状态（即上下文），使进程可以暂停、切换、恢复，从而实现了 CPU 资源的共享。同时，使用虚拟内存机制，为每个进程都提供了独立的虚拟地址空间。</p><h2 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h2><p>为了对进程进行管理，首先需要定义进程的状态。一般来说，进程有以下几种状态。</p><ul><li><strong>新生状态</strong>：此时进程刚刚被创建出来，尚未完成初始化，不可以被调度。当完成初始化后，迁移至预备状态。</li><li><strong>预备状态</strong>：此时进程可以被调度，但是还没有被调度器选择。当被调度器选择时，迁移至运行状态。</li><li><strong>运行状态</strong>：此时进程正在 CPU 上运行。当调度器中断其执行并将其放回调度队列中时，其迁移至预备状态；当其运行结束时，迁移至终止状态；当其需要等待外部事件时，迁移至阻塞状态。</li><li><strong>阻塞状态</strong>：此时进程需要等待外部事件（例如某个 I&#x2F;O 请求的完成），暂时无法被调度。</li><li><strong>终止状态</strong>：此时进程已经完成了执行，不会再被调度。</li></ul><h2 id="进程的内存空间布局"><a href="#进程的内存空间布局" class="headerlink" title="进程的内存空间布局"></a>进程的内存空间布局</h2><p>如图所示，进程拥有独立的虚拟内存空间。</p><img src="进程内存布局.png" width="20%"><ul><li><strong>用户栈</strong>：用户栈保留了进程需要的各种临时数据，其扩展方向是自顶向下，栈底在高地址，栈顶在低地址。当有数据压入栈时，栈顶向低地址扩展。</li><li><strong>代码库</strong>：进程执行需要的共享代码库（比如 libc），其被标记为只读。</li><li><strong>用户堆</strong>：堆管理的时动态分配的内存，和栈相反，其扩展方向是自底向上。</li><li><strong>数据与代码段</strong>：数据段主要保存的是全局变量的值，代码段保存的是进程执行所需的代码。</li><li><strong>内核部分</strong>：每个进程的虚拟地址空间里都映射了相同的内核内存。当进程在用户态时，内核内存对其不可见；只有进程进入内核态时，才能访问内核内存。</li></ul><p>在 Linux 中，可以使用 <code>cat /proc/PID/maps</code> 来查看某个进程的内存布局。</p><h2 id="进程控制块"><a href="#进程控制块" class="headerlink" title="进程控制块"></a>进程控制块</h2><p>在内核中，每个进程都通过一个数据结构来描述其状态，这个数据结构成为进程控制块（Process Control Block，PCB）。在不同的操作系统中，PCB 所包含的内容也不一样。在 Linux 4.14 中 PCB 对应的数据结构 task_struct 所包含的部分内容如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> &#123;</span><br>  <span class="hljs-comment">// 进程状态</span><br>  <span class="hljs-keyword">volatile</span> <span class="hljs-type">long</span> state;<br>  <span class="hljs-comment">// 虚拟内存状态</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mm_struct</span> *<span class="hljs-title">mm</span>;</span><br>  <span class="hljs-comment">// 进程标识符</span><br>  <span class="hljs-type">pid_t</span> pid;<br>  <span class="hljs-comment">// 进程组标识符</span><br>  <span class="hljs-type">pid_t</span> tgid;<br>  <span class="hljs-comment">// 进程间关系</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> __<span class="hljs-title">rcu</span> *<span class="hljs-title">parent</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">children</span>;</span><br>  <span class="hljs-comment">// 打开的文件</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">files_struct</span> *<span class="hljs-title">files</span>;</span><br>  <span class="hljs-comment">// 其他状态（如上下文）</span><br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><p>进程的上下文（context）包括进程运行时的寄存器状态，其能够用于保存和恢复一个进程在处理器上的运行状态。当操作系统需要切换当前执行的进程时，就会使用上下文切换机制（context switch）。</p><h2 id="Linux-中的进程"><a href="#Linux-中的进程" class="headerlink" title="Linux 中的进程"></a>Linux 中的进程</h2><h3 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h3><p>在 Linux 中进程的创建一般使用 fork 接口，从已有的进程中“分裂”出来。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">pid_t</span> <span class="hljs-title function_">fork</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br></code></pre></td></tr></table></figure><p>fork 接口非常简单，不接收任何参数，返回的时当前进程的 PID。当一个进程调用 fork 时，操作系统会创建一个和该进程几乎一模一样的新进程。当 fork 刚刚完成时，两个进程的内存、寄存器、程序计数器等状态完全一致，但是这两个线程相互独立，拥有独立的虚拟内存空间和不同的 PID。在 fork 结束以后他们会独立执行，互不干扰。</p><p>在调用 fork 之后父子进程之间存在大量的共享，因此会造成很多不确定的行为。例如，假如父进程在 fork 之前打开了一个文件，fork 结束以后，这两个进程都会持有这个文件的文件描述符（File Descriptor）。文件描述符是操作系统提供的对于某一文件引用的抽象，会记录关于文件的一些信息，例如当前位置的偏移量。因此，假如这两个父子进程同时操作该文件，有可能会导致冲突。</p><p>除了简单的 fork 接口，Linux 中还有 clone 接口，其拓展了 fork。关于 fork 和 clone 的详细使用方法，可以参考<a href="https://blog.csdn.net/gatieme/article/details/51417488">Linux中fork，vfork和clone详解（区别与联系）</a>。</p><h3 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h3><h4 id="进程树"><a href="#进程树" class="headerlink" title="进程树"></a>进程树</h4><p>在 Linux 中，由于进程都是通过 fork 创建的，操作系统会以 fork 作为线索记录进程之间的关系。每个进程的 task_struct 都会记录自己的父进程与子进程，进程之间因此形成了进程树的结构。</p><img src="进程树.png" width="55%"><p>处于进程树根节点的是 init 进程，它是操作系统创建的第一个进程，之后所有的进程都是由它直接或间接 fork 出来的。</p><h4 id="进程间监控：wait"><a href="#进程间监控：wait" class="headerlink" title="进程间监控：wait"></a>进程间监控：wait</h4><p>在 Linux 中，进程可以使用 wait 操作来对其子进程进行监控。其由多个变种，这里介绍 <code>waitpid</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">pid_t</span> <span class="hljs-title function_">waitpid</span><span class="hljs-params">(<span class="hljs-type">pid_t</span> pid, <span class="hljs-type">int</span> *wstatus, <span class="hljs-type">int</span> options)</span>;<br></code></pre></td></tr></table></figure><p>其中第一个参数是需要等待的子进程 id，第二个参数会用来保存子进程状态，最后一个参数包含一些选项。父进程调用 <code>waitpid</code> 对子进程进行监控，如果子进程已经退出，那么 waitpid 会立即返回，并设置 status 变量的值；如果子进程还没有退出，则父进程会被阻塞，并等待子进程退出。</p><p>在 Linux 中，wait 操作不仅起到了监控的作用，还起到了回收已经结束的子进程和释放资源的作用。如果父进程没有调用 wait 操作，就算子进程已经终止了，它所占用的资源也不会完全释放，我们将这种进程成为<strong>僵尸进程</strong>。内核会为僵尸进程保留其进程描述符（PID）和终止时的信息（waitpid 中的 status），以便父进程在调用 wait 时可以监控子进程的状态。不过，如果父进程退出了，那么子进程的信息就不会再被父进程使用，也就没有必要继续保留它们了。此时，所有由父进程创建的僵尸进程都会被内核的第一个进程 init 通过调用 wait 的方式回收。</p><p>如果一个父进程调用了一个或若干个子进程，但是父进程在子进程结束之前就已经结束了，那么这些子进程就被成为<strong>孤儿进程</strong>，这些进程会被 init 进程收养。</p><h4 id="进程组和会话"><a href="#进程组和会话" class="headerlink" title="进程组和会话"></a>进程组和会话</h4><p>为了方便对进程进行管理，内核还定义了进程组和会话的概念。会话和进程组主要用于 Shell 环境中的进程管理。</p><p>进程组是进程的集合，可以由一个或多个进程组成。在默认的情况下，父进程和子进程属于同一个进程组。如果子进程想要脱离当前进程组，可以通过 <code>setpgid</code> 创建一个新的进程组或者移入一个已有的进程组。进程组的一大作用是体现在对信号的处理上，应用程序可以调用 <code>killpg</code> 向一个进程组发送信号，这个信号会被发给该进程组的所有进程。</p><p>会话是进程组的集合，可以由一个或多个进程组组成。会话将进程组根据执行状态分为前台进程组和后台进程组。</p><h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><p>在早期的操作系统中，进程是调度的最小单元。随着程序并行性的提高，操作系统需要对程序进行更加细粒度的调度，于是就产生了线程（thread）的概念。同一进程下的所有线程共享进程的地址空间，但又各自保留运行时所需的状态（上下文）。在现代操作系统中，线程取代了进程，成为了操作系统调度的最小单位。</p><h2 id="线程内存布局"><a href="#线程内存布局" class="headerlink" title="线程内存布局"></a>线程内存布局</h2><img src="多线程内存布局.png" width="20%"><p>上图是包含三个线程的进程地址空间，其有两个重要特征：</p><ul><li><strong>分离的内核栈和用户栈</strong>：进程为每个线程都准备了不同的栈，供它们存放临时数据。在内核中，每个线程也有对应的内核栈。</li><li><strong>共享的其他区域</strong>：除了栈，进程中的所有其他区域都由该进程的所有线程共享，包括堆、数据段、代码段等。</li></ul><h2 id="用户态线程和内核线程"><a href="#用户态线程和内核线程" class="headerlink" title="用户态线程和内核线程"></a>用户态线程和内核线程</h2><p>根据线程是由用户应用创建还是内核创建，可以将其分为两类：用户态线程和内核态线程。内核态线程由内核创建，受操作系统调度器管理。用户态线程则是应用创建的，内核不可见，不受操作系统调度器管理。用户态线程中与内核相关的功能（如系统调用）需要内核线程协助才能完成。为了使用户态线程与内核态线程相互协作，操作系统会建立两者之间的关系。一般来说，主要由三种模型：多对一、一对一和多对多。</p><ul><li><strong>多对一</strong>：该模型中一个内核线程服务多个用户态线程，每次只能有一个用户态线程进入内核，其他需要内核服务的线程将被阻塞。随着多核机器的普及，这种模型已不再使用。</li><li><strong>一对一</strong>：该模型中每个用户态线程都有单独的内核态线程，其比一对一模型具有更好的拓展性。这种模型的缺点是，随着用户态线程的增多，创建内核态线程的开销会随之增大。因此，在实现该模型的操作系统中，都会限制用户态线程的总数量。Linux 和 Windows 使用的都是这种模型。</li><li><strong>多对多</strong>：多对多模型将 $N$ 个用户态线程映射到 $M$ 个内核态线程上，其中 $N&gt;M$。这种模型既减轻了多对一模型中因为内核线程数量过少而导致的阻塞问题，也解决了一对一模型中因为内核态线程过多而导致的性能问题。但是这种模型会使得内核态线程的管理变得复杂。macOS 和 iOS 使用的面向用户体验的调度器 GCD 采用了这一种模型。</li></ul><h2 id="线程接口"><a href="#线程接口" class="headerlink" title="线程接口"></a>线程接口</h2><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>在 POSIX 线程库中，使用 <code>pthread_create</code> 函数来创建线程。 其接受四个参数，分别是线程的引用、线程的属性、线程开始运行的函数、线程运行的参数。</p><h3 id="退出"><a href="#退出" class="headerlink" title="退出"></a>退出</h3><p>在 POSIX 线程库中，使用 <code>pthread_exit</code> 函数来退出线程。但是这个调用并不是必要的，当线程运行结束后，<code>pthread_exit</code> 会被隐式地调用。</p><h3 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h3><p>在多线程场景中，有可能会出现几个线程之间相互依赖的情况。因此，线程库中提供了合并（join）操作的函数 <code>pthread_join</code>，其允许一个线程等待另一个线程的执行，并获取其执行的结果。</p><h3 id="挂起"><a href="#挂起" class="headerlink" title="挂起"></a>挂起</h3><p>pthread 中没有专门挂起的函数，此时可以使用 <code>sleep</code> 函数完成挂起操作。调用该函数后，该线程会处于阻塞状态，等到睡眠结束后将转为预备状态，但是此时并不一定会被调度器选择，因此在睡眠结束之后并不一定会立即被执行。<br>还有一种挂起是等待某种事件，线程在挂起之前指明等待的具体时间。在 pthreads 中，对应的接口是 <code>pthread_cond_wait</code>。</p><h1 id="纤程"><a href="#纤程" class="headerlink" title="纤程"></a>纤程</h1><p>由于主流的操作系统都使用一对一的线程模型，用户态线程和内核态线程具有一对一的关系，因此可以认为用户态线程的执行几乎完全收到操作系统调度器的管理。<br>但是，随着程序越来越复杂，应用的设计者可能更能优化调度的性能。因此，操作系统开始提供更多对用户态线程，即<strong>纤程</strong>的支持。因为纤程不是操作系统调度的单位，纤程的调度和切换不需要通过操作系统。更多关于纤程的介绍，可以参考<a href="https://en.wikipedia.org/wiki/Fiber_(computer_science)">Wikipedia</a></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>《现代操作系统：原理与实现》第 5 章，陈海波，夏虞斌等著</p>]]></content>
    
    
    <categories>
      
      <category>计算机科学</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>操作系统（一）：内存</title>
    <link href="/2021/03/11/OS-memory/"/>
    <url>/2021/03/11/OS-memory/</url>
    
    <content type="html"><![CDATA[<h1 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h1><p>为了让每个应用都可以高效又安全地使用物理内存，现代操作系统中会在应用程序和物理内存之间加入一层新的抽象：虚拟内存。应用程序在编写时仅考虑虚拟内存，CPU 在运行时将应用程序的虚拟内存地址翻译成物理内存地址，操作系统负责设置虚拟地址与物理地址之间的映射。</p><p>虚拟内存的设计有以下三个目标：</p><ul><li>高效性：虚拟内存不能在程序运行过程中造成明显的性能开销，且虚拟内存抽象也不应该占用过多的物理内存资源。</li><li>安全性：虚拟内存应使得不同应用程序之间的内存相互隔离。</li><li>透明性：应用程序开发者在变成时无需考虑虚拟内存抽象。</li></ul><h2 id="虚拟内存的翻译"><a href="#虚拟内存的翻译" class="headerlink" title="虚拟内存的翻译"></a>虚拟内存的翻译</h2><p>在使用虚拟内存的情况下，CPU 取指令时发出的时指令的虚拟地址，该虚拟地址被内存管理单元（Memory Management Unit，MMU）翻译为对应的物理地址，包含改物理地址的内存读请求被发送到物理内存设备，然后物理内存设备把该物理地址对应的内容发送给 CPU。为了加速翻译，现代 CPU 都引入了转址旁路缓存（Translation Lookaside Buffer，TLB）。</p><p>MMU 将虚拟地址翻译为物理地址的主要机制有两种：分段机制与分页机制，下面分别介绍。</p><h3 id="基于分段的虚拟地址"><a href="#基于分段的虚拟地址" class="headerlink" title="基于分段的虚拟地址"></a>基于分段的虚拟地址</h3><p>在分段机制中，操作系统以“段”的形式管理物理内存。CPU 访问虚拟内存空间中某一个段时，MMU 会通过查询<strong>段表</strong>得到该段对应的物理地址区域。</p><img src="虚拟内存翻译-段.png" width="65%"><p>虚拟地址由两个部分构成：高位的段号和低位的段内偏移。在翻译时，MMU 首先通过段表基地址寄存器找到段表的位置，结合虚拟地址中的段号，找到对应物理段的信息；然后取出该段的起始地址（物理地址），加上待翻译虚拟地址中的段地址（偏移量），就能够得到最终的物理地址。</p><p>在分段机制下，不仅虚拟内存空间被划分成不同的段，物理内存也以段为单位进行分配。这种段式分配方式容易导致在物理内存中出现外部碎片，即在段与段之间留下碎片空间，从而造成物理内存资源利用率的降低。</p><h3 id="基于分页的虚拟地址"><a href="#基于分页的虚拟地址" class="headerlink" title="基于分页的虚拟地址"></a>基于分页的虚拟地址</h3><h4 id="虚拟地址翻译"><a href="#虚拟地址翻译" class="headerlink" title="虚拟地址翻译"></a>虚拟地址翻译</h4><p>在 x86-64 架构之后，基于分页机制的虚拟内存已经成为主流。分页机制的思想是将虚拟内存地址空间划分成连续的、等长的虚拟页（显著区别于分段机制下不同长度的段），同时物理内存也被划分为连续的、等长的物理页。虚拟页和物理页的页长固定且相等，操作系统可以很方便地为每个应用程序构造<strong>页表</strong>，即虚拟页到物理页的映射关系表。类似于分段机制下的虚拟地址，分页机制下的虚拟地址分为两个部分：高位的页号和低位的页内地址。</p><img src="虚拟内存翻译-页.png" width="65%"><p>在翻译时，MMU 首先解析得到虚拟地址中的虚拟页号，然后通过页表基地址寄存器找到页表，查询该虚拟页号对应的物理页号，最后用该物理页号对应的物理页的起始地址加上虚拟地址中的页内偏移得到最终的物理地址。</p><p>在分页机制下，连续的虚拟页可以对应离散的物理页，因此可以实现物理内存资源的离散分配。并且，分页机制按照固定页大小分配物理内存，可以有效避免分段机制中的外部碎片。</p><h4 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h4><p>页表是分页机制中的关键部分，如果仅使用一张简单的页表来记录映射关系，那么对于 64 位的虚拟地址空间，假设一个页的大小为 4 KB，页表中每一项的大小为 8 字节，那么这个页表的大小就是 $2^{64}&#x2F;4 KB * 8$ 字节，即 33554432 GB。显然，这是不可接受的。因此，人们又设计出了多级页表来节省页表所占用的空间。</p><img src="虚拟内存翻译-多级页.png" width="65%"><p>在使用多级页表时，一个虚拟地址中仍然可以划分为页号和页内偏移量。但是页号被进一步划分成 k 个部分，每一个部分对应着其在每一级页表中所对应的项。在多级页表中，除了最后一级页表中的项是映射到物理页，其余的页表都映射到下一级页表上。注意，在 0 到 k - 1 级页表中，其条目可以为空，该空条目的子页表也就不存在。换句话说，多级页表允许在整个页表结构中出现空洞，而单级页表则不允许。在实际使用中，大多数虚拟地址空间都是未分配的，因此多级页表可以部分创建，进而节省内存空间。</p><h4 id="TLB"><a href="#TLB" class="headerlink" title="TLB"></a>TLB</h4><p>多级页表可以压缩页表的大小，但是会增加虚拟地址翻译的延迟。所以人们在 MMU 中加入了转址旁路缓存（TLB）来加速翻译的过程。TLB 相当于一个哈希表，将虚拟页号映射到物理页号上。考虑虚拟地址 VA，其在应用 A 和应用 B 中所对应的物理页是不同的，因此操作系统在切换应用程序时需要刷新 TLB 。</p><h2 id="虚拟内存的管理"><a href="#虚拟内存的管理" class="headerlink" title="虚拟内存的管理"></a>虚拟内存的管理</h2><h3 id="换页与缺页异常"><a href="#换页与缺页异常" class="headerlink" title="换页与缺页异常"></a>换页与缺页异常</h3><p>如果虚拟页没有被分配使用，那么页表中自然没有对应的物理页映射。反过来，被分配使用的虚拟页在页表中一定有相应的物理页映射吗？答案是否定的。</p><p>虚拟内存中存在换页机制。该机制的基本思想是：当物理内存容量不够的时候，操作系统把若干物理页写入磁盘中，然后回收物理页。当操作系统希望从应用程序 A 回收物理页 P （对应 A 的虚拟页 V）时，其会将物理页 P 的内容写入磁盘中一个位置，并且在应用程序 A 的页表中去除虚拟页 V 的映射，同时记录该物理页写入磁盘时的位置。这一过程叫做换出。此时，虚拟页 V 就处于已分配但未映射的状态。</p><p>当程序访问到已分配但未映射的虚拟页时，就会触发缺页异常，此时会运行操作系统预先定义的缺页异常处理函数。该函数会找到一个空闲的物理页，将磁盘中的数据重新加载到该物理页中，并且在页表中填写虚拟地址到该物理页的映射。这一过程被称为换入。</p><h3 id="换页策略"><a href="#换页策略" class="headerlink" title="换页策略"></a>换页策略</h3><p>常见的换页策略有：FIFO 策略、Second Chance 策略、LRU 策略、MRU 策略、时钟算法策略。</p><h4 id="FIFO-策略"><a href="#FIFO-策略" class="headerlink" title="FIFO 策略"></a>FIFO 策略</h4><p>FIFO 策略优先选择最先换入的页进行换出。操作系统维护一个队列，每换入一个页就将其加入队尾，需要换出页时则从队列头选择页。这种算法在实际中表现不佳，也几乎不会被现代操作系统采用。</p><h4 id="Second-Chance-策略"><a href="#Second-Chance-策略" class="headerlink" title="Second Chance 策略"></a>Second Chance 策略</h4><p>Second Chance 策略是 FIFO 策略的改进版。其在每个记录的物理页上增加了一个访问标志位，在寻找需要换出的内存页时，该策略优先查看位于队头的内存页。如果该内存页的访问标志位没有被置上，则换出该页；否则，将其标志位清空，并将其挪到队尾，然后继续从队头寻找符合条件的内存页。</p><h4 id="LRU-策略"><a href="#LRU-策略" class="headerlink" title="LRU 策略"></a>LRU 策略</h4><p>LRU 策略会记录每个物理页被访问的时间，在寻找物理页进行换出时，优先选择那些最久未被访问的物理页。</p><h4 id="MRU-策略"><a href="#MRU-策略" class="headerlink" title="MRU 策略"></a>MRU 策略</h4><p>MRU 策略和 LRU 策略相反，在寻找物理页进行换出时，会优先选择那些最近被访问的物理页。</p><h4 id="时钟算法策略"><a href="#时钟算法策略" class="headerlink" title="时钟算法策略"></a>时钟算法策略</h4><p>时钟算法将换入物理内存的页号排成一个时钟的形状。该时钟有一个针臂，指向新换入内存的页号的后一个。同时，也为每个页号维护一个访问标志位。每次需要选择换出页号时，该算法从针臂所指的页号开始检查。如果当前页号的访问位没有设置，则将该页换出；否则，将其访问标志位清空，并将针臂顺时针移动到下一个页号。时钟算法策略类似 Second Chance 策略，但实现上更高效些。</p><h1 id="物理内存"><a href="#物理内存" class="headerlink" title="物理内存"></a>物理内存</h1><h2 id="物理内存的分配"><a href="#物理内存的分配" class="headerlink" title="物理内存的分配"></a>物理内存的分配</h2><p>物理内存的分配有两个评价指标：内存资源利用率、分配性能。内存资源利用率要求分配机制可以减少内部碎片和外部碎片的大小；分配性能要求分配机制尽可能降低分配延迟和节约 CPU 资源。</p><h3 id="伙伴系统"><a href="#伙伴系统" class="headerlink" title="伙伴系统"></a>伙伴系统</h3><p>伙伴系统是现代操作系统中广泛使用的机制。其基本思想是将物理内存划分成连续的块，以块为单位进行分配。不同块的大小可以不同，但每个块都有一个或多个连续的物理页组成，物理页的数量必须是 2 的 n 次幂（$0 \le n &lt;$ 预设的最大值）。当一个请求需要分配 m 个物理页时，伙伴系统将寻找一个大小合适的块，该块包括 $2^n$ 个物理页，且满足 $2^{n-1} &lt; m \le 2^{n}$。在处理分配请求的过程中，大的块可以分裂成两半，这两个块互为伙伴。分裂得到的块可以继续分裂，直到一个大小合适的块去服务相应的分配请求。在一个块被释放后，分配器会找到其伙伴块，若伙伴块也处于空闲的状态，则可以将这两个块进行合并，合并得到的块可以进一步向上合并。由于分裂操作和合并操作都是级联的，因此可以很好地解决外部碎片的问题。</p><img src="虚拟内存翻译-空闲链表.png" width="45%"><p>在实际中，常用空闲列表去实现伙伴系统。具体来说，全局有一个有序数组，其每一项都指向一条空闲链表，每条链表将其对应大小的空闲块连接起来（一条链表中的空闲块大小相同）。当收到分配请求之后，伙伴分配器首先计算应该分配多大的空闲块，然后查找对应的空闲链表。例如，请求的大小是 15 KB，则应该分配一个 16 KB 的块。因此首先查找第二条 $2^2$ 空闲链表，如果链表不为空，则取出头节点的空闲块分配即可。但是在图中该链表为空，则继续访问第三条 $2^3$ 空闲链表，取出一个空闲块（32 KB），将其分裂成两个 16 KB 的空闲块，一块用于服务请求，另一个则插入 $2^2$ 这条空闲链表中。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://item.jd.com/12731379.html">现代操作系统：原理与实现</a>第 4 章</p>]]></content>
    
    
    <categories>
      
      <category>计算机科学</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Windows 下使用 Visual Studio 2019 进行 CUDA 编程</title>
    <link href="/2020/12/04/CUDA-PROGRAMMING-IN-WINDOWS/"/>
    <url>/2020/12/04/CUDA-PROGRAMMING-IN-WINDOWS/</url>
    
    <content type="html"><![CDATA[<h2 id="CUDA-安装"><a href="#CUDA-安装" class="headerlink" title="CUDA 安装"></a>CUDA 安装</h2><p>CUDA 的安装比较简单，下载了安装包以后一直点 Next 就行了，可以参考<a href="https://blog.csdn.net/letutu/article/details/81237081">这个博客</a>。</p><p>安装完以后对 CUDA 进行一下测试，在命令行执行 <code>nvcc -V</code> 得到下面的结果说明安装成功</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dns">$ nvcc -V<br>nvcc: NVIDIA (R) Cuda compiler driver<br>Copyright (c) <span class="hljs-number">2005-2019</span> NVIDIA Corporation<br>Built on Fri_Feb__8_19:<span class="hljs-number">08</span>:<span class="hljs-number">26</span>_Pacific_Standard_Time_2019<br>Cuda compilation tools, release <span class="hljs-number">10</span>.<span class="hljs-number">1</span>, V<span class="hljs-number">10.1.105</span><br></code></pre></td></tr></table></figure><h2 id="Visual-Studio-配置"><a href="#Visual-Studio-配置" class="headerlink" title="Visual Studio 配置"></a>Visual Studio 配置</h2><p>网上很多博客中，在 Visual Studio 中新建项目时都会有一个 NVIDIA 的模板，但是我在新建时并没有看到。所以我直接新建空白项目，然后为项目添加 CUDA 的依赖项。</p><img src="1.jpg" style="zoom:40%"><img src="2.png" style="zoom:60%"><p>然后在源文件中添加新建项，以 <code>.cu</code> 结尾，这里是 <code>test.cu</code>。然后对文件属性进行设置<br><img src="3.jpg" style="zoom:40%"></p><p>设置内容为 <code>配置属性-常规-项类型-CUDA C/C++</code>。</p><p>然后对项目属性进行配置。首先在 <code>配置属性-VC++ 目录-包含目录</code> 中添加 <code>$(CUDA_PATH)\include</code>，然后在 <code>配置属性-VC++ 目录-包含目录</code> 中添加 <code>$(CUDA_PATH)\lib\x64</code>，在 <code>配置属性-链接器-常规-附加库目录</code> 中添加 <code>$(CUDA_PATH)\lib\x64</code>，最后在 <code>配置属性-链接器-输入-附加依赖库</code> 中添加 </p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal">cublas.<span class="hljs-keyword">lib</span>;cublasLt.<span class="hljs-keyword">lib</span>;cuda.<span class="hljs-keyword">lib</span>;cudadevrt.<span class="hljs-keyword">lib</span>;cudart.<span class="hljs-keyword">lib</span>;cudart_static.<span class="hljs-keyword">lib</span>;cudnn.<span class="hljs-keyword">lib</span>;cudnn64_8.<span class="hljs-keyword">lib</span>;cudnn_adv_infer.<span class="hljs-keyword">lib</span>;cudnn_adv_infer64_8.<span class="hljs-keyword">lib</span>;cudnn_adv_train.<span class="hljs-keyword">lib</span>;cudnn_adv_train64_8.<span class="hljs-keyword">lib</span>;cudnn_cnn_infer.<span class="hljs-keyword">lib</span>;cudnn_cnn_infer64_8.<span class="hljs-keyword">lib</span>;cudnn_cnn_train.<span class="hljs-keyword">lib</span>;cudnn_cnn_train64_8.<span class="hljs-keyword">lib</span>;cudnn_ops_infer.<span class="hljs-keyword">lib</span>;cudnn_ops_infer64_8.<span class="hljs-keyword">lib</span>;cudnn_ops_train.<span class="hljs-keyword">lib</span>;cudnn_ops_train64_8.<span class="hljs-keyword">lib</span>;cufft.<span class="hljs-keyword">lib</span>;cufftw.<span class="hljs-keyword">lib</span>;curand.<span class="hljs-keyword">lib</span>;cusolver.<span class="hljs-keyword">lib</span>;cusparse.<span class="hljs-keyword">lib</span>;nppc.<span class="hljs-keyword">lib</span>;nppial.<span class="hljs-keyword">lib</span>;nppicc.<span class="hljs-keyword">lib</span>;nppicom.<span class="hljs-keyword">lib</span>;nppidei.<span class="hljs-keyword">lib</span>;nppif.<span class="hljs-keyword">lib</span>;nppig.<span class="hljs-keyword">lib</span>;nppim.<span class="hljs-keyword">lib</span>;nppist.<span class="hljs-keyword">lib</span>;nppisu.<span class="hljs-keyword">lib</span>;nppitc.<span class="hljs-keyword">lib</span>;npps.<span class="hljs-keyword">lib</span>;nvblas.<span class="hljs-keyword">lib</span>;nvgraph.<span class="hljs-keyword">lib</span>;nvml.<span class="hljs-keyword">lib</span>;nvrtc.<span class="hljs-keyword">lib</span>;OpenCL.<span class="hljs-keyword">lib</span><br></code></pre></td></tr></table></figure><p>实际上上面这些就是 <code>$(CUDA_PATH)\lib\x64</code> 下的所有 lib 文件的文件名，每个版本的 CUDA 所包括的 lib 文件各不相同，我这里是 CUDA 10.1 版本的 lib 文件。</p><p>配置完以后就可以编译运行 <code>.cu</code> 文件了，打开 <code>main.cu</code>，输入以下测试代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;cuda.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;cuda_runtime.h&quot;</span></span><br><br><span class="hljs-function">__global__ <span class="hljs-type">void</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello world from device\n&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    hello &lt;&lt; &lt;<span class="hljs-number">1</span>, <span class="hljs-number">1</span> &gt;&gt; &gt; ();<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello world from host\n&quot;</span>);<br>    <span class="hljs-built_in">cudaDeviceSynchronize</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>得到结果</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">Hello world <span class="hljs-keyword">from</span> host<br>Hello world <span class="hljs-keyword">from</span> device<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>环境配置</category>
      
      <category>CUDA 编程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Distilling a Nerual Network Into a Soft Decision Tree 翻译</title>
    <link href="/2020/11/19/Distilling-a-Nerual-Network-Into-a-Soft-Decision-Tree/"/>
    <url>/2020/11/19/Distilling-a-Nerual-Network-Into-a-Soft-Decision-Tree/</url>
    
    <content type="html"><![CDATA[<p>下面是我对《<a href="https://arxiv.org/abs/1711.09784">Distilling a Nerual Network Into a Soft Decision Tree</a>》的简单翻译</p><h1 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h1><p>深度神经网络在分类任务上有很出色的表现，但是却非常难解释其对一个具体的测例做出分类的原因。这是因为他们非常依赖于分布式的分层表示。如果我们将从神经网络中获取到的知识用一个依赖于分层决定的模型来进行表示，解释一个具体的决定会变得更加容易。我们提出了一种使用训练好的神经网络来创建一种软决策树的方法，其比直接从训练数据中学到的模型泛化的更好。</p><h1 id="Introdcution"><a href="#Introdcution" class="headerlink" title="Introdcution"></a>Introdcution</h1><p>深度神经网络优秀的泛化能力取决于它们隐藏层中的分布式表示，但是这种表示非常难被理解。对于第一个隐藏层，我们可以理解使一个神经元激活的原因；对最后一个隐藏层，我们可以理解激活一个神经元的效果；但是对于其他隐藏层，我们很难从有意义的变量的角度，如输入变量和输出变量，来理解特征激活的原因和影响。而且，隐藏层中的神经元将输入的向量分解为一组特征激活，通过这样的方式这些激活特征的组合效果可以在下一个隐藏层中产生一种合适的分布式表示。这使得很难单独地理解任何特定的特征激活的效果，因为其边际效应取决于同一隐藏层中的所有其他神经元的效果。</p><p>深度神经网络可以通过模拟训练数据中输入和输出之间的大量弱统计规律来做出可靠的决定，并且神经网络中没有任何东西可以区分数据集中真实的弱规律性和训练集采样特性导致的虚假规律性，这进一步加剧了上述的困难。面对这些困难，放弃通过理解单个隐藏单元的行为来理解深度神经网络是如果做分类决策的想法看起来是明智。</p><p>相比之下，决策树是如何进行任何特定的分类是很容易进行解释的，因为每个分类取决于一个相对较短的决策序列，并且每个决策都是直接基于输入数据的。但是，决策树通常并没有深度神经网络泛化的好。不同于神经网络中的隐藏神经元，决策树中一个特定的低层节点只被非常少的训练数据使用。因此，除非训练集的大小和树的深度相比呈指数增长，否则决策树的底层部分会趋于过拟合。</p><p>在这篇文章中，我们提出了一种解决泛化性和可解释性之间矛盾的新方法。不同于尝试去理解一个深度神经网络是如何做出决策的，我们使用深度神经网络来训练一个决策树，其模仿神经网络发现的输入-输出函数，但以一种完全不同的方式工作。如果有非常多的无标记数据，则可以使用神经网络创建更大的标记数据集来训练决策树，从而克服决策树统计效率低下的问题。即使没有无标记数据，也可以使用最近先进的生成模型从一个接近于数据分布的分布中来生成合成的无标记数据。即使不适用无标记数据，也仍然可能使用一种叫分馏（distillation）的技术和一种做软决策的决策树来将神级网络中的泛化性转移到决策树中。</p><p>在测试时，我们使用了决策树作为模型。这可能会比神经网络表现的差一些，但是决策树会更快，并且我们有了一个可以解释并直接参与决策的模型。我们从描述我们所使用的特定类型的决策树开始。这个选择是为了便于将深度神经网络获取的知识轻松地提取到决策树中。</p>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>HTML基本语法及使用</title>
    <link href="/2019/07/01/HTML/"/>
    <url>/2019/07/01/HTML/</url>
    
    <content type="html"><![CDATA[<h1 id="HTML简介"><a href="#HTML简介" class="headerlink" title="HTML简介"></a>HTML简介</h1><p>HTML全程为Hyper Text Markup Language，翻译过来是超文本标记语言。所谓的超文本，包含了普通文本、图片、标题、表格、链接等。HTML是前端中最常使用的三个语言之一，一般由其组成网页的骨干。</p><h1 id="HTML示例"><a href="#HTML示例" class="headerlink" title="HTML示例"></a>HTML示例</h1><p>下面有一段简单的HTML代码。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs HTML"><span class="hljs-meta">&lt;!doctype <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>页面标题<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>一级标题<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>段落内容<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>将这一段代码保存为 .html 文件，并用浏览器打开，会得到以下的页面。<br><img src="/2019/07/01/HTML/example.png" alt="example"></p><h1 id="HTML语法"><a href="#HTML语法" class="headerlink" title="HTML语法"></a>HTML语法</h1><p>简单来说，HTML语言是由一对对的标签组成的。在上面的例子中，我们有 <code>&lt;html&gt;</code> 和 <code>&lt;/html&gt;</code> 这一对标签，其中间的内容是 HTML 文件的主要内容；<code>&lt;h1&gt;</code> 和 <code>&lt;/h1&gt;</code> 两个标签表明他们中间的内容为一级标题，等等。当然，我们也发现了有像 <code>&lt;meta&gt;</code> 这样的单标签，没有响应的另一标签和其对应。</p><p>下面，根据 HTML 标签中的不同种类对其进行介绍。</p><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><table><thead><tr><th>标题等级</th><th>标签</th><th>效果</th></tr></thead><tbody><tr><td>一级标题</td><td><code>&lt;h1&gt;xxx&lt;\h1&gt;</code></td><td><h1>一级标题</td></tr><tr><td>二级标题</td><td><code>&lt;h2&gt;xxx&lt;\h2&gt;</code></td><td><h2>二级标题</td></tr><tr><td>三级标题</td><td><code>&lt;h3&gt;xxx&lt;\h3&gt;</code></td><td><h3>三级标题</td></tr><tr><td>四级标题</td><td><code>&lt;h4&gt;xxx&lt;\h4&gt;</code></td><td><h4>四级标题</td></tr><tr><td>五级标题</td><td><code>&lt;h5&gt;xxx&lt;\h5&gt;</code></td><td><h5>五级标题</td></tr><tr><td>六级标题</td><td><code>&lt;h6&gt;xxx&lt;\h6&gt;</code></td><td><h6>六级标题</td></tr></tbody></table><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>有序列表：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">ol</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>阿凡达<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>泰坦尼克号<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>复仇者联盟<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ol</span>&gt;</span><br></code></pre></td></tr></table></figure><p>效果如下：</p><div style="line-height:12px"><ol>    <li>阿凡达</li>    <li>泰坦尼克号</li>    <li>复仇者联盟</li></ol></div><p>无序列表</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>葡萄<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>西瓜<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>苹果<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br></code></pre></td></tr></table></figure><p>效果如下：</p><div style="line-height:12px"><ul>    <li>葡萄</li>    <li>西瓜</li>    <li>苹果</li></ul></div><p>定义列表：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">dl</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">dt</span>&gt;</span>计算机<span class="hljs-tag">&lt;/<span class="hljs-name">dt</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>用来计算的仪器 ... ...<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">dt</span>&gt;</span>显示器<span class="hljs-tag">&lt;/<span class="hljs-name">dt</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>以视觉方式显示信息的装置 ... ...<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dl</span>&gt;</span><br></code></pre></td></tr></table></figure><p>效果如下：</p><div style="line-height:13px"><dl>   <dt>计算机</dt>   <dd>用来计算的仪器 ... ...</dd>   <dt>显示器</dt>   <dd>以视觉方式显示信息的装置 ... ...</dd></dl></div><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>链接用于外链到其他网站，使用方法如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;http://www.tsinghua.edu.cn&quot;</span>&gt;</span><br>清华大学<br><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><p>效果如下：<br><a href="http://www.tsinghua.edu.cn"><br>清华大学<br></a></p><h2 id="多媒体"><a href="#多媒体" class="headerlink" title="多媒体"></a>多媒体</h2><p>多媒体包括图片、音频、视频等等多媒体文件。</p><p>图片：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> </span><br><span class="hljs-tag"> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://p0.ssl.qhimg.com/t0142620c6328f7ab7d.jpg&quot;</span></span><br><span class="hljs-tag"> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;Metal movable type&quot;</span></span><br><span class="hljs-tag"> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;400&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p>效果：<br><img  src="https://p0.ssl.qhimg.com/t0142620c6328f7ab7d.jpg" alt="Metal movable type" width="400"></p><p>音频：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">audio</span></span><br><span class="hljs-tag"><span class="hljs-attr">controls</span></span><br><span class="hljs-tag"><span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://s2.ssl.qhres.com/static/cbf0c6b1ea11e72b.ogg&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">audio</span>&gt;</span><br></code></pre></td></tr></table></figure><p>效果：<br><audiocontrolssrc="https://s2.ssl.qhres.com/static/cbf0c6b1ea11e72b.ogg"><br></audio></p><p>视频：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">video</span></span><br><span class="hljs-tag">  <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://s2.ssl.qhres.com/static/eb04e248864ac1a8.mp4&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">controls</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">video</span>&gt;</span><br></code></pre></td></tr></table></figure><p>效果：<br><video  src="https://s2.ssl.qhres.com/static/eb04e248864ac1a8.mp4"  controls><br></video></p><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><p>HTML中输入使用的是<code>&lt;input&gt;</code>标签，但是赋予不同的属性之后会得到不一样的效果。</p><p>最简单的输入标签如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><p>效果为：<br>    <input></p><p>如果我们要在输入框中添加一些提示，则可以这样做：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;请输入用户名&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><p>效果如下：<br><input placeholder="请输入用户名"></p><p>如果我们要让用户输入一个范围，那我们可以指定标签的类型。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;range&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><p>效果如下：<br><input type="range"></p><p>如果我们要用户输入一个数字，并且这个数字有一定的范围，那我们可以指定这个标签的更多属性</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;number&quot;</span> <span class="hljs-attr">min</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">max</span>=<span class="hljs-string">&quot;10&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;3&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><p>效果如下：<br><input type="number" min="1" max="10" value="3"></p><p>如果我们要用户输入一个日期，并且也有一定的范围，同上面一样，我们可以这样做：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;date&quot;</span> <span class="hljs-attr">min</span>=<span class="hljs-string">&quot;2018-02-10&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><p>效果如下：<br><input type="date" min="2018-02-10"></p><p>如果我们用用户输入一系列文本，则应该使用<code>&lt;textarea&gt;</code>标签</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">textarea</span>&gt;</span>Hello<span class="hljs-tag">&lt;/<span class="hljs-name">textarea</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><p>效果如下：</p><textarea>Hello</textarea><h2 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h2><p>选择使用的是<code>checkbox</code>和<code>radio</code>两种属性。各自的效果如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span>&gt;</span> Apple<br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">checked</span>&gt;</span> Watermelon<br></code></pre></td></tr></table></figure><p>效果为：<br><input type="checkbox"> Apple<br><input type="checkbox" checked> Watermelon</p><p>另一种选择则是：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sport&quot;</span>&gt;</span> basketball<br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sport&quot;</span>&gt;</span> football<br></code></pre></td></tr></table></figure><p>效果为：<br><input type="radio" name="sport"> basketball<br><input type="radio" name="sport"> football</p><h2 id="文本标签"><a href="#文本标签" class="headerlink" title="文本标签"></a>文本标签</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">blockquote</span> <span class="hljs-attr">cite</span>=<span class="hljs-string">&quot;http://t.cn/RfjKO0F&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>天才并不是⾃⽣⾃⻓在深林荒野⾥的怪物， 是由可以使天才⽣⻓<br>的⺠众产⽣、⻓育出来的，所以没有 这种⺠众，就没有天才。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">blockquote</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>我最喜欢的⼀本书是<span class="hljs-tag">&lt;<span class="hljs-name">cite</span>&gt;</span>⼩王⼦<span class="hljs-tag">&lt;/<span class="hljs-name">cite</span>&gt;</span>。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>在<span class="hljs-tag">&lt;<span class="hljs-name">cite</span>&gt;</span>第⼀章<span class="hljs-tag">&lt;/<span class="hljs-name">cite</span>&gt;</span>，我们讲过<span class="hljs-tag">&lt;<span class="hljs-name">q</span>&gt;</span>字符串是不可变量<span class="hljs-tag">&lt;/<span class="hljs-name">q</span>&gt;</span>。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>const<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span>声明创建⼀个只读的常量。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">pre</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span><br>const add = (a, b) =&gt; a + b;<br>const multiply = (a, b) =&gt; a * b;<br><span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">pre</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>在投资之前，<span class="hljs-tag">&lt;<span class="hljs-name">strong</span>&gt;</span>⼀定要做⻛险评估<span class="hljs-tag">&lt;/<span class="hljs-name">strong</span>&gt;</span>。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><p>效果为：</p><div><blockquote cite="http://t.cn/RfjKO0F"><p>天才并不是⾃⽣⾃⻓在深林荒野⾥的怪物， 是由可以使天才⽣⻓的⺠众产⽣、⻓育出来的，所以没有 这种⺠众，就没有天才。</p></blockquote><p>我最喜欢的⼀本书是<cite>⼩王⼦</cite>。</p><p>在<cite>第⼀章</cite>，我们讲过<q>字符串是不可变量</q>。</p><p><code>const</code>声明创建⼀个只读的常量。</p><pre><code class="hljs">const add = (a, b) => a + b;const multiply = (a, b) => a * b;</code></pre><p>在投资之前，<strong>⼀定要做⻛险评估</strong>。</p></div><p><code>&lt;p&gt;</code>标签生成一个新的段落，<code>&lt;cite&gt;</code>用于标记斜体文字，<code>&lt;code&gt;</code>可以标注出文本中的代码，<code>&lt;strong&gt;</code>用以将指定文字粗体，<code>&lt;pre&gt;</code>用以生成一个文本框。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上就是比较常用的HTML标签，当然，制作一个网页只有HTML是不够的，往往还需要配合CSS和JavaScript才能制作出动态美观的网页。</p>]]></content>
    
    
    <categories>
      
      <category>网页前端</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>最长回文子序列问题</title>
    <link href="/2019/06/14/LPS/"/>
    <url>/2019/06/14/LPS/</url>
    
    <content type="html"><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p><strong>回文</strong>是正序与逆序相同的非空字符串。例如，所有长度为1的字符串、civic、racecar、aibohphobia（害怕回文之意）都是回文。</p><p>设计高效算法，求给定输入字符串的最长回文子序列。例如，给定输入 character，算法应该返回 carac。算法的运行时间是怎么样的？</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>本题出自《算法导论》第 15 章的思考题15-3。这道题可以使用暴力罗列的方法做，那么总共会有 $2^n$ 种情况，算法的复杂度也为 $O(2^n)$ ，其中 $n$ 为输入字符串的长度。</p><p>为了减小算法的复杂度，可以使用动态规划的方法解决。</p><p>给定任意一个输入串 $X &#x3D; {x_1, x_2, x_3, x_4… x_n}$，定义其子串 $X_{i,j} &#x3D; { x_i, x_{i+1}, x_{i+2}, …, x_j}$。设一个函数 $f(X_{i,j})$，其定义如下：</p><p>$$f(X_{i,j})&#x3D; 1 , X_{i,j}是回文序列 $$<br>$$f(X_{i,j})&#x3D; 0 , X_{i,j}不是回文序列$$</p><p>对于任意一个子串 $X_{i,j}$，分以下几种情况讨论：</p><p>$ x_i &#x3D; x_j $，则此时 $X_{i,j}$是否是回文子序列，与 $x_i$和 $x_j$无关，可以将其从 $ X_{ij} $中去除。如果 $X_{i+1, j-1} $是一个回文序列，则 $X_{i, j}$ 也是一个回文序列；如果 $X_{i+1, j-1} $不是一个回文序列，则 $X_{i, j}$也不是一个回文序列。例如，给定一个序列 $ 1w1 $，其中 $w$是一段字符串序列。由于这个序列左右两端是相同的，因此当 $w$是一个回文序列时， $1w1$才是一个回文序列；反之亦然。所以，我们可以给出如下式子：<br>$$ f(X_{i,j}) &#x3D; f(X_{i+1, j - 1}), x_i &#x3D; x_j$$</p><p>$ x_i \neq x_j$，则此时由于 $X_{i, j}$两端的字符不同，其当然不是回文序列。同上，我们有：<br>$$ f(X_{i,j}) &#x3D; 0, x_i \neq x_j$$</p><p>除此之外，我们还知道，一个只含有单个字符的字符串是回文序列；一个只有两个字符的字符串，即 $X_{i, i+1}$，如果有 $x_i &#x3D; x_{i+1} $，则其也是回文序列。</p><p>综上，我们给出 $f(X_{i, j})$的完整递归式：<br>$ f(X_{i, j}) &#x3D;  1 , i &#x3D; j  $<br>$f(X_{i, j}) &#x3D; 1 , x_i &#x3D; x_j, j &#x3D; i + 1 $<br>$  f(X_{i, j}) &#x3D;f(X_{i+1, j-1}) ,x_i &#x3D; x_j $<br>$f(X_{i, j}) &#x3D; 0 , x_i \neq x_j  $</p><p>我们不妨使用一个 $ n \times n $的矩阵来储存 $f(X_{i, j})$的值。我们给出如下伪代码：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs stylus"> <span class="hljs-built_in">LONGEST-PALINDROME-SUBSEQUENCE</span>(S)<br><span class="hljs-number">1</span>   n = S<span class="hljs-selector-class">.length</span><br><span class="hljs-number">2</span>   let <span class="hljs-selector-tag">p</span><span class="hljs-selector-attr">[1 ... n, 1 ... n]</span> be <span class="hljs-selector-tag">a</span> new <span class="hljs-selector-tag">table</span><br><span class="hljs-number">3</span>   <span class="hljs-keyword">for</span> <span class="hljs-selector-tag">i</span> = <span class="hljs-number">1</span> to n<br><span class="hljs-number">4</span>       <span class="hljs-keyword">for</span> j = <span class="hljs-number">1</span> to n<br><span class="hljs-number">5</span>           <span class="hljs-keyword">if</span> <span class="hljs-selector-tag">i</span> == j<br><span class="hljs-number">6</span>               <span class="hljs-selector-tag">p</span><span class="hljs-selector-attr">[i]</span><span class="hljs-selector-attr">[j]</span> = <span class="hljs-number">1</span><br><span class="hljs-number">7</span>           <span class="hljs-keyword">else</span><br><span class="hljs-number">8</span>               <span class="hljs-selector-tag">p</span><span class="hljs-selector-attr">[i]</span><span class="hljs-selector-attr">[j]</span> = <span class="hljs-number">0</span><br><span class="hljs-number">9</span>   <span class="hljs-keyword">for</span> <span class="hljs-selector-tag">i</span> = <span class="hljs-number">1</span> to n-<span class="hljs-number">1</span><br><span class="hljs-number">10</span>      <span class="hljs-keyword">for</span> j = <span class="hljs-number">1</span> to n-<span class="hljs-selector-tag">i</span><br><span class="hljs-number">11</span>          <span class="hljs-keyword">if</span> <span class="hljs-selector-tag">i</span> == <span class="hljs-number">1</span><br><span class="hljs-number">12</span>              <span class="hljs-keyword">if</span> S<span class="hljs-selector-attr">[j]</span> == S<span class="hljs-selector-attr">[j+1]</span><br><span class="hljs-number">13</span>                  <span class="hljs-selector-tag">p</span><span class="hljs-selector-attr">[j]</span><span class="hljs-selector-attr">[j+1]</span> = <span class="hljs-number">1</span><br><span class="hljs-number">14</span>          <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> x<span class="hljs-selector-attr">[j]</span> == x<span class="hljs-selector-attr">[j + i]</span><br><span class="hljs-number">15</span>              <span class="hljs-selector-tag">p</span><span class="hljs-selector-attr">[j]</span><span class="hljs-selector-attr">[j+i]</span> = <span class="hljs-selector-tag">p</span><span class="hljs-selector-attr">[j+1]</span><span class="hljs-selector-attr">[j+i-1]</span><br><span class="hljs-number">16</span>          <span class="hljs-keyword">else</span><br><span class="hljs-number">17</span>              <span class="hljs-selector-tag">p</span><span class="hljs-selector-attr">[j]</span><span class="hljs-selector-attr">[j+i]</span> = <span class="hljs-number">0</span><br><span class="hljs-number">18</span><br><span class="hljs-number">19</span>  max_length = -<span class="hljs-number">1</span>, <span class="hljs-attribute">left</span> = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span><br><span class="hljs-number">20</span>  <span class="hljs-keyword">for</span> <span class="hljs-selector-tag">i</span> = <span class="hljs-number">1</span> to n<br><span class="hljs-number">21</span>      <span class="hljs-keyword">for</span> j = <span class="hljs-number">1</span> to n<br><span class="hljs-number">22</span>          <span class="hljs-keyword">if</span> j - <span class="hljs-selector-tag">i</span> &gt; max_length<br><span class="hljs-number">23</span>              max_length = j - <span class="hljs-selector-tag">i</span><br><span class="hljs-number">24</span>              <span class="hljs-attribute">left</span> = i, right = j<br><span class="hljs-number">25</span>  return S<span class="hljs-selector-attr">[left:right]</span><br></code></pre></td></tr></table></figure><p>使用Python的实现如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np <br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">LPS</span>(<span class="hljs-params">s</span>):<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(s) &lt;= <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">return</span> s<br>    p = np.zeros((<span class="hljs-built_in">len</span>(s), <span class="hljs-built_in">len</span>(s)))<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s)):<br>        p[i][i] = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(s)):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s) - i):<br>            <span class="hljs-keyword">if</span> i == <span class="hljs-number">1</span>:<br>                <span class="hljs-keyword">if</span> s[j] == s[j+i]:<br>                    p[j][j+i] = <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">if</span> s[j] == s[j+i]:<br>                    p[j][j+i] = p[j+<span class="hljs-number">1</span>][j+i-<span class="hljs-number">1</span>]<br>                <span class="hljs-keyword">else</span>:<br>                    p[j][j+i] = <span class="hljs-number">0</span><br>    max_len = -<span class="hljs-number">1</span><br>    l, r = -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s)-<span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i, <span class="hljs-built_in">len</span>(s)):<br>            <span class="hljs-keyword">if</span> p[i][j] == <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> j - i &gt; max_len:<br>                l, r = i, j<br>                max_len = j - i<br>    <span class="hljs-keyword">return</span> s[l:r+<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><p>显然，该算法的复杂度为 $ O(n^2) $，远比暴力求解的 $O(2^n)$要好。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Pytorch使用Visdom可视化</title>
    <link href="/2018/03/11/visdom-1/"/>
    <url>/2018/03/11/visdom-1/</url>
    
    <content type="html"><![CDATA[<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script><h1 id="Visdom"><a href="#Visdom" class="headerlink" title="Visdom"></a>Visdom</h1><p>Visdom是Pytorch自带的一个可视化工具，能够在训练神经网络的过程中，将一些数据进行可视化。目前Visdom可以支持Numpy和Torch。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">$ pip <span class="hljs-keyword">install</span> visdom<br></code></pre></td></tr></table></figure><h2 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h2><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta">$ python -m visdom.<span class="hljs-keyword">server</span><br></code></pre></td></tr></table></figure><p>默认的端口号为8097，如果需要更改端口号，可以加入-p选项</p><h2 id="两个概念"><a href="#两个概念" class="headerlink" title="两个概念"></a>两个概念</h2><p>使用Visdom需要区分其中的一些概念，以将可视化环境分隔开</p><h3 id="Panes"><a href="#Panes" class="headerlink" title="Panes"></a>Panes</h3><p>Panes即窗格，其中可以显示具体的数据可视化内容。Panes可以进行拖放、删除等操作。</p><p><img src="/2018/03/11/visdom-1/pane.png" alt="panes"></p><h3 id="env"><a href="#env" class="headerlink" title="env"></a>env</h3><p>env即Environment。Pane存放在env中，一个env中可以存放多个pane。默认的env为<code>main</code>，可以在初始化Visdom的时候指定env，如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> visdom <span class="hljs-keyword">import</span> Visdom<br><br>vis = Visdom()<br></code></pre></td></tr></table></figure><p>此时默认环境为<code>main</code></p><p>而假设想将环境改为<code>loss</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> visdom <span class="hljs-keyword">import</span> Visdom<br><br>vis = Visdom(env=<span class="hljs-string">&#x27;loss&#x27;</span>)<br></code></pre></td></tr></table></figure><p>则此时的visdom环境变成了<code>loss</code></p><h2 id="几个API"><a href="#几个API" class="headerlink" title="几个API"></a>几个API</h2><p>Visdom中提供了不同的API，来绘制不同类型的图像。</p><h3 id="plot-scatter"><a href="#plot-scatter" class="headerlink" title="plot.scatter"></a>plot.scatter</h3><p>plot.scatter 用来绘制2D或者3D的散点图，需要输入N * 2或者N * 3的tensor X来确定N个点的位置。</p><h3 id="plot-line"><a href="#plot-line" class="headerlink" title="plot.line"></a>plot.line</h3><p>这个API可以用来绘制线条。它需要一个形状为N或者N*M的tensorY，用来指定M条线的值（每条线上有N个点），和一个可选的tensorX来指定X轴的值。X可以是一个长度为N的tensor（此时M条线共享一个X），也可以是一个形状和tensorY相同的tensor。</p><h3 id="plot-image"><a href="#plot-image" class="headerlink" title="plot.image"></a>plot.image</h3><p>这个API用来画图像。输入</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-function"><span class="hljs-title">img</span>(<span class="hljs-variable">tensor</span>):<span class="hljs-title">shape</span>(<span class="hljs-variable">C</span> * <span class="hljs-variable">H</span> * <span class="hljs-variable">W</span>)</span><br></code></pre></td></tr></table></figure><h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> visdom <span class="hljs-keyword">import</span> visdom<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br>vis = Visdom(env=<span class="hljs-string">&#x27;test&#x27;</span>)<br>win = vis.line(<br>        X=np.zeros(<span class="hljs-number">1</span>),<br>        Y=np.zeros(<span class="hljs-number">1</span>),<br>        opts=<span class="hljs-built_in">dict</span>(title=<span class="hljs-string">&#x27;test_random&#x27;</span>)<br>)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100</span>):<br>    vis.line(<br>        X=np.array([i]),<br>        Y=np.random.randn(<span class="hljs-number">1</span>),<br>        win=win,<br>        update=<span class="hljs-string">&#x27;append&#x27;</span><br>    ) <span class="hljs-comment"># win要和之前的win保持一致，update选择append不会覆盖之前的数据</span><br></code></pre></td></tr></table></figure><p>效果：</p><p><img src="/2018/03/11/visdom-1/test_random.png" alt="test"></p><h2 id="远程使用Visdom"><a href="#远程使用Visdom" class="headerlink" title="远程使用Visdom"></a>远程使用Visdom</h2><p>很多时候训练神经网络并不是在自己的电脑上进行，而是在远端的服务器上进行。下面介绍如何连接查看服务器端的visdom</p><h3 id="SSH连接"><a href="#SSH连接" class="headerlink" title="SSH连接"></a>SSH连接</h3><p>在命令行中输入</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">ssh</span> -L <span class="hljs-number">18097</span>:<span class="hljs-number">127.0.0.1:8097</span> username<span class="hljs-variable">@remote_ip</span><br></code></pre></td></tr></table></figure><p>其中，18097:127.0.0.1代表自己机器上的端口号，8097是服务器上visdom的端口号。username是在远程服务器上的用户名，remote_ip是服务器的ip地址。</p><p>效果：<br><img src="/2018/03/11/visdom-1/remote.png" alt="remote"></p><h3 id="启动visdom服务器"><a href="#启动visdom服务器" class="headerlink" title="启动visdom服务器"></a>启动visdom服务器</h3><p>同上面介绍的一样，在服务器端启动visdom服务，输入</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta">$ python -m visdom.<span class="hljs-keyword">server</span><br></code></pre></td></tr></table></figure><h3 id="在本地浏览器中浏览"><a href="#在本地浏览器中浏览" class="headerlink" title="在本地浏览器中浏览"></a>在本地浏览器中浏览</h3><p>启动完远程的visdom服务之后，在本地浏览器中输入</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">127.0.0.1:18097</span><br></code></pre></td></tr></table></figure><p>即可访问服务器端的visdom</p>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
      <category>工具</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
