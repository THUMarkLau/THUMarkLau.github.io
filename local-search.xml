<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>LevelDB 源代码阅读（五）：SSTable</title>
    <link href="/2021/07/22/leveldb-source-code-reading-5/"/>
    <url>/2021/07/22/leveldb-source-code-reading-5/</url>
    
    <content type="html"><![CDATA[<p>在 LSM 结构的数据库中，SSTable 指的是数据落盘之后形成的文件。在 LevelDB 中，SSTable 是以 <em>.sst</em> 文件的形式存在的。本文将介绍 LevelDB 中 SSTable 的写过程和读过程。</p><h1 id="SSTable-的总体结构"><a href="#SSTable-的总体结构" class="headerlink" title="SSTable 的总体结构"></a>SSTable 的总体结构</h1><img src="SSTable-structrue.png"><p>图中所示为 SSTable 文件的整体结构。文件的前部分为数据部分（DataBlock），文件的结尾部分为数据的索引。在索引部分，又分为了 Filter Block 、 Meta Index Block 、 Index Block 以及 Footer 。下面我们依次来介绍 SSTable 中每个结构的具体细节。</p><h2 id="数据部分"><a href="#数据部分" class="headerlink" title="数据部分"></a>数据部分</h2><p>数据部分由许多个 DataBlock 组成，在 LevelDB 中，一个 DataBlock 的大小默认设置为 4 KB 。每个 DataBlock 由三个部分组成：数据部分（Data）、压缩类型（CompressionType）以及校验和（CRC）。</p><img src="SSTable-datablock-struct.png"><p>Data 中存储的即是数据库的数据内容； CompressionType 中记录了对原始数据使用的压缩方式，在 LevelDB 中默认的压缩方式是 Snappy ； CRC 部分则记录了对 Data 以及 CompressionType 进行 CRC32 计算得到的结果，用来保证数据的正确性。</p><p>Data 部分有更加细微的结构：</p><img src="SSTable-datastruct.png"><p>图中每一个 Entry 就是一组 Key-Value 对，由于 DataBlock 在写入时，在一组键之间会寻找可以共享的长度（详见后面的写入过程），因此 Entry 块的后面会有若干个 Restart Point ，每个 Restart Point 会指向一个 Entry ，这个 Entry 不会与其前面的 Entry 有共享的键内容。每次读取数据时，都要从 Restart Point 指向的某个 Entry 开始往后读，直到读到目标键值对为止。最后，Data 中还标记了 Restart Point 的个数。前面提到，在编码是会对一组 Key 进行键值共享，因此一个 Entry 的结构为</p><img src="SSTable-entrystruct.png"><h2 id="索引部分"><a href="#索引部分" class="headerlink" title="索引部分"></a>索引部分</h2><p>索引部分主要包含两大部分：数据的索引及元数据、布隆过滤器的索引及内容。</p><h3 id="Filter-Block"><a href="#Filter-Block" class="headerlink" title="Filter Block"></a>Filter Block</h3><p>Filter Block 主要装载布隆过滤器的内容，所谓布隆过滤器就是一种用于快速模糊查找的数据结构，关于布隆过滤器的详细介绍可以查看这篇<a href="https://zhuanlan.zhihu.com/p/43263751">文章</a>。</p><img src="SSTable-filter-block-struct.png"><p>Filter Block 中的 Filter Data 块保存了布隆过滤器的具体内容；绿色部分的 Offset of Filter Data $i$ 则记录了第 $i$ 个 Filter Data 的偏移量；Offset of Filter Offset 则记录了 Offset of Filter Data 1 的偏移量；Base Lg 默认值为 11 ，表示每 2 KB 的数据创建一个新的过滤器来存放过滤数据。因此，Filter Data $i$ 就记录了文件中位置位于 [2KB $\times (i-1)$, 2KB $\times i$] 范围内数据的 Filter 数据。</p><h3 id="Meta-Index-Block"><a href="#Meta-Index-Block" class="headerlink" title="Meta Index Block"></a>Meta Index Block</h3><p>Meta Index Block 用以记录 Filter Block 在整个 SSTable 中的位置，整个 Block 只记录了一组键值对，Key 为 “filter.” 与过滤器名称组成的常量字符串，值则为 Filter Block 的索引信息（包括 Filter Block 在 SSTable 中的偏移量以及 Filter Block 的数据长度）序列化后的内容。</p><h3 id="Index-Block"><a href="#Index-Block" class="headerlink" title="Index Block"></a>Index Block</h3><p>Index Block 记录了数据部分的索引信息。具体地，Index Block 由多个 &lt;Max Key&gt;&lt;Offset&gt;&lt;Length&gt; 这样的三元组构成。一个三元组对应了数据部分的一个 DataBlock ，三元组中的信息分别记录了其最大键值、在文件中的偏移量以及大小三个信息。</p><img src="SSTable-indexblock-struct.png"><p>在写入 DataBlock 的过程中，不同的 DataBlock 和 DataBlock 内部都是严格有序的（因为 MemTable 中的 SkipList 也是有序的），因此在查询时可以通过 IndexBlock 中记录的 MaxKey信息进行快速查找，然后根据 Offset 和 Length 信息将找到的 DataBlock 读取出来，再进行下一步的处理。</p><h3 id="Footer"><a href="#Footer" class="headerlink" title="Footer"></a>Footer</h3><p>Footer 的大小是固定的，为 48 个字节，其存储了 MetaIndexBlock 的 offset、 IndexBlock 的 offset 以及一串 Magic Word ，内容为 “<a href="http://code.google.com/p/leveldb/">http://code.google.com/p/leveldb/</a>“ 字符串 sha1 哈希的前 8 个字节。</p><h1 id="SSTable-的写流程"><a href="#SSTable-的写流程" class="headerlink" title="SSTable 的写流程"></a>SSTable 的写流程</h1><p>在 LevelDB 中，Level 0 级的 SSTable 由内存中的 <em>Immutable MemTable</em> 写出得到，这个过程在 <em>db_impl.cc</em> 中的 <code>WriteLevel0Table</code> 中和主线程异步地执行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// db_impl.cc</span><br><span class="hljs-function">Status <span class="hljs-title">DBImpl::WriteLevel0Table</span><span class="hljs-params">(MemTable* mem, VersionEdit* edit,</span></span><br><span class="hljs-params"><span class="hljs-function">                                Version* base)</span> </span>&#123;<br>  mutex_.<span class="hljs-built_in">AssertHeld</span>();<br>  <span class="hljs-type">const</span> <span class="hljs-type">uint64_t</span> start_micros = env_-&gt;<span class="hljs-built_in">NowMicros</span>();<br>  <span class="hljs-comment">// 生成文件元数据</span><br>  FileMetaData meta;<br>  meta.number = versions_-&gt;<span class="hljs-built_in">NewFileNumber</span>();<br>  pending_outputs_.<span class="hljs-built_in">insert</span>(meta.number);<br>  Iterator* iter = mem-&gt;<span class="hljs-built_in">NewIterator</span>();<br>  <span class="hljs-built_in">Log</span>(options_.info_log, <span class="hljs-string">&quot;Level-0 table #%llu: started&quot;</span>,<br>      (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span>)meta.number);<br><br>  Status s;<br>  &#123;<br>    mutex_.<span class="hljs-built_in">Unlock</span>();<br>    <span class="hljs-comment">// 将 Immutable MemTable 写入到文件中</span><br>    s = <span class="hljs-built_in">BuildTable</span>(dbname_, env_, options_, table_cache_, iter, &amp;meta);<br>    mutex_.<span class="hljs-built_in">Lock</span>();<br>  &#125;<br><br>  <span class="hljs-built_in">Log</span>(options_.info_log, <span class="hljs-string">&quot;Level-0 table #%llu: %lld bytes %s&quot;</span>,<br>      (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span>)meta.number, (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span>)meta.file_size,<br>      s.<span class="hljs-built_in">ToString</span>().<span class="hljs-built_in">c_str</span>());<br>  <span class="hljs-keyword">delete</span> iter;<br>  pending_outputs_.<span class="hljs-built_in">erase</span>(meta.number);<br><br>  <span class="hljs-comment">// Note that if file_size is zero, the file has been deleted and</span><br>  <span class="hljs-comment">// should not be added to the manifest.</span><br>  <span class="hljs-type">int</span> level = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">ok</span>() &amp;&amp; meta.file_size &gt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-type">const</span> Slice min_user_key = meta.smallest.<span class="hljs-built_in">user_key</span>();<br>    <span class="hljs-type">const</span> Slice max_user_key = meta.largest.<span class="hljs-built_in">user_key</span>();<br>    <span class="hljs-keyword">if</span> (base != <span class="hljs-literal">nullptr</span>) &#123;<br>      <span class="hljs-comment">// 在所有无文件和该 SSTable 不发生 key 重叠的 Level 中</span><br>      <span class="hljs-comment">// 选择一个最大的 Level 插入该文件</span><br>      level = base-&gt;<span class="hljs-built_in">PickLevelForMemTableOutput</span>(min_user_key, max_user_key);<br>    &#125;<br>    <span class="hljs-comment">// 将文件加入到文件列表中</span><br>    edit-&gt;<span class="hljs-built_in">AddFile</span>(level, meta.number, meta.file_size, meta.smallest,<br>                  meta.largest);<br>  &#125;<br><br>  CompactionStats stats;<br>  stats.micros = env_-&gt;<span class="hljs-built_in">NowMicros</span>() - start_micros;<br>  stats.bytes_written = meta.file_size;<br>  stats_[level].<span class="hljs-built_in">Add</span>(stats);<br>  <span class="hljs-keyword">return</span> s;<br>&#125;<br></code></pre></td></tr></table></figure><p>将 <em>MemTable</em> 中的内容写入到 SSTable 中的过程在 <code>BuildTable</code> 中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// builder.cc</span><br><span class="hljs-function">Status <span class="hljs-title">BuildTable</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; dbname, Env* env, <span class="hljs-type">const</span> Options&amp; options,</span></span><br><span class="hljs-params"><span class="hljs-function">                  TableCache* table_cache, Iterator* iter, FileMetaData* meta)</span> </span>&#123;<br>  Status s;<br>  meta-&gt;file_size = <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">// 移动到 SkipList 中第一个元素的位置</span><br>  iter-&gt;<span class="hljs-built_in">SeekToFirst</span>();<br><br>  <span class="hljs-comment">// 创建文件</span><br>  std::string fname = <span class="hljs-built_in">TableFileName</span>(dbname, meta-&gt;number);<br>  <span class="hljs-keyword">if</span> (iter-&gt;<span class="hljs-built_in">Valid</span>()) &#123;<br>    WritableFile* file;<br>    s = env-&gt;<span class="hljs-built_in">NewWritableFile</span>(fname, &amp;file);<br>    <span class="hljs-keyword">if</span> (!s.<span class="hljs-built_in">ok</span>()) &#123;<br>      <span class="hljs-keyword">return</span> s;<br>    &#125;<br><br>    TableBuilder* builder = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TableBuilder</span>(options, file);<br>    <span class="hljs-comment">// SkipList 中的数据是按照顺序排列的</span><br>    <span class="hljs-comment">// 因此第一个键就是其最小的键</span><br>    meta-&gt;smallest.<span class="hljs-built_in">DecodeFrom</span>(iter-&gt;<span class="hljs-built_in">key</span>());<br>    Slice key;<br>    <span class="hljs-comment">// 不断地将 SkipList 中的数据插入到 TableBuilder 中</span><br>    <span class="hljs-keyword">for</span> (; iter-&gt;<span class="hljs-built_in">Valid</span>(); iter-&gt;<span class="hljs-built_in">Next</span>()) &#123;<br>      key = iter-&gt;<span class="hljs-built_in">key</span>();<br>      builder-&gt;<span class="hljs-built_in">Add</span>(key, iter-&gt;<span class="hljs-built_in">value</span>());<br>    &#125;<br>    <span class="hljs-comment">// 最后一个键就是最大的键</span><br>    <span class="hljs-keyword">if</span> (!key.<span class="hljs-built_in">empty</span>()) &#123;<br>      meta-&gt;largest.<span class="hljs-built_in">DecodeFrom</span>(key);<br>    &#125;<br><br>    <span class="hljs-comment">// Finish and check for builder errors</span><br>    <span class="hljs-comment">// Finish 时会写入索引部分的数据</span><br>    <span class="hljs-comment">// 包括 FilterBlock、MetaIndexBlock、IndexBlock 以及 Footer</span><br>    s = builder-&gt;<span class="hljs-built_in">Finish</span>();<br>    <br>    <span class="hljs-comment">// 一些检查文件状态的代码</span><br>    ...<br>  <span class="hljs-keyword">return</span> s;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 <code>BuildTable</code> 函数中， <em>MemTable</em> 中的内容被不断添加到 <em>TableBuilder</em> 中。当 <em>MemTable</em> 中的数据都被添加到了 <em>TableBuilder</em> 中后，SSTable 中数据部分就已经写入完成了。随后调用 <em>TableBuilder</em> 的 <code>Finish</code> 函数，这个函数会写入索引部分的块，包括 FilterBlock（可选）、 MetaIndexBlock、 IndexBlock 以及 Footer 。写入完成后，程序会对新生成文件的状态进行一些检查，通过检查后文件会被添加到内存的文件列表中，供查询使用。</p><p>下面我们看看数据在 <em>TableBuilder</em> 中是如何被编码的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// table_builder.cc</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TableBuilder::Add</span><span class="hljs-params">(<span class="hljs-type">const</span> Slice&amp; key, <span class="hljs-type">const</span> Slice&amp; value)</span> </span>&#123;<br>  Rep* r = rep_;<br>  <span class="hljs-built_in">assert</span>(!r-&gt;closed);<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">ok</span>()) <span class="hljs-keyword">return</span>;<br>  <span class="hljs-comment">// 保证插入是有序的</span><br>  <span class="hljs-keyword">if</span> (r-&gt;num_entries &gt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-built_in">assert</span>(r-&gt;options.comparator-&gt;<span class="hljs-built_in">Compare</span>(key, <span class="hljs-built_in">Slice</span>(r-&gt;last_key)) &gt; <span class="hljs-number">0</span>);<br>  &#125;<br><br>  <span class="hljs-comment">// 如果当前内存中的 Block 是空的，那么就为这个 Block 生成一个 IndexKey</span><br>  <span class="hljs-comment">// 这个 IndexKey 不一定会出现在用户写入的数据中，而是根据计算得出的</span><br>  <span class="hljs-comment">// 可以将这个 Block 和上一个 Block 分开的最短的 Key</span><br>  <span class="hljs-comment">// 例如上一个 Block 的 IndexKey 是 &quot;the great&quot;， 当前 Block 插入的第一个</span><br>  <span class="hljs-comment">// key 为 &quot;the hello&quot; ，那么这个 IndexKey 需要满足</span><br>  <span class="hljs-comment">// &quot;the great&quot; &lt; IndexKey &lt;= &quot;the hello&quot;</span><br>  <span class="hljs-comment">// 例如，其值可能是 &quot;the h&quot;</span><br>  <span class="hljs-keyword">if</span> (r-&gt;pending_index_entry) &#123;<br>    <span class="hljs-built_in">assert</span>(r-&gt;data_block.<span class="hljs-built_in">empty</span>());<br>    r-&gt;options.comparator-&gt;<span class="hljs-built_in">FindShortestSeparator</span>(&amp;r-&gt;last_key, key);<br>    std::string handle_encoding;<br>    r-&gt;pending_handle.<span class="hljs-built_in">EncodeTo</span>(&amp;handle_encoding);<br>    <span class="hljs-comment">// 将这个 IndexKey 记录到 index block 中</span><br>    r-&gt;index_block.<span class="hljs-built_in">Add</span>(r-&gt;last_key, <span class="hljs-built_in">Slice</span>(handle_encoding));<br>    r-&gt;pending_index_entry = <span class="hljs-literal">false</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// 如果需要生成 BloomFilter ，则将这个数据编码进 BloomFilter 中</span><br>  <span class="hljs-keyword">if</span> (r-&gt;filter_block != <span class="hljs-literal">nullptr</span>) &#123;<br>    r-&gt;filter_block-&gt;<span class="hljs-built_in">AddKey</span>(key);<br>  &#125;<br><br>  r-&gt;last_key.<span class="hljs-built_in">assign</span>(key.<span class="hljs-built_in">data</span>(), key.<span class="hljs-built_in">size</span>());<br>  r-&gt;num_entries++;<br>  <span class="hljs-comment">// 将数据编码进 DataBlock 中</span><br>  r-&gt;data_block.<span class="hljs-built_in">Add</span>(key, value);<br><br>  <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> estimated_block_size = r-&gt;data_block.<span class="hljs-built_in">CurrentSizeEstimate</span>();<br>  <span class="hljs-comment">// 如果 DataBlock 的大小大于阈值（默认为 4KB），则将这个 DataBlock 刷到磁盘上</span><br>  <span class="hljs-keyword">if</span> (estimated_block_size &gt;= r-&gt;options.block_size) &#123;<br>    <span class="hljs-built_in">Flush</span>();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这里，数据还是没有被直接编码，而是被插入到了 <em>DataBlock</em> 中。如果一个 <em>DataBlock</em> 的大小超过了阈值（默认为 4KB），那么它就会被刷到文件中。除了插入数据，<code>Add</code> 函数还做了其他的事情：在 <em>IndexBlock</em> 中为本 <em>DataBlock</em> 生成一个 <em>IndexKey</em> ，这个 <em>IndexKey</em> 不一定会出现在用户插入的数据中，而是一个计算出来的最短的可以区别两个 <em>DataBlock</em> 的 key 。如果用户在配置中开启了布隆过滤器，那么在这个函数中也会将 key 编码到 <em>FilterBlock</em> 中。</p><p>在 <em>DataBlock</em> 的 <code>Add</code> 函数中，真正执行了对数据的编码。下面我们来看看这个函数是如何执行的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// block_builder.cc</span><br><span class="hljs-comment">// BlockBuilder 会寻找不同 key 之间可以共享的部分，以此进行压缩</span><br><span class="hljs-comment">// 压缩只会对 key 进行，不会对 value 进行</span><br><span class="hljs-comment">// 压缩后的格式为</span><br><span class="hljs-comment">// &lt;与前一个 key 的共享长度&gt;&lt;不共享的长度&gt;&lt;value 的长度&gt;&lt;key 不共享的部分&gt;&lt;value&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">BlockBuilder::Add</span><span class="hljs-params">(<span class="hljs-type">const</span> Slice&amp; key, <span class="hljs-type">const</span> Slice&amp; value)</span> </span>&#123;<br>  <span class="hljs-function">Slice <span class="hljs-title">last_key_piece</span><span class="hljs-params">(last_key_)</span></span>;<br>  <span class="hljs-built_in">assert</span>(!finished_);<br>  <span class="hljs-built_in">assert</span>(counter_ &lt;= options_-&gt;block_restart_interval);<br>  <span class="hljs-built_in">assert</span>(buffer_.<span class="hljs-built_in">empty</span>()  <span class="hljs-comment">// No values yet?</span><br>         || options_-&gt;comparator-&gt;<span class="hljs-built_in">Compare</span>(key, last_key_piece) &gt; <span class="hljs-number">0</span>);<br>  <span class="hljs-comment">// 如果当前共享内容的键数目没有达到阈值，就寻找当前键和上一个键之间重叠的部分</span><br>  <span class="hljs-type">size_t</span> shared = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">if</span> (counter_ &lt; options_-&gt;block_restart_interval) &#123;<br>    <span class="hljs-comment">// See how much sharing to do with previous string</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> min_length = std::<span class="hljs-built_in">min</span>(last_key_piece.<span class="hljs-built_in">size</span>(), key.<span class="hljs-built_in">size</span>());<br>    <span class="hljs-keyword">while</span> ((shared &lt; min_length) &amp;&amp; (last_key_piece[shared] == key[shared])) &#123;<br>      shared++;<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// Restart compression</span><br>    restarts_.<span class="hljs-built_in">push_back</span>(buffer_.<span class="hljs-built_in">size</span>());<br>    counter_ = <span class="hljs-number">0</span>;<br>  &#125;<br>  <span class="hljs-comment">// 当前键和上一个键不重叠的大小</span><br>  <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> non_shared = key.<span class="hljs-built_in">size</span>() - shared;<br><br>  <span class="hljs-comment">// 将 &quot;&lt;shared&gt;&lt;non_shared&gt;&lt;value_size&gt;&quot; 编码到 buffer_ 中</span><br>  <span class="hljs-built_in">PutVarint32</span>(&amp;buffer_, shared);<br>  <span class="hljs-built_in">PutVarint32</span>(&amp;buffer_, non_shared);<br>  <span class="hljs-built_in">PutVarint32</span>(&amp;buffer_, value.<span class="hljs-built_in">size</span>());<br><br>  <span class="hljs-comment">// 将当前键不共享的部分以及 value 的内容编码到 buffer_ 中</span><br>  buffer_.<span class="hljs-built_in">append</span>(key.<span class="hljs-built_in">data</span>() + shared, non_shared);<br>  buffer_.<span class="hljs-built_in">append</span>(value.<span class="hljs-built_in">data</span>(), value.<span class="hljs-built_in">size</span>());<br><br>  <span class="hljs-comment">// 更新 last_key_</span><br>  last_key_.<span class="hljs-built_in">resize</span>(shared);<br>  last_key_.<span class="hljs-built_in">append</span>(key.<span class="hljs-built_in">data</span>() + shared, non_shared);<br>  <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">Slice</span>(last_key_) == key);<br>  counter_++;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 <em>BlockBuilder</em> 中，所有的数据都被一起编码到一个 buffer 中。但是中编码之前，程序会对 key 进行一次压缩。这个压缩是通过寻找当前 key 和上一个 key 之间共同的长度来完成的。当然，这个共享不会无限进行下去，每隔若干个 key ，程序会就重新开始计算共享键。例如，如果系统设置的共享键数目是 16 （默认值），那么第 1 个到第 16 个 key 之间是有内容共享的，第 16 个和第 17 个键则不计算其共享的内容，第 17 个键到第 32 键之间又继续计算其共享内容。这是因为最终数据会被编码成</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-section">&lt;SharedKeyLength&gt;</span> <span class="hljs-section">&lt;NonSharedKeyLength&gt;</span> <span class="hljs-section">&lt;ValueLength&gt;</span> <span class="hljs-section">&lt;NonSharedKeyContent&gt;</span> <span class="hljs-section">&lt;ValueContent&gt;</span><br></code></pre></td></tr></table></figure><p>的形式，因此读取一个键时，只能知道它与前一个键不共享部分的内容，如果要读取其完整值，则必须知道它与前一个键共享的内容。因此，我们需要一直往前找，直到找到一个 SharedKeyLength 为 0 的 key ，然后往后读，一直读到我们需要的 key 为止。如果整个 <em>DataBlock</em> 都一起共享键，那么每次我们读取一个键都要从这个 <em>DataBlock</em> 的第一个键开始读，效率非常低。为了避免这种情况， <em>DataBlock</em> 中键值的共享在每一个 Entry 中进行，每 16 个键（默认值）保存在一个 Entry 中，并且为每个 Entry 在文件中维护了一个 Restart Point ，用于指向这个 Entry 。这样，在读取一个 Key 时，只需要找到这个 Key 所在的 Entry ，然后从这个 Entry 的第一个 Key 开始读即可。这样在读取一个 Key 时既不会读取太多其他的 Key ，也可以有效压缩 Key 的大小 。最后需要注意的是，这里通过共享值的压缩方法只会对 Key 进行，对于 Value 则是不做任何处理直接编码进 buffer 中。</p><h1 id="SSTable-的读流程"><a href="#SSTable-的读流程" class="headerlink" title="SSTable 的读流程"></a>SSTable 的读流程</h1><p><em>SSTable</em> 的读流程其实就是写流程的逆过程。读流程的入口在 <em>table_cache.cc</em> 中的 <code>FindTable</code> 函数中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// table_cache.cc</span><br><span class="hljs-function">Status <span class="hljs-title">TableCache::FindTable</span><span class="hljs-params">(<span class="hljs-type">uint64_t</span> file_number, <span class="hljs-type">uint64_t</span> file_size,</span></span><br><span class="hljs-params"><span class="hljs-function">                             Cache::Handle** handle)</span> </span>&#123;<br>  Status s;<br>  <span class="hljs-type">char</span> buf[<span class="hljs-built_in">sizeof</span>(file_number)];<br>  <span class="hljs-built_in">EncodeFixed64</span>(buf, file_number);<br>  <span class="hljs-function">Slice <span class="hljs-title">key</span><span class="hljs-params">(buf, <span class="hljs-keyword">sizeof</span>(buf))</span></span>;<br>  <span class="hljs-comment">// 在 Cache 中查找是否缓存 SSTable 的 handle</span><br>  *handle = cache_-&gt;<span class="hljs-built_in">Lookup</span>(key);<br>  <span class="hljs-keyword">if</span> (*handle == <span class="hljs-literal">nullptr</span>) &#123;<br>  <span class="hljs-comment">// 如果没有缓存，就从磁盘中打开这个 SSTable</span><br>    std::string fname = <span class="hljs-built_in">TableFileName</span>(dbname_, file_number);<br>    RandomAccessFile* file = <span class="hljs-literal">nullptr</span>;<br>    Table* table = <span class="hljs-literal">nullptr</span>;<br>    s = env_-&gt;<span class="hljs-built_in">NewRandomAccessFile</span>(fname, &amp;file);<br>    <span class="hljs-keyword">if</span> (!s.<span class="hljs-built_in">ok</span>()) &#123;<br>      std::string old_fname = <span class="hljs-built_in">SSTTableFileName</span>(dbname_, file_number);<br>      <span class="hljs-keyword">if</span> (env_-&gt;<span class="hljs-built_in">NewRandomAccessFile</span>(old_fname, &amp;file).<span class="hljs-built_in">ok</span>()) &#123;<br>        s = Status::<span class="hljs-built_in">OK</span>();<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">ok</span>()) &#123;<br>    <span class="hljs-comment">// 打开文件，读取内容</span><br>      s = Table::<span class="hljs-built_in">Open</span>(options_, file, file_size, &amp;table);<br>    &#125;<br><br>    <span class="hljs-comment">// some check codes</span><br>    ...<br>  &#125;<br>  <span class="hljs-keyword">return</span> s;<br>&#125;<br></code></pre></td></tr></table></figure><p>在读取一个文件之前，程序首先会在 <em>TableCache</em> 查找有无该文件的 handle ，如果没有，才会从磁盘中读取这个文件。 <code>Table::Open</code> 函数从磁盘上读取这个文件的 <em>Footer</em> 和 <em>IndexBlock</em> ，如果文件有 <em>FilterBlock</em>，也会将 <em>MetaIndexBlock</em> 读入内存中。当这些数据都被读完后，程序会对读取的状态进行一些检查，通过检查后这个文件的 handle 就会被缓存在 <em>TableCache</em> 中，供其他过程使用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// table.cc</span><br><span class="hljs-function">Status <span class="hljs-title">Table::Open</span><span class="hljs-params">(<span class="hljs-type">const</span> Options&amp; options, RandomAccessFile* file,</span></span><br><span class="hljs-params"><span class="hljs-function">                   <span class="hljs-type">uint64_t</span> size, Table** table)</span> </span>&#123;<br>  *table = <span class="hljs-literal">nullptr</span>;<br>  <span class="hljs-keyword">if</span> (size &lt; Footer::kEncodedLength) &#123;<br>    <span class="hljs-keyword">return</span> Status::<span class="hljs-built_in">Corruption</span>(<span class="hljs-string">&quot;file is too short to be an sstable&quot;</span>);<br>  &#125;<br><br>  <span class="hljs-comment">// 读取 footer</span><br>  <span class="hljs-type">char</span> footer_space[Footer::kEncodedLength];<br>  Slice footer_input;<br>  Status s = file-&gt;<span class="hljs-built_in">Read</span>(size - Footer::kEncodedLength, Footer::kEncodedLength,<br>                        &amp;footer_input, footer_space);<br>  <span class="hljs-keyword">if</span> (!s.<span class="hljs-built_in">ok</span>()) <span class="hljs-keyword">return</span> s;<br><br>  Footer footer;<br>  s = footer.<span class="hljs-built_in">DecodeFrom</span>(&amp;footer_input);<br>  <span class="hljs-keyword">if</span> (!s.<span class="hljs-built_in">ok</span>()) <span class="hljs-keyword">return</span> s;<br><br>  <span class="hljs-comment">// 读取 index block</span><br>  BlockContents index_block_contents;<br>  ReadOptions opt;<br>  <span class="hljs-keyword">if</span> (options.paranoid_checks) &#123;<br>    opt.verify_checksums = <span class="hljs-literal">true</span>;<br>  &#125;<br>  s = <span class="hljs-built_in">ReadBlock</span>(file, opt, footer.<span class="hljs-built_in">index_handle</span>(), &amp;index_block_contents);<br><br>  <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">ok</span>()) &#123;<br>    <span class="hljs-comment">// We&#x27;ve successfully read the footer and the index block: we&#x27;re</span><br>    <span class="hljs-comment">// ready to serve requests.</span><br>    Block* index_block = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Block</span>(index_block_contents);<br>    Rep* rep = <span class="hljs-keyword">new</span> Table::Rep;<br>    rep-&gt;options = options;<br>    rep-&gt;file = file;<br>    rep-&gt;metaindex_handle = footer.<span class="hljs-built_in">metaindex_handle</span>();<br>    rep-&gt;index_block = index_block;<br>    rep-&gt;cache_id = (options.block_cache ? options.block_cache-&gt;<span class="hljs-built_in">NewId</span>() : <span class="hljs-number">0</span>);<br>    rep-&gt;filter_data = <span class="hljs-literal">nullptr</span>;<br>    rep-&gt;filter = <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-comment">// 生成新的 Table 对象，并且读取 BloomFilter</span><br>    *table = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Table</span>(rep);<br>    (*table)-&gt;<span class="hljs-built_in">ReadMeta</span>(footer);<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> s;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面是在 <code>Open</code> 函数中读取文件 <em>Footer</em> 和 <em>IndexBlock</em> 的代码，在 <code>table-&gt;ReadMeta</code> 中会读取文件的 <em>MetaIndexBlock</em>（如果存在的话）。</p><p>至此，一个文件的索引部分（除了 FilterBlock ）已经被加载到了内存中。下面让我们看看当我们需要从已经加载到了内存中的文件里读取一个具体的 Key 需要经过怎样的流程。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// table.cc</span><br><span class="hljs-function">Status <span class="hljs-title">Table::InternalGet</span><span class="hljs-params">(<span class="hljs-type">const</span> ReadOptions&amp; options, <span class="hljs-type">const</span> Slice&amp; k, <span class="hljs-type">void</span>* arg,</span></span><br><span class="hljs-params"><span class="hljs-function">                          <span class="hljs-type">void</span> (*handle_result)(<span class="hljs-type">void</span>*, <span class="hljs-type">const</span> Slice&amp;,</span></span><br><span class="hljs-params"><span class="hljs-function">                                                <span class="hljs-type">const</span> Slice&amp;))</span> </span>&#123;<br>  Status s;<br>  <span class="hljs-comment">// 从 IndexBlock 中找到可能保存搜索键 k 的 dataBlock 对应的 IndexKey</span><br>  Iterator* iiter = rep_-&gt;index_block-&gt;<span class="hljs-built_in">NewIterator</span>(rep_-&gt;options.comparator);<br>  iiter-&gt;<span class="hljs-built_in">Seek</span>(k);<br>  <span class="hljs-keyword">if</span> (iiter-&gt;<span class="hljs-built_in">Valid</span>()) &#123;<br>    Slice handle_value = iiter-&gt;<span class="hljs-built_in">value</span>();<br>    FilterBlockReader* filter = rep_-&gt;filter;<br>    BlockHandle handle;<br>    <span class="hljs-keyword">if</span> (filter != <span class="hljs-literal">nullptr</span> &amp;&amp; handle.<span class="hljs-built_in">DecodeFrom</span>(&amp;handle_value).<span class="hljs-built_in">ok</span>() &amp;&amp;<br>        !filter-&gt;<span class="hljs-built_in">KeyMayMatch</span>(handle.<span class="hljs-built_in">offset</span>(), k)) &#123;<br>    <span class="hljs-comment">// 如果 bloomFilter 存在，并且 BloomFilter 指示不存在这个 key ，查找失败</span><br>      <span class="hljs-comment">// Not found</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 构建一个前面在 IndexBlock 中找到的目标 Block 的 iterator</span><br>      Iterator* block_iter = <span class="hljs-built_in">BlockReader</span>(<span class="hljs-keyword">this</span>, options, iiter-&gt;<span class="hljs-built_in">value</span>());<br>      <span class="hljs-comment">// 通过 block iterator 查找键</span><br>      block_iter-&gt;<span class="hljs-built_in">Seek</span>(k);<br>      <span class="hljs-keyword">if</span> (block_iter-&gt;<span class="hljs-built_in">Valid</span>()) &#123;<br>        (*handle_result)(arg, block_iter-&gt;<span class="hljs-built_in">key</span>(), block_iter-&gt;<span class="hljs-built_in">value</span>());<br>      &#125;<br>      s = block_iter-&gt;<span class="hljs-built_in">status</span>();<br>      <span class="hljs-keyword">delete</span> block_iter;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">ok</span>()) &#123;<br>    s = iiter-&gt;<span class="hljs-built_in">status</span>();<br>  &#125;<br>  <span class="hljs-keyword">delete</span> iiter;<br>  <span class="hljs-keyword">return</span> s;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Table::InternalGet</code> 函数完成了在 <em>SSTable</em> 中查找的过程。首先程序会从 <em>IndexBlock</em> 找到可能保存搜索键 k 的 <em>DataBlock</em> 的 IndexKey （因为 <em>DataBlock</em> 是有序存放的，因此用二分查找即可找到），然后检查是否有布隆过滤器，有的话检查布隆过滤器中是否编码了这个键，如果没编码，那么代表这个数据不存在于这个 <em>SSTable</em> 中，查找失败；否则，如果布隆过滤器不存在或者布隆过滤器中编码了这一个 key ，那么就对前面在 <em>IndexBlock</em> 查找到的指向的 <em>DataBlock</em> 新建一个 iterator ，然后通过这个 iterator 找到这个键。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// block.cc</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Seek</span><span class="hljs-params">(<span class="hljs-type">const</span> Slice&amp; target)</span> <span class="hljs-keyword">override</span> </span>&#123;<br>  <span class="hljs-comment">// Binary search in restart array to find the last restart point</span><br>  <span class="hljs-comment">// with a key &lt; target</span><br>  <span class="hljs-type">uint32_t</span> left = <span class="hljs-number">0</span>;<br>  <span class="hljs-type">uint32_t</span> right = num_restarts_ - <span class="hljs-number">1</span>;<br>  <span class="hljs-type">int</span> current_key_compare = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">// 如果已经进行过查找了，那么就检查上一轮查找最终结束的位置是在当前 key 的左边还是右边</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Valid</span>()) &#123;<br>    <span class="hljs-comment">// If we&#x27;re already scanning, use the current position as a starting</span><br>    <span class="hljs-comment">// point. This is beneficial if the key we&#x27;re seeking to is ahead of the</span><br>    <span class="hljs-comment">// current position.</span><br>    current_key_compare = <span class="hljs-built_in">Compare</span>(key_, target);<br>    <span class="hljs-keyword">if</span> (current_key_compare &lt; <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-comment">// key_ is smaller than target</span><br>      left = restart_index_;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (current_key_compare &gt; <span class="hljs-number">0</span>) &#123;<br>      right = restart_index_;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// We&#x27;re seeking to the key we&#x27;re already at.</span><br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// 使用二分查找寻找这个 key 所在的位置</span><br>  <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>    <span class="hljs-type">uint32_t</span> mid = (left + right + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>    <span class="hljs-type">uint32_t</span> region_offset = <span class="hljs-built_in">GetRestartPoint</span>(mid);<br>    <span class="hljs-type">uint32_t</span> shared, non_shared, value_length;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* key_ptr =<br>        <span class="hljs-built_in">DecodeEntry</span>(data_ + region_offset, data_ + restarts_, &amp;shared,<br>                    &amp;non_shared, &amp;value_length);<br>    <span class="hljs-keyword">if</span> (key_ptr == <span class="hljs-literal">nullptr</span> || (shared != <span class="hljs-number">0</span>)) &#123;<br>      <span class="hljs-built_in">CorruptionError</span>();<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-function">Slice <span class="hljs-title">mid_key</span><span class="hljs-params">(key_ptr, non_shared)</span></span>;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Compare</span>(mid_key, target) &lt; <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-comment">// Key at &quot;mid&quot; is smaller than &quot;target&quot;.  Therefore all</span><br>      <span class="hljs-comment">// blocks before &quot;mid&quot; are uninteresting.</span><br>      left = mid;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// Key at &quot;mid&quot; is &gt;= &quot;target&quot;.  Therefore all blocks at or</span><br>      <span class="hljs-comment">// after &quot;mid&quot; are uninteresting.</span><br>      right = mid - <span class="hljs-number">1</span>;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// We might be able to use our current position within the restart block.</span><br>  <span class="hljs-comment">// This is true if we determined the key we desire is in the current block</span><br>  <span class="hljs-comment">// and is after than the current key.</span><br>  <span class="hljs-built_in">assert</span>(current_key_compare == <span class="hljs-number">0</span> || <span class="hljs-built_in">Valid</span>());<br>  <span class="hljs-comment">// 如果我们当前已经在这个 RestartPoint 指向的 Entry 里了（上一次查找）</span><br>  <span class="hljs-comment">// 并且我们要找的键就在这个 Entry 中，那么我们就可以不用 seek</span><br>  <span class="hljs-type">bool</span> skip_seek = left == restart_index_ &amp;&amp; current_key_compare &lt; <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">if</span> (!skip_seek) &#123;<br>  <span class="hljs-comment">// 跳转到 key 所在的 RestartPoint 指向的 Entry</span><br>    <span class="hljs-built_in">SeekToRestartPoint</span>(left);<br>  &#125;<br>  <span class="hljs-comment">// 在一个 Entry 中从头往后读</span><br>  <span class="hljs-comment">// Linear search (within restart block) for first key &gt;= target</span><br>  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">ParseNextKey</span>()) &#123;<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Compare</span>(key_, target) &gt;= <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面这段代码就是在 <em>BlockIterator</em> 中查找搜索 key 的过程。函数的主体是一个二分搜索，找到这个 key 所在的 Entry ，然后从这个 Entry 的第一个键开始顺序地往下读，直到读到我们要查找的 key 为止。</p><p>到这里 SSTable 的读写过程就解析完了，这里值得体会的是对文件分块分层次组织的过程，从 SSTable 到 DataBlock 再到 Entry ，多个数据层次使得文件写和文件读可以更高效。同时，将索引和数据放在一个文件里，使得索引和数据在删除与移动时都是一体的。</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>源代码阅读</category>
      
      <category>LevelDB</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>LevelDB 源代码阅读（四）：MemTable</title>
    <link href="/2021/07/15/leveldb-source-code-reading-4/"/>
    <url>/2021/07/15/leveldb-source-code-reading-4/</url>
    
    <content type="html"><![CDATA[<p>在 <a href="/2021/07/08/leveldb-source-code-reading-1/" title="LevelDB 源代码阅读（一）：写流程">LevelDB 源代码阅读（一）：写流程</a> 中，我们在介绍写入时最终讲到写入的数据被编码成 internalKey 然后被插入到 <em>SkipList</em> 中。在本文中，我们将结合 LevelDB 的源代码，详细介绍 MemTable 的结构。</p><h1 id="MemTable-基本结构"><a href="#MemTable-基本结构" class="headerlink" title="MemTable 基本结构"></a>MemTable 基本结构</h1><p>代码中有关于 <em>MemTable</em> 的定义和实现在 memtable.{h&#x2F;cc} 中，我们先从 <em>MemTable</em> 的定义开始了解其基础结构和功能。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// memtable.h</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MemTable</span> &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">MemTable</span><span class="hljs-params">(<span class="hljs-type">const</span> InternalKeyComparator&amp; comparator)</span></span>;<br><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Ref</span><span class="hljs-params">()</span> </span>&#123; ++refs_; &#125;<br><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Unref</span><span class="hljs-params">()</span> </span>&#123;<br>    --refs_;<br>    <span class="hljs-built_in">assert</span>(refs_ &gt;= <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (refs_ &lt;= <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">ApproximateMemoryUsage</span><span class="hljs-params">()</span></span>;<br>  <span class="hljs-function">Iterator* <span class="hljs-title">NewIterator</span><span class="hljs-params">()</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Add</span><span class="hljs-params">(SequenceNumber seq, ValueType type, <span class="hljs-type">const</span> Slice&amp; key,</span></span><br><span class="hljs-params"><span class="hljs-function">           <span class="hljs-type">const</span> Slice&amp; value)</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Get</span><span class="hljs-params">(<span class="hljs-type">const</span> LookupKey&amp; key, std::string* value, Status* s)</span></span>;<br>  <br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">KeyComparator</span> &#123;<br>    <span class="hljs-type">const</span> InternalKeyComparator comparator;<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">KeyComparator</span><span class="hljs-params">(<span class="hljs-type">const</span> InternalKeyComparator&amp; c)</span> : comparator(c) &#123;</span>&#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* a, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* b)</span> <span class="hljs-type">const</span></span>;<br>  &#125;;<br><br>  <span class="hljs-keyword">typedef</span> SkipList&lt;<span class="hljs-type">const</span> <span class="hljs-type">char</span>*, KeyComparator&gt; Table;<br><br>  ~<span class="hljs-built_in">MemTable</span>();<br><br>  KeyComparator comparator_;<br>  <span class="hljs-type">int</span> refs_;<br>  Arena arena_;<br>  Table table_;<br>&#125;<br></code></pre></td></tr></table></figure><p><em>MemTable</em> 是一个有引用计数的类型，当其引用计数为 0 时（除了刚创建时）就会从内存中删除。<code>Ref</code> 函数和 <code>Unref</code> 函数就是用以管理引用计数的函数。<code>ApproximateMemoryUsage</code> 函数会计算当前 <em>MemTable</em> 的内存占用值，但是这个值不是精确的。<code>NewIterator</code> 函数会返回一个 <em>Iterator</em> 对象，用以正序遍历 <em>MemTable</em> 中的数据。<code>Add</code> 函数和 <code>Get</code> 的函数则分别对应写数据和读数据，注意 <code>Add</code> 函数既包含了新增值或修改值，也包含删除值。在数据部分，<em>MemTable</em> 维护了四个私有变量：<em>comparator_<em>、</em>refs_<em>、</em>arena_</em> 和 <em>table_</em> 。<em>comparator_</em> 的定义就在 <em>MemTable</em> 中，它重载了 <code>()</code> 运算符，可以像函数一样被调用，主要用以比较 <em>MemTable</em> 中 key 的大小，以便对 key 进行排序。<em>refs_</em> 是一个整数类型的值，用以维护引用计数。<em>arena_</em> 是一个 <em>Arena</em> 对象，主要用于管理内存。<em>table_</em> 是一个 <em>SkipList</em> 类，是 <em>MemTable</em> 中实际存储数据的结构。</p><img src="Leveldb-internal_key.png" width=65%><p>在 <a href="/2021/07/08/leveldb-source-code-reading-1/" title="LevelDB 源代码阅读（一）：写流程">LevelDB 源代码阅读（一）：写流程</a> 中我们已经简要介绍过了 <em>MemTable</em> 的写入过程：写入的 key 和 value（删除则没有 value）以及写入操作对应的 sequence number 会编码成一个如图所示的 entry ，然后这个 entry 会被插入到 <em>table_</em> 中（即 SkipList 中）。关于 SkipList 的结构以及如何在 SkipList 中插入数据，我们在下面一节中描述。</p><p><em>MemTable</em> 的读操作代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// memtable.cc</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">MemTable::Get</span><span class="hljs-params">(<span class="hljs-type">const</span> LookupKey&amp; key, std::string* value, Status* s)</span> </span>&#123;<br>  Slice memkey = key.<span class="hljs-built_in">memtable_key</span>();<br>  <span class="hljs-function">Table::Iterator <span class="hljs-title">iter</span><span class="hljs-params">(&amp;table_)</span></span>;<br>  iter.<span class="hljs-built_in">Seek</span>(memkey.<span class="hljs-built_in">data</span>());<br>  <span class="hljs-keyword">if</span> (iter.<span class="hljs-built_in">Valid</span>()) &#123;<br>    <span class="hljs-comment">// entry format is:</span><br>    <span class="hljs-comment">//    klength  varint32</span><br>    <span class="hljs-comment">//    userkey  char[klength]</span><br>    <span class="hljs-comment">//    tag      uint64</span><br>    <span class="hljs-comment">//    vlength  varint32</span><br>    <span class="hljs-comment">//    value    char[vlength]</span><br>    <span class="hljs-comment">// Check that it belongs to same user key.  We do not check the</span><br>    <span class="hljs-comment">// sequence number since the Seek() call above should have skipped</span><br>    <span class="hljs-comment">// all entries with overly large sequence numbers.</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* entry = iter.<span class="hljs-built_in">key</span>();<br>    <span class="hljs-type">uint32_t</span> key_length;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* key_ptr = <span class="hljs-built_in">GetVarint32Ptr</span>(entry, entry + <span class="hljs-number">5</span>, &amp;key_length);<br>    <span class="hljs-keyword">if</span> (comparator_.comparator.<span class="hljs-built_in">user_comparator</span>()-&gt;<span class="hljs-built_in">Compare</span>(<br>            <span class="hljs-built_in">Slice</span>(key_ptr, key_length - <span class="hljs-number">8</span>), key.<span class="hljs-built_in">user_key</span>()) == <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-comment">// Correct user key</span><br>      <span class="hljs-type">const</span> <span class="hljs-type">uint64_t</span> tag = <span class="hljs-built_in">DecodeFixed64</span>(key_ptr + key_length - <span class="hljs-number">8</span>);<br>      <span class="hljs-keyword">switch</span> (<span class="hljs-built_in">static_cast</span>&lt;ValueType&gt;(tag &amp; <span class="hljs-number">0xff</span>)) &#123;<br>        <span class="hljs-keyword">case</span> kTypeValue: &#123;<br>          Slice v = <span class="hljs-built_in">GetLengthPrefixedSlice</span>(key_ptr + key_length);<br>          value-&gt;<span class="hljs-built_in">assign</span>(v.<span class="hljs-built_in">data</span>(), v.<span class="hljs-built_in">size</span>());<br>          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">case</span> kTypeDeletion:<br>          *s = Status::<span class="hljs-built_in">NotFound</span>(<span class="hljs-built_in">Slice</span>());<br>          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>代码中首先声明了一个 <em>table_</em> 的迭代器 <em>iter</em> ，然后调用迭代器的 <code>Seek</code> 函数，寻找 SkipList 中有对应 <em>Key</em> 的节点。由于 SkipList 是有序的，这里 <em>iter</em> 找到的节点是所有拥有待搜索键且其 sequence number 大于此次操作的 sequence number 的节点中 sequence number 最大的一个，因此其数据也是最新的。找到这个节点之后，将这个节点进行解析，获取其 key 的值以及节点对应的操作类型。如果节点对应的操作类型是 insert ，那么则返回 insert 对应的 value ；如果是 delete ，那么则返回空。</p><p>不难看出，<em>MemTable</em> 无论是写还是读，其涉及到的核心组件就是 SkipList 。那么 SkipList 是一种怎么样的数据结构呢，又是如何实现的呢，下面让我们一起来看一看。</p><h1 id="跳表-SkipList"><a href="#跳表-SkipList" class="headerlink" title="跳表 SkipList"></a>跳表 SkipList</h1><p>跳表的英文名称是 SkipList ，最早由 William Pugh 在论文 <a href="https://dl.acm.org/doi/abs/10.1145/78973.78977">SkipList: A Probabilistic Alternative to Balanaced Tree</a> 中提出。在 <a href="/2021/07/13/SkipList/" title="跳表：平衡树的概率替代方案">跳表：平衡树的概率替代方案</a> 一文中，笔者对 SkipList 这篇论文涉及到数据结构与算法的前半部分进行了翻译，有兴趣的读者可以自行阅读论文原文或者翻译。</p><p>简单来说，SkipList 就是有序链表加上索引。如图 1a ，这是一个顺序链表。虽然所有的元素已经排好序，但是如果我们想要从中查找一个元素，还是需要将所有元素遍历一遍，直到找到我们想要的元素为止。例如我们需要查找 19，那么总共需要遍历 7 个元素。</p><div style="font-size:11px; text-align:center; line-height: 0px"><img src="Figure1.png" width=65%><p><em>图 1</em></p></div><p>下面我们考虑给链表增加索引：如果隔一个元素，我们就增加一个索引，使其指向下一个具有索引的节点，那我们就获得了图 1b 所示的链表。在这个链表中进行查找，首先我们从高层指针开始查找，如果高层指针指向的下一个元素的值小于等于我们的预期值，那么我们就跳转到这个指针指向的元素；否则，我们就检查下一个层级的指针是否满足条件。如果我们已经在一级指针了，那么当前所在的元素就是我们要找的元素（如果元素存在）。如在图 1b 中我们要查找 19 ，那么经过的节点顺序是 头节点 -&gt; 6 -&gt; 9 -&gt; 17（17 的二级指针指向的下一个元素为 21 ，大于 19 ，因此我们转换到一级指针进行搜索）-&gt; 19 （19 的一级指针指向的下一个元素为 21 ，大于 19 ，那么此时所在的节点就是我们要搜索的节点）。不算头节点，总共遍历了 4 个元素。</p><p>那我们还可以继续优化吗？当然可以！我们先定义一个概念，一个拥有 n 个指针的链表节点称为 n 级节点。前面所述的情况有两种节点：一级节点和二级节点。我们可以在二级指针的基础上，增加一个三级指针，相当于三级索引。假如每隔 1 个元素，就有一个二级节点，其指向下一个级别大于等于二的节点；每隔三个元素，就有一个三级节点，其指向下一个为三的节点。这样，我们就得到了图 1c 的链表。搜索的顺序同样是从高级别指针开始向低级别指针搜索，在这个链表中查找 19 的路径为：头节点 -&gt; 9（在这里先检查三级指针指向的下一个元素，其值为 21 ，大于我们要搜索的 19 ，因此切换到二级指针进行检查） -&gt; 17 （在这里先检查二级指针，其指向的下一个元素的值为 21 ，大于我们要搜索的 19 ，因此切换到一级指针进行检查） -&gt; 19 （在这里检查一级指针指向的下一个元素，其值为 21 ，大于我们要搜索的 19 ，因此这个节点就是我们要搜索的节点）。加了三级指针以后，我们查找只遍历了 3 个节点。</p><p>除了三级指针，我们还可以继续加上更多级别的指针，如图 1d 就有 4 级指针，查找到 19 要遍历 3 个节点。在以上这几种情况中，拥有 50% 的结点为 1 级节点，25% 的结点为 2 级节点，12.5% 的结点为 3 级节点，6.25% 的结点为 4 级节点。我们定义一个链表的级别为其中所有节点中最高级的那个节点的级别，图 1 a-d 的四个链表分别对应了一级到四级链表。随着链表的级别升高，各种级别的节点的比例是可计算的，为 $1&#x2F;2^n$ ，其中 $n$ 为节点的级别。</p><div style="font-size:11px; text-align:center; line-height: 0px"><img src="Figure3.png" width=65%><p><em>图 2：跳表的插入流程</em></p></div><p>如果要遵循上面这种不同级别节点出现的位置都非常规律的规定（$n$ 级节点每隔 $2^n - 1$ 个节点出现一次），那么对链表进行插入和删除是非常麻烦的。跳表和这种索引链表的区别在于，跳表去掉了对不同级别的节点出现的位置的规定，仅要求它们的比例符合规定。如图 1e 就是一个跳表，其中不同级别节点出现的位置并不规定，但其总体分布遵循索引链表的分布。在插入时，一个新的节点的级别通过随机数进行生成，这个随机数的生成的分布要遵循索引链表的节点级别分布。生成节点后，我们通过搜索算法将这个节点插入，并设置好对应级别的指针，即完成了数据的插入。删除时先搜索到对应的节点并将其移除，然后设置好其他节点的指针即可。可以证明，跳表的搜索、插入和删除算法都是 $O(log(n))$ 的，其中 $n$ 为跳表中元素的数量。</p><p>跳表的理论分析就分析到这，下面让我们来看看在 LevelDB 中跳表是如何实现的。</p><h1 id="LevelDB-中的跳表"><a href="#LevelDB-中的跳表" class="headerlink" title="LevelDB 中的跳表"></a>LevelDB 中的跳表</h1><p>我们先来看看 <em>SkipList</em> 的声明：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// skiplist.h </span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Key, <span class="hljs-keyword">class</span> <span class="hljs-title class_">Comparator</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SkipList</span> &#123;<br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>;<br><br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-comment">// Create a new SkipList object that will use &quot;cmp&quot; for comparing keys,</span><br>  <span class="hljs-comment">// and will allocate memory using &quot;*arena&quot;.  Objects allocated in the arena</span><br>  <span class="hljs-comment">// must remain allocated for the lifetime of the skiplist object.</span><br>  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">SkipList</span><span class="hljs-params">(Comparator cmp, Arena* arena)</span></span>;<br><br>  <span class="hljs-built_in">SkipList</span>(<span class="hljs-type">const</span> SkipList&amp;) = <span class="hljs-keyword">delete</span>;<br>  SkipList&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> SkipList&amp;) = <span class="hljs-keyword">delete</span>;<br><br>  <span class="hljs-comment">// Insert key into the list.</span><br>  <span class="hljs-comment">// REQUIRES: nothing that compares equal to key is currently in the list.</span><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Insert</span><span class="hljs-params">(<span class="hljs-type">const</span> Key&amp; key)</span></span>;<br><br>  <span class="hljs-comment">// Returns true iff an entry that compares equal to key is in the list.</span><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Contains</span><span class="hljs-params">(<span class="hljs-type">const</span> Key&amp; key)</span> <span class="hljs-type">const</span></span>;<br><br>  <span class="hljs-comment">// Iteration over the contents of a skip list</span><br>  <span class="hljs-keyword">class</span> <span class="hljs-title class_">Iterator</span> &#123;<br>   <span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// Initialize an iterator over the specified list.</span><br>    <span class="hljs-comment">// The returned iterator is not valid.</span><br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Iterator</span><span class="hljs-params">(<span class="hljs-type">const</span> SkipList* list)</span></span>;<br><br>    <span class="hljs-comment">// Returns true iff the iterator is positioned at a valid node.</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Valid</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><br>    <span class="hljs-comment">// Returns the key at the current position.</span><br>    <span class="hljs-comment">// REQUIRES: Valid()</span><br>    <span class="hljs-function"><span class="hljs-type">const</span> Key&amp; <span class="hljs-title">key</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><br>    <span class="hljs-comment">// Advances to the next position.</span><br>    <span class="hljs-comment">// REQUIRES: Valid()</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Next</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">// Advances to the previous position.</span><br>    <span class="hljs-comment">// REQUIRES: Valid()</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Prev</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">// Advance to the first entry with a key &gt;= target</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Seek</span><span class="hljs-params">(<span class="hljs-type">const</span> Key&amp; target)</span></span>;<br><br>    <span class="hljs-comment">// Position at the first entry in list.</span><br>    <span class="hljs-comment">// Final state of iterator is Valid() iff list is not empty.</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SeekToFirst</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">// Position at the last entry in list.</span><br>    <span class="hljs-comment">// Final state of iterator is Valid() iff list is not empty.</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SeekToLast</span><span class="hljs-params">()</span></span>;<br><br>   <span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">const</span> SkipList* list_;<br>    Node* node_;<br>    <span class="hljs-comment">// Intentionally copyable</span><br>  &#125;;<br><br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-keyword">enum</span> &#123; kMaxHeight = <span class="hljs-number">12</span> &#125;;<br><br>  <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">GetMaxHeight</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> max_height_.<span class="hljs-built_in">load</span>(std::memory_order_relaxed);<br>  &#125;<br><br>  <span class="hljs-function">Node* <span class="hljs-title">NewNode</span><span class="hljs-params">(<span class="hljs-type">const</span> Key&amp; key, <span class="hljs-type">int</span> height)</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">RandomHeight</span><span class="hljs-params">()</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Equal</span><span class="hljs-params">(<span class="hljs-type">const</span> Key&amp; a, <span class="hljs-type">const</span> Key&amp; b)</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> (<span class="hljs-built_in">compare_</span>(a, b) == <span class="hljs-number">0</span>); &#125;<br><br>  <span class="hljs-comment">// Return true if key is greater than the data stored in &quot;n&quot;</span><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">KeyIsAfterNode</span><span class="hljs-params">(<span class="hljs-type">const</span> Key&amp; key, Node* n)</span> <span class="hljs-type">const</span></span>;<br><br>  <span class="hljs-comment">// Return the earliest node that comes at or after key.</span><br>  <span class="hljs-comment">// Return nullptr if there is no such node.</span><br>  <span class="hljs-comment">//</span><br>  <span class="hljs-comment">// If prev is non-null, fills prev[level] with pointer to previous</span><br>  <span class="hljs-comment">// node at &quot;level&quot; for every level in [0..max_height_-1].</span><br>  <span class="hljs-function">Node* <span class="hljs-title">FindGreaterOrEqual</span><span class="hljs-params">(<span class="hljs-type">const</span> Key&amp; key, Node** prev)</span> <span class="hljs-type">const</span></span>;<br><br>  <span class="hljs-comment">// Return the latest node with a key &lt; key.</span><br>  <span class="hljs-comment">// Return head_ if there is no such node.</span><br>  <span class="hljs-function">Node* <span class="hljs-title">FindLessThan</span><span class="hljs-params">(<span class="hljs-type">const</span> Key&amp; key)</span> <span class="hljs-type">const</span></span>;<br><br>  <span class="hljs-comment">// Return the last node in the list.</span><br>  <span class="hljs-comment">// Return head_ if list is empty.</span><br>  <span class="hljs-function">Node* <span class="hljs-title">FindLast</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><br>  <span class="hljs-comment">// Immutable after construction</span><br>  Comparator <span class="hljs-type">const</span> compare_;<br>  Arena* <span class="hljs-type">const</span> arena_;  <span class="hljs-comment">// Arena used for allocations of nodes</span><br><br>  Node* <span class="hljs-type">const</span> head_;<br><br>  <span class="hljs-comment">// Modified only by Insert().  Read racily by readers, but stale</span><br>  <span class="hljs-comment">// values are ok.</span><br>  std::atomic&lt;<span class="hljs-type">int</span>&gt; max_height_;  <span class="hljs-comment">// Height of the entire list</span><br><br>  <span class="hljs-comment">// Read/written only by Insert().</span><br>  Random rnd_;<br>&#125;;<br></code></pre></td></tr></table></figure><p>首先我们看 SkipList 暴露给外界的接口，总共只有两个：<code>Insert</code> 和 <code>Contains</code> 。因此，SkipList 实际上并不支持删除操作。在所有对外暴露的接口中，自由 <code>Insert</code> 可以修改 SkipList 的结构。一个 Node 一旦被插入了 SkipList 中，那么其就无法再被移除了。并且，在插入时要求跳表中不存在与待插入键相同键的节点。注意，这里的键并不是用户在插入时给出的原始键，而是包含了 sequence number 的 internalKey ，理论上每个 internalKey 都是独一无二的。<em>Iterator</em> 类实际上提供了遍历 SkipList 和在 SkipList 中进行搜索的功能。在 <em>MemTable</em> 的 <code>Get</code> 函数中，就是通过 <em>Iterator</em> 来实现的，因此也可以算作 SkipList 对外暴露的接口。当然，这个接口也不会修改 SkipList 内部节点的数据。</p><p>SkipList 内部的数据部分包含了六个对象：随机生成节点层级时的最大值 <em>kMaxHeight</em> 、用于比较不同键大小的比较器 <em>compare_</em> 、用于管理内存的 <em>arena_</em> 、跳表的头节点 <em>head_</em> 、当前跳表中所有节点的最高层级 <em>max_height_</em> 以及随机数生成器 <em>rnd_</em> 。在第二节中我们分析过，SkipList 的插入、删除（当然 LevelDB 中不包含删除）都是基于其查找功能实现的，因此我们就从 SkipList 查找的实现开始分析其源代码。</p><h2 id="Search"><a href="#Search" class="headerlink" title="Search"></a>Search</h2><div style="font-size:11px; text-align:center; line-height: 0px"><img src="Figure2.png" width=65%><p><em>图 3：跳表搜索算法伪代码</em></p></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// skiplist.h</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Key, <span class="hljs-keyword">class</span> <span class="hljs-title class_">Comparator</span>&gt;<br><span class="hljs-keyword">typename</span> SkipList&lt;Key, Comparator&gt;::Node*<br>SkipList&lt;Key, Comparator&gt;::<span class="hljs-built_in">FindGreaterOrEqual</span>(<span class="hljs-type">const</span> Key&amp; key,<br>                                              Node** prev) <span class="hljs-type">const</span> &#123;<br>  Node* x = head_;<br>  <span class="hljs-type">int</span> level = <span class="hljs-built_in">GetMaxHeight</span>() - <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    Node* next = x-&gt;<span class="hljs-built_in">Next</span>(level);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">KeyIsAfterNode</span>(key, next)) &#123;<br>      <span class="hljs-comment">// Keep searching in this list</span><br>      x = next;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">if</span> (prev != <span class="hljs-literal">nullptr</span>) prev[level] = x;<br>      <span class="hljs-keyword">if</span> (level == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> next;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// Switch to next list</span><br>        level--;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对比 SkipList 论文中给出的搜索算法的伪代码和 LevelDB 中 SkipList 的搜索算法，两者基本上是一致的。算法首先从头节点开始，从高级别指针开始搜索，如果当前指针指向的下一个元素小于等于待搜索的键，那么就移动到下一个节点中，继续检查这一级别的指针；如果下一个节点的值大于待搜索键，那么就搜索当前节点的下一个级别的指针。如果没有下一个级别的指针了，即 level 等于 0 ，那么当前节点就是我们要搜索的节点。如果跳表中有一个节点的键与待搜索键相同，那么这就是我们查找的结果；如果不存在这样的节点，那么最终搜索到的节点的键的值会大于待搜索键。和原始算法不一样的一点是，LevelDB 的实现中加入了一个 <em>Node</em>** 类型的 <em>prev</em> 变量。如果我们将最终搜索到的节点称为 <em>target_node</em> ，那么 <em>prev[i]</em> 就会指向跳表中位于 <em>target_node</em> 之前、距离 <em>target_node</em> 最近的级别大于等于 $i+1$ 的节点。如果在 <em>target_node</em> 之前没有级别大于 <em>prev[i]</em> 的节点，那么就会指向跳表的头节点。</p><h2 id="Insert"><a href="#Insert" class="headerlink" title="Insert"></a>Insert</h2><p>看完了 SkipList 的搜索过程，下面我们一起看看插入过程：</p><div style="font-size:11px; text-align:center; line-height: 0px"><img src="Figure4.png" width=40%><p><em>图 4：跳表插入算法伪代码</em></p></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// skiplist.h</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Key, <span class="hljs-keyword">class</span> <span class="hljs-title class_">Comparator</span>&gt;<br><span class="hljs-type">void</span> SkipList&lt;Key, Comparator&gt;::<span class="hljs-built_in">Insert</span>(<span class="hljs-type">const</span> Key&amp; key) &#123;<br>  <span class="hljs-comment">// TODO(opt): We can use a barrier-free variant of FindGreaterOrEqual()</span><br>  <span class="hljs-comment">// here since Insert() is externally synchronized.</span><br>  Node* prev[kMaxHeight];<br>  Node* x = <span class="hljs-built_in">FindGreaterOrEqual</span>(key, prev);<br><br>  <span class="hljs-comment">// Our data structure does not allow duplicate insertion</span><br>  <span class="hljs-built_in">assert</span>(x == <span class="hljs-literal">nullptr</span> || !<span class="hljs-built_in">Equal</span>(key, x-&gt;key));<br><br>  <span class="hljs-type">int</span> height = <span class="hljs-built_in">RandomHeight</span>();<br>  <span class="hljs-keyword">if</span> (height &gt; <span class="hljs-built_in">GetMaxHeight</span>()) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-built_in">GetMaxHeight</span>(); i &lt; height; i++) &#123;<br>      prev[i] = head_;<br>    &#125;<br>    <span class="hljs-comment">// It is ok to mutate max_height_ without any synchronization</span><br>    <span class="hljs-comment">// with concurrent readers.  A concurrent reader that observes</span><br>    <span class="hljs-comment">// the new value of max_height_ will see either the old value of</span><br>    <span class="hljs-comment">// new level pointers from head_ (nullptr), or a new value set in</span><br>    <span class="hljs-comment">// the loop below.  In the former case the reader will</span><br>    <span class="hljs-comment">// immediately drop to the next level since nullptr sorts after all</span><br>    <span class="hljs-comment">// keys.  In the latter case the reader will use the new node.</span><br>    max_height_.<span class="hljs-built_in">store</span>(height, std::memory_order_relaxed);<br>  &#125;<br><br>  x = <span class="hljs-built_in">NewNode</span>(key, height);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; height; i++) &#123;<br>    <span class="hljs-comment">// NoBarrier_SetNext() suffices since we will add a barrier when</span><br>    <span class="hljs-comment">// we publish a pointer to &quot;x&quot; in prev[i].</span><br>    x-&gt;<span class="hljs-built_in">NoBarrier_SetNext</span>(i, prev[i]-&gt;<span class="hljs-built_in">NoBarrier_Next</span>(i));<br>    prev[i]-&gt;<span class="hljs-built_in">SetNext</span>(i, x);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对比 SkipList 论文中给出的插入算法和 LevelDB 的实现，还是可以比较清晰地看明白的。首先找到插入的位置，并且通过 <em>prev</em>（伪代码中为 <em>update</em> ）记录各个级别的前驱节点。在 LevelDB 的实现中，不允许对同一个键进行两次插入，在断言中否定了这种情况，而在 SkipList 的伪代码中是允许这种情况的。找到待插入的位置后，为该节点分配一个级别，如果这个级别高于了当前跳表的级别，那么就需要对 <em>prev</em> 中高于跳表级别的指针进行处理，使其指向 <em>head_</em> 。完成好这些预备工作后，为当前键生成一个节点实例，然后将新节点的 $i$ 级指针设置为 $prev[i]$ 的 $i$ 级指针的值，而 $prev[i]$ 的 $i$ 级指针则更新为新生成的这个节点。处理好这些指针后，新的节点插入就算完成了。</p><h2 id="Contains"><a href="#Contains" class="headerlink" title="Contains"></a>Contains</h2><p>最后我们来看看 <code>Contains</code> 是如何实现的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// skiplist.h</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Key, <span class="hljs-keyword">class</span> <span class="hljs-title class_">Comparator</span>&gt;<br><span class="hljs-type">bool</span> SkipList&lt;Key, Comparator&gt;::<span class="hljs-built_in">Contains</span>(<span class="hljs-type">const</span> Key&amp; key) <span class="hljs-type">const</span> &#123;<br>  Node* x = <span class="hljs-built_in">FindGreaterOrEqual</span>(key, <span class="hljs-literal">nullptr</span>);<br>  <span class="hljs-keyword">if</span> (x != <span class="hljs-literal">nullptr</span> &amp;&amp; <span class="hljs-built_in">Equal</span>(key, x-&gt;key)) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个实际上就比较简单了，就是调用了搜索过程的函数，然后判断搜索到的节点的键是否等于搜索键即可。</p><p>到这里，SkipList 的基本内容就讲完了。SkipList 这个数据结构实际上就是在有序链表的基础上通过增加索引形成的一个数据结构，LevelDB 中的实现基本也是按照论文中的思路进行的。建议希望深入了解 SkipList 的读者去阅读其论文原文以及相关的研究论文。</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>源代码阅读</category>
      
      <category>LevelDB</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>跳表：平衡树的概率替代方案</title>
    <link href="/2021/07/13/SkipList/"/>
    <url>/2021/07/13/SkipList/</url>
    
    <content type="html"><![CDATA[<p>LevelDB 和一众 NoSQL 数据库都使用 LSM 树作为其存储模型，其中 MemTable 是非常重要的一个数据结构。在 LevelDB 的实现中，MemTable 是通过一种名为跳表（SkipList）来存储数据的。跳表最早由 William Pugh 在论文《SkipList: A Probabilistic Alternative to Balanaced Tree》 中提出，本文是对这篇论文前几节有关数据结构部分的翻译，有兴趣的读者可以直接去阅读<a href="https://dl.acm.org/doi/abs/10.1145/78973.78977">原文</a>。</p><h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>跳表是一种使用概率平衡而不是严格平衡的数据机构。因此，跳表的插入和删除算法都比平衡树中对应的算法都更简单且快速。</p><p><em>Skip lists are data structures that use probabilistic balancing rather than strictly enforced balancing. As a result, the algorithms for insertion and deletion in skip lists are much simpler and significantly faster than equivalent algorithms for balanced trees.</em></p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>二叉树可以用来表示如字典或者有序列表这样的抽象数据结构，当元素以随机顺序插入时它们能够运行得很好。一些如顺序插入元素这样的操作，会导致二叉树变成性能非常差的退化数据结构。如果允许讲待插入的元素列表进行随机打乱，那么二叉树在任何输入序列下大概率都会工作得很好。但是在大多数情况下，查询都必须在线返回，因此随机排列输入时不现实的。平衡树算法在执行插入操作时重新调整树的结构，以保持较好的平衡性并确保良好的性能。</p><p><em>Binary trees can be used for representing abstract data types such as dictionaries and ordered lists. They work well when the elements are inserted in a random order. Some sequences of operations, such as inserting the elements in order, produce degenerate data structures that perform very poorly. If it were possible to randomly permute the list of items to be inserted, trees would work well with high probability for any input sequence. In most cases queries must be answered online, so randomly permuting the input is impractical. Balanced tree algorithms rearrange the tree as operations are performed to maintain certain balance conditions and assure good performance.</em></p><p><strong>跳表</strong>是一种平衡树的概率替代方案，其通过查询随机数生成器来保持平衡。尽管在最坏情况下跳表的性能非常差，但是没有任何序列能一直导致跳表进入最坏的情况（就像快排的时候主元素的选择是随机的）。对于一个跳表来说，其结构变得非常不平衡的概率是非常小的（例如，对于一个有超过 250 元素的字典来说，一次搜索所花费的时间超过预期时间的三倍的可能性小于一百万分之一）。跳表拥有类似随机插入元素形成的搜索树的平衡性，但是它不需要插入时的元素是随机的。</p><p><em>Skip lists are a probabilistic alternative to balanced trees. Skip lists are balanced by consulting a random number generator. Although skip lists have bad worstcase performance, no input sequence consistently produces the worstcase performance (much like quicksort when the pivot element is chosen randomly). It is very unlikely a skip list data structure will be significantly unbalanced (e.g., for a dictionary of more than 250 elements, the chance that a search will take more than three-times the expecied time is less than one in a million). Skip lists have balance properties similar to that of search trees built by random insertions, yet do not require insertions to be random.</em></p><p>对于一个数据结构来说，保持概率性的平衡比保持严格的平衡要更加容易。对于大多数应用来说，跳表是一种比树更加自然的数据表示方式，并且使用跳表可以使算法更加简单。跳表的简洁性使得它们更容易实现，并且相较于平衡树和其他自平衡树算法，跳表提供了常数倍性能优化。跳表对空间的使用效率也非常高，它可以很轻易地通过配置来实现对平均只对 1 % （或者更少）的元素使用的指针，并且每个节点也不需要存储任何的平衡或优先级信息。</p><p><em>It is easier to balance a data structure probabilistitally than to explicitly maintain the balance. For many applications, skip lists are a more natural representation than trees, and they lead to simpler algorithms. The simplicity of skip list algorithms makes them easier to implement and provides significant constant factor speed improvements over balanced tree and self-adjusting tree algorithms. Skip lists are also very space efficient. They can easily be configured to require an average of 1% pointers per element (or even less) and do not require balance or priority information to be stored with each node.</em></p><h2 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h2><p>当我们在搜索一个链表时，有可能需要检查链表的每一个节点（如图 1a）。如果链表是按照顺序存放的，并且链表中的每两个节点都有一个指向位于它两个节点前的节点的指针（如图 1<br>b），我们就只需要检查不超过 $\lceil n &#x2F; 2 \rceil$ 个节点（其中 $n$ 是链表的长度）。同样的，假如每四个节点都有一个指针指向位于它四个节点前的节点的指针（如图 1c），那么就只需要检查 $\lceil n &#x2F; 4\rceil + 2$ 个节点。假如每 $(2^i)$ 个节点就有一个指针指向位于它 $(2^i)$ 个节点前的节点的指针，那么仅仅通过将指针数量加倍就可以使一次搜索所需要检查的节点个数可以减少到 $\lceil \log_2 n \rceil$ 。这样的一种数据结构可以用来进行快速查找，但是对它的插入和删除将变得很困难。</p><p><em>We might need to examine every node of the list when searching a linked list (Figure la). If the list is stored in sorted order and every other node of the list also has a pointer to the node two ahead of it in the list (Figure lb), we have to examine no more than $\lceil n&#x2F;2\rceil + 1$ nodes (where n is the length of the list). Also giving every fourth node a pointer four ahead (Figure lc) requires that no more than $\lceil n &#x2F; 4\rceil + 2$ nodes be examined. If every ($(2^i)$th node has a pointer $(2^i)$ nodes ahead (Figure 1d), the number of nodes that must be examined can be reduced to $\lceil \log_2 n \rceil$ while only doubling the number of pointers. This data structure could be used for fast searching, but insertion and deletion would be impractical.</em></p><div style="font-size:13px; text-align:center; line-height: 0px"><img src="Figure1.png"><p><em>Figure 1</em></p></div><p>如果一个节点拥有 k 个指向前面节点的指针，那么这个节点被称为 k 层节点。如果每 $2^i$ 个节点就有一个节点拥有一个指针指向 $2^i$ 个节点之前的那个节点，那么链表中节点的层级分布遵循这样一个简单的模式：50 % 的节点是 1 层节点，25 % 的节点是 2 层节点，12.5 % 的节点是 3 层节点，等等。假如节点的层级是随机选择的，但是所有节点的层级分布不变（如图 1e），会发生什么呢？一个节点的第 $i$ 个指针，指向了下一个 $i$ 层或高于 $i$ 层的节点，而不是位于前方 $2^{i-1}$ 节点之前的那个节点。插入或者删除只需要进行本地修改，一个节点的层级在它被插入时就被随机的选择，并且不需要再进行修改。有一些层级排布的情况会导致结构变得很差，但是我们会发现这样的情况是很少的。因为这样的数据结构是一种带着用以跳过中间节点的额外指针的链表，我把它称之为跳表。</p><p><em>A node that has k forward pointers is called a level k node. If every $(2^i)$th node has a pointer $2^i$ nodes ahead, then levels of nodes are distributed in a simple pattern: 50 percent are level 1, 25 percent are level 2, 12.5 percent are level 3 and so on. What would happen if the levels of nodes were chosen randomly, but in the same proportions (e.g., as in Figure 1e)? A node’s $i$ th forward pointer, instead of pointing $2^{i-1}$ nodes ahead, points to the next node of level $i$ or higher. Insertions or deletions would require only local modifications; the level of a node, chosen randomly when the node is inserted, need never change. Some arrangements of levels would give poor execution times, but we will see that such arrangements are rare. Because these data structures are linked lists with extra pointers that skip over intermediate nodes, I named them skip lists.</em></p><h2 id="跳表算法"><a href="#跳表算法" class="headerlink" title="跳表算法"></a>跳表算法</h2><p>这一节描述了对跳表算法来说如何进行查找，以及如何对一个字典或符号表中的元素进行插入和删除。搜索操作返回与目标键相关联的值的内容，当目标键不存在时操作会失败。插入操作将一个指定的键和一个新的值关联起来（如果这个键没有出现过，那么就将这个键插入到数据结构中）。删除操作会将指定的键删除。支持如寻找最小键或者寻找下一个键这样的附加操作是很容易的。</p><p><em>This section describes how to search for algorithms and to insert and delete elements in a dictionary or symbol table. The Search operation returns the contents of the value associated with the desired key or failure if the key is not present. The Insert operation associates a specified key with a new value (inserting the key if it had not already been present). The Delete operation deletes the specified key. It is easy to support additional operations such as “find the minimum key” or “find the next key.”</em></p><p>每个元素由一个节点表示，节点的层级在它被插入时随机地选择，选择的时候无需考虑数据结构中的元素数量。一个 $i$ 层节点有 $i$ 个前向指针（计数从 1 开始一直到 $i$）。我们不需要在节点中记录这个节点属于哪个层级，跳表的级别是表中所有节点的最大级别（如果跳表是空的，那么表的级别为 1），头节点中高于当前链表最大层级的指针指向 NIL （即尾结点，例如头节点有 10 个指针，当前跳表的级别为 6 ，那么头节点中的第 7 到 10 个指针都指向 NIL）。</p><p><em>Each element is represented by a node, the level of which is chosen randomly when the node is inserted without regard for the number of elements in the data structure. A level $i$ node has $i$ forward pointers, indexed 1 through i. We do not need to store the level of a node in the node. Levels are capped at some appropriate con- stant MaxLevel. The level of a list is the maximum level currently in the list (or 1 if the list is empty). The header of a list has forward pointers at levels one through MaxLevel. The forward pointers of the header at levels higher than the current maximum level of the list point to NIL.</em></p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>申请一个 NIL 节点，并对这个节点赋予一个比任何键都大的值。所有层级的所有跳表都以 NIL 节点作为结尾。一个新的链表被初始化成这个链表的层级是 1 ，并且链表中头节点的所有指针都指向 NIL 。</p><p><em>An element NIL is allocated and given a key greater than any legal key. All levels of all skip lists are terminated with NIL. A new list is initialized so that the level of the list is equal to 1 and all forward pointers of the list’s header point to NIL.</em></p><h3 id="搜索算法"><a href="#搜索算法" class="headerlink" title="搜索算法"></a>搜索算法</h3><p>我们通过遍历所有不超过包含待搜索元素的节点的前向指针来实现搜索（如图 2）。如果当前层级的指针无法搜索到更多的内容，那么就会进行到下一个层级。当我们在层级 1 也无法搜索到更多内容，如果包含待搜索键的节点存在，那我们必然在这个节点中。</p><p><em>We search for an element by traversing forward pointers that do not overshoot the node containing the element being searched for (Figure 2). When no more progress can be made at the current level of forward pointers, the search moves down to the next level. When we can make no more progress at level 1, we must be immediately in front of the node that contains the desired element (if it is in the list).</em></p><div style="font-size:13px; text-align:center; line-height: 0px"><img src="Figure2.png" width=80%><p><em>Figure 2</em></p></div><h3 id="插入和删除算法"><a href="#插入和删除算法" class="headerlink" title="插入和删除算法"></a>插入和删除算法</h3><div style="font-size:13px; text-align:center; line-height: 0px"><img src="Figure3.png"><p><em>Figure 3</em></p></div><p>如果要插入或者删除一个节点，我们只需要进行搜索和拼接（如图 3）。图 4 给出了插入和删除的算法。我们维护一个名为 <em>update</em> 的向量，以便当搜索完成时（并且我们已经准备好进行拼接了），<em>update[i]</em> 保存了一个指向一个层级大于等于 $i$ 的节点的指针，并且这个节点位于插入或删除节点所在位置的左半边的最右侧。如果一个插入产生了一个节点，其层级比原本链表中层级最高的节点还高，那么我们就更新链表的层级，并且初始化 <em>update</em> 向量合适的部分。在删除后，我们检查这次删除是否删掉了链表中层级最高的节点，如果是，那么就需要更新链表的层级。</p><p><em>To insert or delete a node, we simply search and splice, as shown in Figure 3. Figure 4 gives algorithms for insertion and deletion. A vector update is maintained so that when the search is complete (and we are ready to perform the splice), update[i] contains a pointer to the rightmost node of level i or higher that is to the left of the location of the insertion&#x2F;deletion. If an insertion generates a node with a level greater than the previous maximum level of the list, we update the maximum level of the list and initialize the appropriate portions of the update vector. After each deletion, we check to see if we have deleted the maximum element of the list and if so, decrease the maximum level of the list.</em></p><div style="font-size:13px; text-align:center; line-height: 0px"><img src="Figure4.png"><p><em>Figure 4</em></p></div><h3 id="选择随机层级"><a href="#选择随机层级" class="headerlink" title="选择随机层级"></a>选择随机层级</h3><p>最初，我们讨论了一个概率分布：一半具有 $i$ 层级指针的节点也有 $i+1$ 层级指针。为了避免魔法数，我们说在具有 $i$ 层级指针的节点中有比例 $p$ 的节点也拥有 $i+1$ 层级指针（我们最初假设 $p$&#x3D;1&#x2F;2 进行讨论）。层级是有和图 5 等效的算法随机生成的，并且在生成时无需考虑链表中元素的个数。</p><p><em>Initially, we discussed a probability distribution where half of the nodes that have level i pointers also have level i + 1 pointers. To get away from magic constants, we say that a fraction p of the nodes with level i pointers also have level i + 1 pointers (see p &#x3D; 1&#x2F;2 for our original discussion). Levels are generated randomly by an algorithm equivalent to the one in Figure 5. Levels are generated without reference to the number of elements in the list.</em></p><h3 id="我们在哪一个层级开始搜索？定义-L-n"><a href="#我们在哪一个层级开始搜索？定义-L-n" class="headerlink" title="我们在哪一个层级开始搜索？定义 $L(n)$"></a>我们在哪一个层级开始搜索？定义 $L(n)$</h3><p>在一个以 $p&#x3D;1&#x2F;2$ 生成的有 16 个元素的跳表中，可能有 9 个元素在层级 1 ，3 个元素在层级 2 ，3 个元素在层级 3 ，以及一个元素在层级 14（这发生的概率很小，但是还是有可能发生）。我们应该怎么处理它？如果我们使用标准算法从层级 14 开始搜索，那么就需要做很多无用功。那我们该从哪里开始搜索呢？我们的分析表明，理想情况下，我们应该从层级 L （期望有 $1&#x2F;p$  个节点）开始搜索，这在 $L &#x3D; \log_{1&#x2F;p} n$ 时成立。因为我们会经常引用这个式子，因此我们用 $L(n)$ 来代表 $\log_{1&#x2F;p} n$ 。</p><p><em>In a skip list of 16 elements generated with p &#x3D; 1&#x2F;2, we might happen to have 9 elements of level 1; 3 elements of level 2; 3 elements of level 3; and 1 element of level 14 (this would be very unlikely, but it could happen). How should we handle this? If we use the standard algorithm and start our search at level 14, we will do a lot of useless work. Where should we start the search? Our analysis suggests that ideally we would start a search at the level L where we expect 1&#x2F;p nodes. This happens when $L &#x3D; \log_{1&#x2F;p} n$. Since we will be referring frequently to this formula, we will use L(n) to denote $\log_{1&#x2F;p} n$.</em> </p><p>想要解决一个节点有异常大的层级这个问题有很多方法。别担心，我们只需要简单地从链表的最高层开始搜索即可。正如我们将在分析中所见，一个含有 n 个元素的链表中的节点的最高层级远高于 $L(n)$ 的概率是非常小的，从链表的最高层开始搜索只会对搜索的预期时间增加一个微小的常数。这种方法就是这篇论文中描述的算法所采用的方法。</p><p><em>There are a number of solutions to the problem of deciding how to handle the case where there is an element with an unusually large level in the list. Don’t worry, be happy. Simply start a search at the highest level present in the list. As we will see in our analysis, the probability that the maximum level in a list of n elements is significantly larger than L(n) is very small. Starting a search at the maximum level in the list does not add more than a small constant to the expected search time. This is the approach used in the algorithms described in this paper.</em></p><p>使用少于你获取的信息。尽管一个元素有可能包含 14 个指针的位置，我们不需要将这个 14 个都用完，我们可以选择仅使用 L(n) 层。有多种方法可以实现这一点，但它们都会使算法复杂化并且不会显着提高性能，因此不推荐使用这种方法。</p><p><em>Use less than you are given. Although an element may contain room for 14 pointers, we do not need to use all 14. We can choose to utilize only L(n) levels. There are a number of ways to implement this, but they all complicate the algorithms and do not noticeably improve performance, so this approach is not recommended.</em></p><p>固定随机数产生器。如果我们生成的随机层级比链表中的当前层级级别大一以上，我们只需使用列表中当前的最大层级加一作为新节点的层级。在实践中和直觉上，这种改变似乎运作良好。 然而，它完全破坏了我们分析结果算法的能力，因为节点的层级不再是完全随机的。 虽然程序员可能会实现这种方法，但纯粹主义者应该避免它。</p><p><em>Fix the dice. If we generate a random level that is more than one greater than the current maximum level in the list, we simply use one plus the current maximum level in the list as the level of the new node. In practice and intuitively, this change seems to work well. However, it totally destroys our ability to analyze the resulting algorithms, since the level of a node is no longer completely random. Although programmers may implement this method, purists should avoid it.</em></p><h3 id="选择最大层级"><a href="#选择最大层级" class="headerlink" title="选择最大层级"></a>选择最大层级</h3><p>由于可以在 L(n) 处限制层级的最大值，因此我们应该选择 MaxLevel &#x3D; L(N)（其中 N 是跳表中元素数量的上限）。如果 p &#x3D; 1&#x2F;2，那么使用 MaxLevel &#x3D; 16 适用于最多包含 $2^{16}$ 个元素的数据结构。</p><p><em>Since we can safely cap levels at L(n), we should choose MaxLevel &#x3D; L(N) (where N is an upper bound on the number of elements in a skip list). If p &#x3D; 1&#x2F;2, using MaxLevel &#x3D; 16 is appropriate for data structures con taining up to $2^{16}$ elements.</em></p>]]></content>
    
    
    <categories>
      
      <category>论文阅读</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>LevelDB 源代码阅读（三）：预写日志</title>
    <link href="/2021/07/11/leveldb-source-code-reading-3/"/>
    <url>/2021/07/11/leveldb-source-code-reading-3/</url>
    
    <content type="html"><![CDATA[<p>在前面两篇文章中，我们介绍了 LevelDB 的写流程和读流程。原本准备这篇文章介绍 LevelDB 的 MemTable 结构，但是在 <a href="https://leveldb-handbook.readthedocs.io/zh/latest/index.html">LevelDB Handbook</a> 的内容编排中，MemTable 被放在了预写日志之后介绍。于是我也决定按照 Handbook 的顺序，先介绍预写日志，再介绍 MemTable 的结构。</p><h1 id="WAL：预写日志"><a href="#WAL：预写日志" class="headerlink" title="WAL：预写日志"></a>WAL：预写日志</h1><p>WAL 的英文全称为 Write-Ahead Log ，翻译过来就是预写日志。所谓预写，就是在正式地执行对数据的写操作前（插入或者删除），先将操作的内容通过日志记录下来，这么做的目的是为了防止因进程异常或者服务器异常导致的数据库异常。</p><img src="LSM.png" width=65%><p>我们考虑下面两种情况：</p><ul><li>日志未写完或者未开始写进程就异常退出</li><li>日志写完了，数据没写完或者没开始写进程异常退出</li><li>日志写完了，数据也写完了，进程异常退出</li></ul><p>第一种情况下，在数据库恢复时会看到一条不完整的日志（写到一半）或者看不到该条日志（没开始写），这种情况下可以认为这次写操作失败，数据库也不会恢复这次操作，保证了写操作的原子性。</p><p>第二种情况下，数据库在恢复时可以通过读取到的日志内容来恢复未完成的写操作，同样保证了原子性。</p><p>第三种情况就是正常的情况，数据库在恢复时无须进行任何操作。</p><p>因此，WAL 在这三种情况下都可以保证数据库写操作的原子性。对于 WAL 的更多知识，可以查看这篇<a href="https://martinfowler.com/articles/patterns-of-distributed-systems/wal.html">文章</a>。下面我们看看 WAL 在 LevelDB 中是如何实现的。</p><h1 id="LevelDB-中的-WAL-实现"><a href="#LevelDB-中的-WAL-实现" class="headerlink" title="LevelDB 中的 WAL 实现"></a>LevelDB 中的 WAL 实现</h1><h2 id="LevelDB-的日志结构"><a href="#LevelDB-的日志结构" class="headerlink" title="LevelDB 的日志结构"></a>LevelDB 的日志结构</h2><img src="Leveldb-WAL.png" width=80%><p>上图是 LevelDB 中日志的结构。日志被存储的最小单位是 Chunk，一个 Chunk 包含了四个部分：校验和 Checksum（4 个字节）、数据长度 Length （2 个字节），Chunk 类型 Type（1 个字节）以及数据内容，前三个部分被称为 ChunkHeader 。校验和是由数据类型以及数据内容计算出来的，使用的算法是 CRC 校验算法。Chunk 类型一共有 4 种：Full、First、Midlle、Last 。之所以需要有四种 Chunk 类型，是因为一条日志有可能因为大小太大而被存在多个 Chunk 当中。假如一条日志被存放在了一个 Chunk 当中，那么这个 Chunk 的类型就是 Full ；假如一条日志被存放在了多个 Chunk 当中，那么第一个 Chunk 的类型为 First ，最后一个 Chunk 的类型为 Last ，First 和 Last 之间包含了零个或多个 Middle 类型的 Chunk ，这些所有的 Chunk 中的数据组合起来就是日志的原始数据。</p><p>一个或多个 Chunk 会组成一个 Block 。一个 Block 是有大小限制的，上限是 32 KB，即 32768 个字节。当一个 Block 的大小达到了阈值后，这个 Block 就会被关闭，然后开启一个新的 Block 。如果我们往一个 Block 中写日志时，Block 中剩余的空间足够写下一个 ChunkHeader， 但无法容下这条日志的所有内容，那么就会写入一个类型为 First 的 Chunk，然后开启一个新的 Block ，将剩余的数据写在新 Block 中。我们可以推理出，假如一个 Chunk 的类型为 Middle，那么这个 Chunk 一定占据了一整个 Block （想想这是为什么）。</p><h2 id="写日志"><a href="#写日志" class="headerlink" title="写日志"></a>写日志</h2><p>LevelDB 中所有的写操作都会在 <code>DBImpl::Write</code> 函数中被处理，这当中也包含了对 WAL 的处理，代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// db_impl.cc</span><br><span class="hljs-function">Status <span class="hljs-title">DBImpl::Write</span><span class="hljs-params">(<span class="hljs-type">const</span> WriteOptions&amp; options, WriteBatch* updates)</span> </span>&#123;<br>  ... <span class="hljs-comment">// some code prepare for writing</span><br>  <span class="hljs-comment">// Write WAL</span><br>  status = log_-&gt;<span class="hljs-built_in">AddRecord</span>(WriteBatchInternal::<span class="hljs-built_in">Contents</span>(write_batch));<br>  <span class="hljs-type">bool</span> sync_error = <span class="hljs-literal">false</span>;<br>  <span class="hljs-keyword">if</span> (status.<span class="hljs-built_in">ok</span>() &amp;&amp; options.sync) &#123;<br>    status = logfile_-&gt;<span class="hljs-built_in">Sync</span>();<br>    <span class="hljs-keyword">if</span> (!status.<span class="hljs-built_in">ok</span>()) &#123;<br>      sync_error = <span class="hljs-literal">true</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (status.<span class="hljs-built_in">ok</span>()) &#123;<br>    <span class="hljs-comment">// insert the data to the memtable</span><br>    status = WriteBatchInternal::<span class="hljs-built_in">InsertInto</span>(write_batch, mem_);<br>  &#125;<br><br>  ... <span class="hljs-comment">// some code after write</span><br><br>  <span class="hljs-keyword">return</span> status;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，WAL 确实是在正式写数据之前完成的。 <code>WriteBatchInternal::Contents</code> 函数会将 WriteBatch 中的 rep_ 包装成 <em>Slice</em> 对象（关于 WriteBatch 和 Slice 的介绍，可以参考前面介绍 LevelDB 写流程的文章），然后传入 Writer 的 <code>AddRecord</code> 函数中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// log_writer.cc</span><br><span class="hljs-function">Status <span class="hljs-title">Writer::AddRecord</span><span class="hljs-params">(<span class="hljs-type">const</span> Slice&amp; slice)</span> </span>&#123;<br><span class="hljs-comment">// the data and length of the log</span><br>  <span class="hljs-type">const</span> <span class="hljs-type">char</span>* ptr = slice.<span class="hljs-built_in">data</span>();<br>  <span class="hljs-type">size_t</span> left = slice.<span class="hljs-built_in">size</span>();<br><br>  <span class="hljs-comment">// Fragment the record if necessary and emit it.  Note that if slice</span><br>  <span class="hljs-comment">// is empty, we still want to iterate once to emit a single</span><br>  <span class="hljs-comment">// zero-length record</span><br>  Status s;<br>  <span class="hljs-type">bool</span> begin = <span class="hljs-literal">true</span>;<br>  <span class="hljs-keyword">do</span> &#123;<br>    <span class="hljs-comment">// ------------ Begin of Code Fragment A -------------</span><br>  <span class="hljs-comment">// the left size of current block</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> leftover = kBlockSize - block_offset_;<br>    <span class="hljs-built_in">assert</span>(leftover &gt;= <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (leftover &lt; kHeaderSize) &#123;<br><span class="hljs-comment">// If the left space cannot write a chunk header</span><br>      <span class="hljs-comment">// Switch to a new block</span><br>      <span class="hljs-keyword">if</span> (leftover &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// Fill the trailer (literal below relies on kHeaderSize being 7)</span><br>        <span class="hljs-built_in">static_assert</span>(kHeaderSize == <span class="hljs-number">7</span>, <span class="hljs-string">&quot;&quot;</span>);<br>        dest_-&gt;<span class="hljs-built_in">Append</span>(<span class="hljs-built_in">Slice</span>(<span class="hljs-string">&quot;\x00\x00\x00\x00\x00\x00&quot;</span>, leftover));<br>      &#125;<br>      <span class="hljs-comment">// when switching to a new block, just set the offset in the block to 0</span><br>      block_offset_ = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-comment">// ------------ End of Code Fragment A -------------</span><br><br>    <span class="hljs-comment">// ------------ Begin of Code Fragment B -------------</span><br>    <span class="hljs-comment">// Invariant: we never leave &lt; kHeaderSize bytes in a block.</span><br>    <span class="hljs-built_in">assert</span>(kBlockSize - block_offset_ - kHeaderSize &gt;= <span class="hljs-number">0</span>);<br><br>    <span class="hljs-comment">// the size of space used for writing data</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> avail = kBlockSize - block_offset_ - kHeaderSize;<br>    <span class="hljs-comment">// if the fragment_length == left, current log can be completely written into this block</span><br>    <span class="hljs-comment">// else current log should be divided into several fragment</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> fragment_length = (left &lt; avail) ? left : avail;<br><br>    RecordType type;<br>    <span class="hljs-type">const</span> <span class="hljs-type">bool</span> end = (left == fragment_length);<br>    <span class="hljs-keyword">if</span> (begin &amp;&amp; end) &#123;<br>      type = kFullType;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (begin) &#123;<br>      type = kFirstType;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (end) &#123;<br>      type = kLastType;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      type = kMiddleType;<br>    &#125;<br>    <span class="hljs-comment">// ------------ End of Code Fragment B -------------</span><br><br>    <span class="hljs-comment">// ------------ Begin of Code Fragment C -------------</span><br>    <span class="hljs-comment">// write current chunk to disk</span><br>    s = <span class="hljs-built_in">EmitPhysicalRecord</span>(type, ptr, fragment_length);<br>    ptr += fragment_length;<br>    left -= fragment_length;<br>    begin = <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">// ------------ End of Code Fragment C -------------</span><br>  &#125; <span class="hljs-keyword">while</span> (s.<span class="hljs-built_in">ok</span>() &amp;&amp; left &gt; <span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">return</span> s;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码还是比较清晰的，A 段代码主要是在检查当前 Block 剩余空间大小：如果当前 Block 剩余的空间小于一个 ChunkHeader 的大小，那么就会把 Block 剩下的空间用 0 填满，然后切换到一个新的 Block 中。这里切换新 Block 的操作非常简单，就是将记录当前数据 offset 的变量置为 0 。 B 段代码则是在检查当前这条日志的写入情况：如果 Block 剩余的空间大小可以将这条日志写完，那么新加入的 Chunk 类型就为 Full ；否则一条日志可能要写在多个 Chunk 中，那么就根据当前写的情况将 Chunk 标志为 First、Middle 或者 Last 。C 段代码则是调用函数将当前这条 Chunk 提交并写入到磁盘中。值得注意的是，假如我们当前日志的内容为空，即变量 left 一开始就为 0，那么这段代码仍然会提交一个 data 段为空的 Chunk 。</p><p>下面我们来看看一个 Chunk 是如何被提交的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// log_writer.cc</span><br><span class="hljs-function">Status <span class="hljs-title">Writer::EmitPhysicalRecord</span><span class="hljs-params">(RecordType t, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* ptr,</span></span><br><span class="hljs-params"><span class="hljs-function">                                  <span class="hljs-type">size_t</span> length)</span> </span>&#123;<br>  <span class="hljs-built_in">assert</span>(length &lt;= <span class="hljs-number">0xffff</span>);  <span class="hljs-comment">// Must fit in two bytes</span><br>  <span class="hljs-built_in">assert</span>(block_offset_ + kHeaderSize + length &lt;= kBlockSize);<br><br>  <span class="hljs-comment">// Format the header</span><br>  <span class="hljs-comment">// The structure of Header</span><br>  <span class="hljs-comment">// CheckSum     4 Byte</span><br>  <span class="hljs-comment">// DataLength   2 Byte</span><br>  <span class="hljs-comment">// ChunkType    1 Byte</span><br>  <span class="hljs-type">char</span> buf[kHeaderSize];<br><span class="hljs-comment">// ------------ Start of Code Fragment A -------------</span><br>  <span class="hljs-comment">// Encode the DataLength</span><br>  buf[<span class="hljs-number">4</span>] = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">char</span>&gt;(length &amp; <span class="hljs-number">0xff</span>);<br>  buf[<span class="hljs-number">5</span>] = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">char</span>&gt;(length &gt;&gt; <span class="hljs-number">8</span>);<br>  <span class="hljs-comment">// Encode the ChunkType</span><br>  buf[<span class="hljs-number">6</span>] = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">char</span>&gt;(t);<br><br>  <span class="hljs-comment">// Compute the crc of the record type and the payload.</span><br>  <span class="hljs-type">uint32_t</span> crc = crc32c::<span class="hljs-built_in">Extend</span>(type_crc_[t], ptr, length);<br>  crc = crc32c::<span class="hljs-built_in">Mask</span>(crc);  <span class="hljs-comment">// Adjust for storage</span><br>  <span class="hljs-built_in">EncodeFixed32</span>(buf, crc);<br><span class="hljs-comment">// ------------ End of Code Fragment A -------------</span><br><br><span class="hljs-comment">// ------------ Start of Code Fragment B -------------</span><br>  <span class="hljs-comment">// Write the header and the payload</span><br>  Status s = dest_-&gt;<span class="hljs-built_in">Append</span>(<span class="hljs-built_in">Slice</span>(buf, kHeaderSize));<br>  <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">ok</span>()) &#123;<br>    s = dest_-&gt;<span class="hljs-built_in">Append</span>(<span class="hljs-built_in">Slice</span>(ptr, length));<br>    <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">ok</span>()) &#123;<br>    <span class="hljs-comment">// flush the chunk to disk</span><br>      s = dest_-&gt;<span class="hljs-built_in">Flush</span>();<br>    &#125;<br>  &#125;<br><span class="hljs-comment">// ------------ End of Code Fragment B -------------</span><br>  block_offset_ += kHeaderSize + length;<br>  <span class="hljs-keyword">return</span> s;<br>&#125;<br></code></pre></td></tr></table></figure><p>这一段代码分为两个部分：A 部分代码编码了 ChunkHeader ，我们可以看到校验和是通过 <code>crc32c::Extend</code> 和 <code>crc32c::Mask</code> 方法计算得到的，然后它们和 DataLength、 ChunkType 一起被编码进了 buf 中。B 部分将 ChunkHeader 和 Data 分别添加到了 dest_ 中。这里的 dest_ 是一个 <em>WritableFile</em> 对象，其 <code>Append</code> 的方法并不会将数据刷到文件中，而是保存在一个缓冲区中。当 Chunk Header 以及 Data 部分的数据都成功添加到了 dest_ 中后，就会调用其 <code>Flush</code> 方法，这个方法会将其缓冲区中的 Chunk 刷到磁盘上。有一点需要注意的是，在不同的操作系统下，dest_ 的具体类型会不同。<em>WritableFile</em> 是一个抽象类，在 Windows 下其实现为 <em>WindowsWritableFile</em>；在 Mac 和 Linux 系统下，其实现是 <code>PosixWritableFile</code> 。它们的区别在于写入数据时调用的系统调用不一样，编译时编译器会根据操作系统的信息来选择不同的实现。</p><h1 id="读日志"><a href="#读日志" class="headerlink" title="读日志"></a>读日志</h1><p>当系统在恢复时，需要读取硬盘上的日志然后恢复之前由于进程异常退出丢失的操作。下面我们来讲讲 LevelDB 是如何读取日志的。在前面写入日志时，代码都是中 log_writer.cc 中的。对应的，在读取日志时，也有一个 log_reader.cc 中的 <em>Reader</em> 类负责将日志读出并解析。在这个类中有一个函数 <code>ReadRecord</code> 直接读取下一条日志并返回，下面我们看看这个函数的内容</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// log_reader.cc</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Reader::ReadRecord</span><span class="hljs-params">(Slice* record, std::string* scratch)</span> </span>&#123;<br>  <span class="hljs-comment">// ------------ Start of Code Fragment A -------------</span><br>  <span class="hljs-comment">// 如果 last_record_offset_ 小于 initial_offset_</span><br>  <span class="hljs-comment">// 那么 initial_offset 大于 0，并且第一个 chunk 还没有被读取</span><br>  <span class="hljs-comment">// 所以直接跳转到第一个 chunk 开始的位置</span><br>  <span class="hljs-keyword">if</span> (last_record_offset_ &lt; initial_offset_) &#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">SkipToInitialBlock</span>()) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// scratch 用于缓存一条日志的数据</span><br>  scratch-&gt;<span class="hljs-built_in">clear</span>();<br>  record-&gt;<span class="hljs-built_in">clear</span>();<br>  <span class="hljs-type">bool</span> in_fragmented_record = <span class="hljs-literal">false</span>;<br>  <span class="hljs-comment">// Record offset of the logical record that we&#x27;re reading</span><br>  <span class="hljs-comment">// 0 is a dummy value to make compilers happy</span><br>  <span class="hljs-comment">// 记录当前正在读的这条日志在文件中的 offset</span><br>  <span class="hljs-type">uint64_t</span> prospective_record_offset = <span class="hljs-number">0</span>;<br><br>  Slice fragment;<br>  <span class="hljs-comment">// ------------ End of Code Fragment A -------------</span><br><br><br>  <span class="hljs-comment">// ------------ Start of Code Fragment B -------------</span><br>  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> record_type = <span class="hljs-built_in">ReadPhysicalRecord</span>(&amp;fragment);<br><br>    <span class="hljs-comment">// ReadPhysicalRecord may have only had an empty trailer remaining in its</span><br>    <span class="hljs-comment">// internal buffer. Calculate the offset of the next physical record now</span><br>    <span class="hljs-comment">// that it has returned, properly accounting for its header size.</span><br>    <span class="hljs-comment">// physical_record_offset 就是当前读出来的这个 chunk 在文件中开始的位置</span><br>    <span class="hljs-type">uint64_t</span> physical_record_offset =<br>        end_of_buffer_offset_ - buffer_.<span class="hljs-built_in">size</span>() - kHeaderSize - fragment.<span class="hljs-built_in">size</span>();<br><br>    <span class="hljs-keyword">if</span> (resyncing_) &#123;<br>      <span class="hljs-keyword">if</span> (record_type == kMiddleType) &#123;<br>        <span class="hljs-keyword">continue</span>;<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (record_type == kLastType) &#123;<br>        resyncing_ = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">continue</span>;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        resyncing_ = <span class="hljs-literal">false</span>;<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">switch</span> (record_type) &#123;<br>      <span class="hljs-keyword">case</span> kFullType:<br>        <span class="hljs-comment">// 如果读到了 FullType 的 Chunk,那么就已经读到了一整条日志，直接返回</span><br>        <span class="hljs-keyword">if</span> (in_fragmented_record) &#123;<br>          <span class="hljs-comment">// Handle bug in earlier versions of log::Writer where</span><br>          <span class="hljs-comment">// it could emit an empty kFirstType record at the tail end</span><br>          <span class="hljs-comment">// of a block followed by a kFullType or kFirstType record</span><br>          <span class="hljs-comment">// at the beginning of the next block.</span><br>          <span class="hljs-keyword">if</span> (!scratch-&gt;<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-built_in">ReportCorruption</span>(scratch-&gt;<span class="hljs-built_in">size</span>(), <span class="hljs-string">&quot;partial record without end(1)&quot;</span>);<br>          &#125;<br>        &#125;<br>        prospective_record_offset = physical_record_offset;<br>        scratch-&gt;<span class="hljs-built_in">clear</span>();<br>        *record = fragment;<br>        last_record_offset_ = prospective_record_offset;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>      <span class="hljs-keyword">case</span> kFirstType:<br>        <span class="hljs-comment">// 如果读到了 firstType 的 Chunk,那么就要将 in_fragmented_record 置为 true</span><br>        <span class="hljs-comment">// 然后继续往下读，直到读到了一条 Last 类型的 chunk</span><br>        <span class="hljs-keyword">if</span> (in_fragmented_record) &#123;<br>          <span class="hljs-comment">// Handle bug in earlier versions of log::Writer where</span><br>          <span class="hljs-comment">// it could emit an empty kFirstType record at the tail end</span><br>          <span class="hljs-comment">// of a block followed by a kFullType or kFirstType record</span><br>          <span class="hljs-comment">// at the beginning of the next block.</span><br>          <span class="hljs-keyword">if</span> (!scratch-&gt;<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-built_in">ReportCorruption</span>(scratch-&gt;<span class="hljs-built_in">size</span>(), <span class="hljs-string">&quot;partial record without end(2)&quot;</span>);<br>          &#125;<br>        &#125;<br>        prospective_record_offset = physical_record_offset;<br>        scratch-&gt;<span class="hljs-built_in">assign</span>(fragment.<span class="hljs-built_in">data</span>(), fragment.<span class="hljs-built_in">size</span>());<br>        in_fragmented_record = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">break</span>;<br><br>      <span class="hljs-keyword">case</span> kMiddleType:<br>        <span class="hljs-comment">// 如果读到了 Middle 类型的 Chunk,将内容添加进 scratch 中，然后接着往下读</span><br>        <span class="hljs-comment">// 直到读到了一条 Last 类型的 Chunk</span><br>        <span class="hljs-keyword">if</span> (!in_fragmented_record) &#123;<br>          <span class="hljs-built_in">ReportCorruption</span>(fragment.<span class="hljs-built_in">size</span>(),<br>                           <span class="hljs-string">&quot;missing start of fragmented record(1)&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          scratch-&gt;<span class="hljs-built_in">append</span>(fragment.<span class="hljs-built_in">data</span>(), fragment.<span class="hljs-built_in">size</span>());<br>        &#125;<br>        <span class="hljs-keyword">break</span>;<br><br>      <span class="hljs-keyword">case</span> kLastType:<br>        <span class="hljs-comment">// 读到了一条 Last 类型的日志，将这条日志的内容以及前面缓存的日志一起拼接起来</span><br>        <span class="hljs-comment">// 形成一条完整的日志并且返回</span><br>        <span class="hljs-keyword">if</span> (!in_fragmented_record) &#123;<br>          <span class="hljs-built_in">ReportCorruption</span>(fragment.<span class="hljs-built_in">size</span>(),<br>                           <span class="hljs-string">&quot;missing start of fragmented record(2)&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          scratch-&gt;<span class="hljs-built_in">append</span>(fragment.<span class="hljs-built_in">data</span>(), fragment.<span class="hljs-built_in">size</span>());<br>          *record = <span class="hljs-built_in">Slice</span>(*scratch);<br>          last_record_offset_ = prospective_record_offset;<br>          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">break</span>;<br><br>      <span class="hljs-keyword">case</span> kEof:<br>        <span class="hljs-keyword">if</span> (in_fragmented_record) &#123;<br>          <span class="hljs-comment">// This can be caused by the writer dying immediately after</span><br>          <span class="hljs-comment">// writing a physical record but before completing the next; don&#x27;t// scratch 用于缓存一条日志的数据</span><br>          <span class="hljs-comment">// treat it as a corruption, just ignore the entire logical record.</span><br>          scratch-&gt;<span class="hljs-built_in">clear</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>      <span class="hljs-keyword">case</span> kBadRecord:<br>        <span class="hljs-keyword">if</span> (in_fragmented_record) &#123;<br>          <span class="hljs-built_in">ReportCorruption</span>(scratch-&gt;<span class="hljs-built_in">size</span>(), <span class="hljs-string">&quot;error in middle of record&quot;</span>);<br>          in_fragmented_record = <span class="hljs-literal">false</span>;<br>          scratch-&gt;<span class="hljs-built_in">clear</span>();<br>        &#125;<br>        <span class="hljs-keyword">break</span>;<br><br>      <span class="hljs-keyword">default</span>: &#123;<br>        <span class="hljs-type">char</span> buf[<span class="hljs-number">40</span>];<br>        std::<span class="hljs-built_in">snprintf</span>(buf, <span class="hljs-built_in">sizeof</span>(buf), <span class="hljs-string">&quot;unknown record type %u&quot;</span>, record_type);<br>        <span class="hljs-built_in">ReportCorruption</span>(<br>            (fragment.<span class="hljs-built_in">size</span>() + (in_fragmented_record ? scratch-&gt;<span class="hljs-built_in">size</span>() : <span class="hljs-number">0</span>)),<br>            buf);<br>        in_fragmented_record = <span class="hljs-literal">false</span>;<br>        scratch-&gt;<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// ------------ End of Code Fragment B -------------</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个函数中主要分为两个部分，A 部分的代码主要是一些准备工作，例如将文件的 offset 移动到第一个 Chunk 的起始位置，清空缓冲区等；B 部分代码的工作是不断地读出下一个 Chunk 的内容，根据这个 Chunk 的类型来判断是否需要继续读下一个 Chunk（读到了 First 类型或者 Middle 类型的 Chunk）,如果一条日志的内容读取完了（读到了 Full 类型或者 Last 类型的 Chunk），就将缓冲区中的数据组装成一个 <em>Slice</em> 对象返回，这个对象中的内容就是一条逻辑日志的完整内容。</p><p>读取下一个 Chunk 的执行逻辑主要在 <code>ReadPhysicalRecord</code> 函数中，它的内容如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// log_reader.cc</span><br><span class="hljs-comment">// 从 buffer 中读取一个 Chunk，返回这个 chunk 的类型</span><br><span class="hljs-comment">// 如果当前 buffer 已经读完，则会从文件中读取下一个 Block 的内容到 buffer 中</span><br><span class="hljs-comment">// 如果文件的内容也被读完了，则返回 eof</span><br><span class="hljs-function"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-title">Reader::ReadPhysicalRecord</span><span class="hljs-params">(Slice* result)</span> </span>&#123;<br>  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-comment">// ------------ Start of Code Fragment A -------------</span><br>    <span class="hljs-comment">// 如果 buffer 中剩余的数据大小小于一个 ChunkHeader 的大小</span><br>    <span class="hljs-comment">// 则说明剩下的都是 trailer，直接跳到下一个 Block</span><br>    <span class="hljs-keyword">if</span> (buffer_.<span class="hljs-built_in">size</span>() &lt; kHeaderSize) &#123;<br>      <span class="hljs-keyword">if</span> (!eof_) &#123;<br>        <span class="hljs-comment">// Last read was a full read, so this is a trailer to skip</span><br>        buffer_.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-comment">// 读取下一个 Block</span><br>        Status status = file_-&gt;<span class="hljs-built_in">Read</span>(kBlockSize, &amp;buffer_, backing_store_);<br>        end_of_buffer_offset_ += buffer_.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span> (!status.<span class="hljs-built_in">ok</span>()) &#123;<br>          buffer_.<span class="hljs-built_in">clear</span>();<br>          <span class="hljs-built_in">ReportDrop</span>(kBlockSize, status);<br>          eof_ = <span class="hljs-literal">true</span>;<br>          <span class="hljs-keyword">return</span> kEof;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (buffer_.<span class="hljs-built_in">size</span>() &lt; kBlockSize) &#123;<br>          eof_ = <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">continue</span>;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// Note that if buffer_ is non-empty, we have a truncated header at the</span><br>        <span class="hljs-comment">// end of the file, which can be caused by the writer crashing in the</span><br>        <span class="hljs-comment">// middle of writing the header. Instead of considering this an error,</span><br>        <span class="hljs-comment">// just report EOF.</span><br>        buffer_.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-keyword">return</span> kEof;<br>      &#125;<br>    &#125;<br>    <span class="hljs-comment">// ------------ End of Code Fragment A -------------</span><br><br>    <span class="hljs-comment">// ------------ Start of Code Fragment B -------------</span><br>    <span class="hljs-comment">// Parse the header</span><br>    <span class="hljs-comment">// 获取当前 Chunk 的 type 和 data length</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* header = buffer_.<span class="hljs-built_in">data</span>();<br>    <span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span> a = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(header[<span class="hljs-number">4</span>]) &amp; <span class="hljs-number">0xff</span>;<br>    <span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span> b = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(header[<span class="hljs-number">5</span>]) &amp; <span class="hljs-number">0xff</span>;<br>    <span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> type = header[<span class="hljs-number">6</span>];<br>    <span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span> length = a | (b &lt;&lt; <span class="hljs-number">8</span>);<br><br>    <span class="hljs-comment">// 如果 Header 的大小加上数据部分的大小比 buffer 中数据的大小还大</span><br>    <span class="hljs-comment">// 说明数据的读取发生了异常，报告异常并返回</span><br>    <span class="hljs-keyword">if</span> (kHeaderSize + length &gt; buffer_.<span class="hljs-built_in">size</span>()) &#123;<br>      <span class="hljs-type">size_t</span> drop_size = buffer_.<span class="hljs-built_in">size</span>();<br>      buffer_.<span class="hljs-built_in">clear</span>();<br>      <span class="hljs-keyword">if</span> (!eof_) &#123;<br>        <span class="hljs-built_in">ReportCorruption</span>(drop_size, <span class="hljs-string">&quot;bad record length&quot;</span>);<br>        <span class="hljs-keyword">return</span> kBadRecord;<br>      &#125;<br>      <span class="hljs-comment">// If the end of the file has been reached without reading |length| bytes</span><br>      <span class="hljs-comment">// of payload, assume the writer died in the middle of writing the record.</span><br>      <span class="hljs-comment">// Don&#x27;t report a corruption.</span><br>      <span class="hljs-keyword">return</span> kEof;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (type == kZeroType &amp;&amp; length == <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-comment">// Skip zero length record without reporting any drops since</span><br>      <span class="hljs-comment">// such records are produced by the mmap based writing code in</span><br>      <span class="hljs-comment">// env_posix.cc that preallocates file regions.</span><br>      buffer_.<span class="hljs-built_in">clear</span>();<br>      <span class="hljs-keyword">return</span> kBadRecord;<br>    &#125;<br><br>    <span class="hljs-comment">// Check crc</span><br>    <span class="hljs-comment">// 检查校验和，如果校验和不对，那么也报告异常</span><br>    <span class="hljs-keyword">if</span> (checksum_) &#123;<br>      <span class="hljs-type">uint32_t</span> expected_crc = crc32c::<span class="hljs-built_in">Unmask</span>(<span class="hljs-built_in">DecodeFixed32</span>(header));<br>      <span class="hljs-type">uint32_t</span> actual_crc = crc32c::<span class="hljs-built_in">Value</span>(header + <span class="hljs-number">6</span>, <span class="hljs-number">1</span> + length);<br>      <span class="hljs-keyword">if</span> (actual_crc != expected_crc) &#123;<br>        <span class="hljs-comment">// Drop the rest of the buffer since &quot;length&quot; itself may have</span><br>        <span class="hljs-comment">// been corrupted and if we trust it, we could find some</span><br>        <span class="hljs-comment">// fragment of a real log record that just happens to look</span><br>        <span class="hljs-comment">// like a valid log record.</span><br>        <span class="hljs-type">size_t</span> drop_size = buffer_.<span class="hljs-built_in">size</span>();<br>        buffer_.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-built_in">ReportCorruption</span>(drop_size, <span class="hljs-string">&quot;checksum mismatch&quot;</span>);<br>        <span class="hljs-keyword">return</span> kBadRecord;<br>      &#125;<br>    &#125;<br>    <span class="hljs-comment">// ------------ End of Code Fragment B -------------</span><br><br>    <span class="hljs-comment">// ------------ Start of Code Fragment C -------------</span><br>    <span class="hljs-comment">// 读取成功，将当前 Block 的 offset 往前移动到下一条 Chunk 的开头</span><br>    buffer_.<span class="hljs-built_in">remove_prefix</span>(kHeaderSize + length);<br><br>    <span class="hljs-comment">// Skip physical record that started before initial_offset_</span><br>    <span class="hljs-keyword">if</span> (end_of_buffer_offset_ - buffer_.<span class="hljs-built_in">size</span>() - kHeaderSize - length &lt;<br>        initial_offset_) &#123;<br>      result-&gt;<span class="hljs-built_in">clear</span>();<br>      <span class="hljs-keyword">return</span> kBadRecord;<br>    &#125;<br><br>    *result = <span class="hljs-built_in">Slice</span>(header + kHeaderSize, length);<br>    <span class="hljs-keyword">return</span> type;<br>    <span class="hljs-comment">// ------------ End of Code Fragment C -------------</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码中，主要包含三部分逻辑。A 部分主要判断当前 Block 中是否还有下一条日志，如果没有则切换到下一个 Block 。如果无法读取下一个 Block 或者下一个 Block 的大小小于一个标准 Block 的大小（32 KB），则说明文件已经读完，将 eof 标志置为 true 。B 部分代码主要是根据还原 ChunkHeader,并且根据数据长度、校验和等信息判断 Chunk 中数据的正确性。程序运行到 C 部分代码则表示前面的读取和校验都没有问题，那么只需要将 buffer 的 offset 前移，然后将读取到的内容包装成一个 <em>Slice</em> 返回即可。以上三段代码便组成了从 Block 中读取一个 Chunk 的逻辑。</p><p>在 A 部分代码中，如果当前 buffer（即当前内存中的 Block）已经读到了末尾，那么就需要从文件中载入下一个 Block 。这里使用的函数是 <code>SequentialFile::Read</code> ，这个函数就是简单地使用系统调用从文件中读取了一段数据出来，因此也就不展开讲了。</p><p>到这里，LevelDB 的 WAL 日志就讲完了。应该说整个逻辑还是比较清晰易懂的，主要就是一些编解码的过程。仔细体会这个过程，对我们理解数据编码解码还是很有帮助的。</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>源代码阅读</category>
      
      <category>LevelDB</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>LevelDB 源代码阅读（二）：读流程</title>
    <link href="/2021/07/10/Leveldb-source-code-reading-2/"/>
    <url>/2021/07/10/Leveldb-source-code-reading-2/</url>
    
    <content type="html"><![CDATA[<p>在 <a href="/2021/07/08/leveldb-source-code-reading-1/" title="LevelDB 源代码阅读（一）：写流程">LevelDB 源代码阅读（一）：写流程</a> 中我们介绍了 LevelDB 的 LSM 树结构以及数据写入 LevelDB 的流程。本文我们将介绍从 LevelDB 中读取数据的流程。</p><h1 id="快照（Snapshot）"><a href="#快照（Snapshot）" class="headerlink" title="快照（Snapshot）"></a>快照（Snapshot）</h1><p>在介绍 LevelDB 的读流程之前，首先介绍一下<strong>快照（Snapshot）</strong>的概念。所谓快照，其实就是代表了数据库在某一个时刻的状态，LevelDB 中数据读取就是通过 Snapshot 机制来实现的。</p><p>LevelDB 的快照通过一个名为 <strong>sequence number</strong> 的整型数来实现。当数据被写入后，此次操作对应数据就不可再更改。假如我们在 LevelDB 中对一个键 <code>testkey</code> 赋一个值 <code>testvalue1</code>，那么这次操作对应的数据就会被存放在内存或磁盘上。假如我们又对 <code>testkey</code> 赋了一个新的值 <code>testvalue2</code>，那么前面操作的值无法修改，那么系统应该怎么去更新这个键所对应的值呢？答案是通过 sequence number 。LevelDB 维护了一个全局的 sequence number ，每次有写操作发生时这个 sequence number 就会加一。在写操作发生时，LevelDB 会为这个写操作分配一个 sequence number，其值就是当前系统中 sequence number 的值。在操作记录被持久化时，sequence number 也会通过一定的编码方式被持久化到数据中（详情看写流程的文章）。这样，新操作的 sequence number 永远会比旧操作的 sequence number 大。在读取数据时，我们就可以通过不同 sequence number 的值对应数据库历史上不同的状态。假如同时存在 sequence number 为 99、100、101 的三个操作记录，那么就会以 101 所对应的数据为当前数据库中所记录的数据。在进行文件合并（Compaction）时，对同一数据的不同操作记录会被消除，只保留 sequence number 最大的一条操作记录所对应的数据（假如此记录将数据从数据库中删除了，那么就无需保留任何数据）。</p><img src="leveldb-snapshot.png" width=50%><p>快照在代码中对应的类是 <em>SnapshotImpl</em> ，其内部保存了两个 SnapshotImpl 指针 prev 和 next，这和 SnapshotList 有关；另外还保存了一个 uint_64 类型的 sequence number。当用户创建一个快照时，LevelDB 会将系统中最新的 sequence number 值赋予这个 Snapshot ，这样用户通过这个 Snapshot 读取的数据就是系统中当前状态下的数据。在读数据时，所有读取到的数据会根据 Snapshot 的 sequence number 进行筛选，所有 seqnum 大于该 Snapshot 的 seqnum 的数据都会被剔除，剩下的记录中 seqnum 最大的那一个就是需要读取的数据。</p><h1 id="读操作"><a href="#读操作" class="headerlink" title="读操作"></a>读操作</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// db_impl.cc</span><br><span class="hljs-function">Status <span class="hljs-title">DBImpl::Get</span><span class="hljs-params">(<span class="hljs-type">const</span> ReadOptions&amp; options, <span class="hljs-type">const</span> Slice&amp; key,</span></span><br><span class="hljs-params"><span class="hljs-function">                   std::string* value)</span> </span>&#123;<br>  Status s;<br>  <span class="hljs-function">MutexLock <span class="hljs-title">l</span><span class="hljs-params">(&amp;mutex_)</span></span>;<br>  <span class="hljs-comment">// get the snapshot for read</span><br>  SequenceNumber snapshot;<br>  <span class="hljs-keyword">if</span> (options.snapshot != <span class="hljs-literal">nullptr</span>) &#123;<br>    snapshot =<br>        <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">const</span> SnapshotImpl*&gt;(options.snapshot)-&gt;<span class="hljs-built_in">sequence_number</span>();<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    snapshot = versions_-&gt;<span class="hljs-built_in">LastSequence</span>();<br>  &#125;<br><br>  <span class="hljs-comment">// increase the reference count for MemTable, ImmutableMemTable and Version</span><br>  MemTable* mem = mem_;<br>  MemTable* imm = imm_;<br>  Version* current = versions_-&gt;<span class="hljs-built_in">current</span>();<br>  mem-&gt;<span class="hljs-built_in">Ref</span>();<br>  <span class="hljs-keyword">if</span> (imm != <span class="hljs-literal">nullptr</span>) imm-&gt;<span class="hljs-built_in">Ref</span>();<br>  current-&gt;<span class="hljs-built_in">Ref</span>();<br><br>  <span class="hljs-type">bool</span> have_stat_update = <span class="hljs-literal">false</span>;<br>  Version::GetStats stats;<br><br>  <span class="hljs-comment">// Unlock while reading from files and memtables</span><br>  &#123;<br>    mutex_.<span class="hljs-built_in">Unlock</span>();<br>    <span class="hljs-comment">// First look in the memtable, then in the immutable memtable (if any).</span><br>    <span class="hljs-comment">// the search order is : MemTable -&gt; Immutable MemTable -&gt; SSTable</span><br>    <span class="hljs-function">LookupKey <span class="hljs-title">lkey</span><span class="hljs-params">(key, snapshot)</span></span>;<br>    <span class="hljs-keyword">if</span> (mem-&gt;<span class="hljs-built_in">Get</span>(lkey, value, &amp;s)) &#123;<br>      <span class="hljs-comment">// Done</span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (imm != <span class="hljs-literal">nullptr</span> &amp;&amp; imm-&gt;<span class="hljs-built_in">Get</span>(lkey, value, &amp;s)) &#123;<br>      <span class="hljs-comment">// Done</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      s = current-&gt;<span class="hljs-built_in">Get</span>(options, lkey, value, &amp;stats);<br>      have_stat_update = <span class="hljs-literal">true</span>;<br>    &#125;<br>    mutex_.<span class="hljs-built_in">Lock</span>();<br>  &#125;<br><br>  <span class="hljs-comment">// update the statistic info for SSTable, may run compaction in background</span><br>  <span class="hljs-keyword">if</span> (have_stat_update &amp;&amp; current-&gt;<span class="hljs-built_in">UpdateStats</span>(stats)) &#123;<br>    <span class="hljs-built_in">MaybeScheduleCompaction</span>();<br>  &#125;<br><br>  <span class="hljs-comment">// decrease the ref count</span><br>  mem-&gt;<span class="hljs-built_in">Unref</span>();<br>  <span class="hljs-keyword">if</span> (imm != <span class="hljs-literal">nullptr</span>) imm-&gt;<span class="hljs-built_in">Unref</span>();<br>  current-&gt;<span class="hljs-built_in">Unref</span>();<br>  <span class="hljs-keyword">return</span> s;<br>&#125;<br></code></pre></td></tr></table></figure><p>代码的执行流程如下：</p><ul><li>获取此次 Get 操作对应的 Snapshot 。</li><li>获取系统内存中的 MemTable、ImmutableMemtable 和 Version，前两者在 LSM 树中都有对应，Version 主要是维护 SSTable 的版本信息。获取之后增加其引用计数，这三个数据结构在引用计数为 0 时会其对应的内存会被释放。</li><li>依次从 MemTable、Immutable Memtable 和 SSTable 中查找对应的数据。</li><li>更新 SSTable 的统计信息，可能会在后台进行数据文件合并（Compaction）。</li><li>减少 MemTable、ImmutableMemTable 以及 Version 的引用计数。</li></ul><img src="leveldb-search_order.jpeg" width=70%><p>在查找时，对 MemTable 和 Immutable MemTable 都通过 SkipList 实现，这将在介绍 MemTable 的文章中解读。我们首先关注对 SSTable 的查找。对 SSTable 的查找最终会进入到 <code>ForEachOverlapping</code> 函数中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// version_set.cc</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Version::ForEachOverlapping</span><span class="hljs-params">(Slice user_key, Slice internal_key, <span class="hljs-type">void</span>* arg,</span></span><br><span class="hljs-params"><span class="hljs-function">                                 <span class="hljs-type">bool</span> (*func)(<span class="hljs-type">void</span>*, <span class="hljs-type">int</span>, FileMetaData*))</span> </span>&#123;<br>  <span class="hljs-type">const</span> Comparator* ucmp = vset_-&gt;icmp_.<span class="hljs-built_in">user_comparator</span>();<br><br>  <span class="hljs-comment">// Search level-0 in order from newest to oldest.</span><br>  std::vector&lt;FileMetaData*&gt; tmp;<br>  tmp.<span class="hljs-built_in">reserve</span>(files_[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>());<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">uint32_t</span> i = <span class="hljs-number">0</span>; i &lt; files_[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>(); i++) &#123;<br>    FileMetaData* f = files_[<span class="hljs-number">0</span>][i];<br>    <span class="hljs-comment">// search for SSTable, which may contains the key for current read</span><br>    <span class="hljs-keyword">if</span> (ucmp-&gt;<span class="hljs-built_in">Compare</span>(user_key, f-&gt;smallest.<span class="hljs-built_in">user_key</span>()) &gt;= <span class="hljs-number">0</span> &amp;&amp;<br>        ucmp-&gt;<span class="hljs-built_in">Compare</span>(user_key, f-&gt;largest.<span class="hljs-built_in">user_key</span>()) &lt;= <span class="hljs-number">0</span>) &#123;<br>      tmp.<span class="hljs-built_in">push_back</span>(f);<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (!tmp.<span class="hljs-built_in">empty</span>()) &#123;<br>  <span class="hljs-comment">// sort the selected files from new to old</span><br>    std::<span class="hljs-built_in">sort</span>(tmp.<span class="hljs-built_in">begin</span>(), tmp.<span class="hljs-built_in">end</span>(), NewestFirst);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">uint32_t</span> i = <span class="hljs-number">0</span>; i &lt; tmp.<span class="hljs-built_in">size</span>(); i++) &#123;<br>    <span class="hljs-comment">// if key are found in current file, return</span><br>    <span class="hljs-comment">// else continue to search in next file</span><br>      <span class="hljs-keyword">if</span> (!(*func)(arg, <span class="hljs-number">0</span>, tmp[i])) &#123;<br>        <span class="hljs-keyword">return</span>;<br>      &#125;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// Search other levels.</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> level = <span class="hljs-number">1</span>; level &lt; config::kNumLevels; level++) &#123;<br>    <span class="hljs-type">size_t</span> num_files = files_[level].<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">if</span> (num_files == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br><br>    <span class="hljs-comment">// Binary search to find earliest index whose largest key &gt;= internal_key.</span><br>    <span class="hljs-type">uint32_t</span> index = <span class="hljs-built_in">FindFile</span>(vset_-&gt;icmp_, files_[level], internal_key);<br>    <span class="hljs-keyword">if</span> (index &lt; num_files) &#123;<br>      FileMetaData* f = files_[level][index];<br>      <span class="hljs-keyword">if</span> (ucmp-&gt;<span class="hljs-built_in">Compare</span>(user_key, f-&gt;smallest.<span class="hljs-built_in">user_key</span>()) &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// All of &quot;f&quot; is past any data for user_key</span><br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> (!(*func)(arg, level, f)) &#123;<br>          <span class="hljs-keyword">return</span>;<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以看到，针对 SSTable 的查找分为了两个部分：对 Level-0 文件的查找以及对 Level 大于 0 的文件查找。</p><p>在对 Level-0 层的文件进行查找时，系统会将每一个有可能包含这个 key 的文件都加入到待搜查列表中，随后将选中的文件从新到旧进行排序（新文件中存储的数据才是有效的数据），再对按序对每个文件进行查找。</p><p>在对 Level-N（N&gt;0）层的文件进行查找时，系统在每一层中通过二分查找找到了一个候选文件。如果这个文件不包含当前的 key，那么这一层的查找就结束了。</p><p>之所以对 Level-0 层的查找需要选取许多候选文件进行多次搜索，而对 Level-N（N &gt; 0）层的文件查找只需一次，是因为 Level-0 层的文件都是从数据库中直接 dump 出来的，有可能存在前文所描述的数据重复的情况。而从 Level-1 层开始，数据文件都是从上一层文件中合并得到的。在合并的过程中，对同一条数据的操作只会保留一条，并且所有的文件会按照 key 的顺序排列，整个 Level-1 层及以上的文件是有序的。</p><p>到这里，LevelDB 的读流程就介绍完毕了。LevelDB 的读流程值得品味的点没有写流程的多，对 SSTable 的管理和查找处理的比较细节，当然这里也和 Compaction 模块有关，在后续的文章中会继续介绍。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://leveldb-handbook.readthedocs.io/zh/latest/">LevelDB Handbook</a></p><p><a href="https://zhuanlan.zhihu.com/p/80668555">LevelDb 源码阅读–读操作</a></p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>源代码阅读</category>
      
      <category>LevelDB</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>LevelDB 源代码阅读（一）：写流程</title>
    <link href="/2021/07/08/leveldb-source-code-reading-1/"/>
    <url>/2021/07/08/leveldb-source-code-reading-1/</url>
    
    <content type="html"><![CDATA[<p>LevelDB 是一款基于 LSM 树的嵌入式高性能 NoSQL 数据库，由 Google 的两位 Fellow （Jeff Dean 和 Sanjay Ghemawat）设计开发。LevelDB 最初使用 <a href="https://github.com/google/leveldb">C++</a> 开发，后面衍生出了不同语言版本，如 <a href="https://github.com/golang/leveldb">Go-LevelDB</a>、 <a href="https://github.com/dain/leveldb">Java-LevelDB</a> 等。本系列文章基于最新 C++ 版 LevelDB（1.23.0，截止 2021.7.8），对其结构设计进行分析，相关代码存放在<a href="https://github.com/THUMarkLau/leveldb">我的 github 仓库</a>。</p><h1 id="LSM-树结构"><a href="#LSM-树结构" class="headerlink" title="LSM 树结构"></a>LSM 树结构</h1><p>LSM 树的英文全称为 <strong>Log-Structured-Merge-Tree</strong>，翻译过来就是结构日志合并树。但是 LSM 树并不是一种严格意义上的树型数据结构，而是一种数据存储机制。这种树的机制大致如图</p><img src="LSM.png"><p>当一个数据写入时，首先记录预写日志，然后将数据插入到内存中一个名为 <strong>MemTable</strong> 的数据结构中。当 MemTable 的大小到达阈值后，就会转换为 Immutable MemTable 。MemTable 和 Immutable MemTable 的内容大致相同，但是 Immutable MemTable 无法再发生写入。因此，在 MemTable 转换为 Immutable MemTable 的同时，也会开启一个新的 MemTable 供新数据写入。</p><p>Immutable MemTable 则在后台线程中经过压缩等程序后，被写入磁盘中，成为 SSTable 。一个 SSTable 往往就是一个数据文件。SSTable 是无法被修改的，但是有时用户会写入覆盖前面数据的新数据，例如在 KV 数据库中对一个原有的 Key 赋予一个新的值。所以，新老 SSTable 之间可能存在数据重叠。同时，因为 MemTable 的大小容易受到物理内存大小的限制，一般不会太大。因此，从数据库中直接 dump 出来的 SSTable 一般比较小，数目也比较多。过多的数据文件数量会导致数据库的查询性能下降，因此在文件落盘后，数据库还会对文件进行<strong>合并（Compaction）</strong>。合并即将小的 SSTable 合并为大的 SSTable，并且在合并的过程中还可能会进行数据去重、布局优化等操作。</p><p>LevelDB 中的 Level，代表的就是其后台使用的合并策略。如图所示，在 LevelDB 中，数据文件（即 SSTable）按照层级进行管理。从数据库中直接 dump 出的数据文件为第 0 层，多个 0 层文件进行合并以后得到了 1 层文件，多个 1 层文件合并后得到 2 层文件，以此类推。多个第 N - 1 层文件进行合并会得到一个第 N 层文件，文件所在的层数也代表了其中的数据被合并的次数。同时，随着文件层数的增加，文件的大小也一般会变得越来越大。</p><p>当然，合并的策略不止 Level Compaction 这一种，学术界提出了许多种合并策略，感兴趣的读者可以自行搜索阅读，本文就不再深入。</p><h1 id="LevelDB-写入流程"><a href="#LevelDB-写入流程" class="headerlink" title="LevelDB 写入流程"></a>LevelDB 写入流程</h1><p>LevelDB 没有设计成 C&#x2F;S 模式，而是将数据库以库文件的形式提供给用户，运行时数据库需要和服务一起部署在同一台服务器上。我们简单地用下面这一段代码来说明 LevelDB 的写入过程：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//</span><br><span class="hljs-comment">// Created by lau on 2021/6/17.</span><br><span class="hljs-comment">//</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cassert&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;leveldb/db.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> leveldb;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  DB *db;<br>  Options options;<br>  options.create_if_missing = <span class="hljs-literal">true</span>;<br>  Status status = DB::<span class="hljs-built_in">Open</span>(options, <span class="hljs-string">&quot;./dbtest&quot;</span>, &amp;db);<br>  <span class="hljs-built_in">assert</span>(status.<span class="hljs-built_in">ok</span>());<br>  std::string value;<br>  std::string key1 = <span class="hljs-string">&quot;testkey1&quot;</span>;<br>  leveldb::Status s = db-&gt;<span class="hljs-built_in">Get</span>(leveldb::<span class="hljs-built_in">ReadOptions</span>(), key1, &amp;value);<br>  <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">IsNotFound</span>()) &#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;can not found for key:&quot;</span> &lt;&lt; key1 &lt;&lt; std::endl;<br>    db-&gt;<span class="hljs-built_in">Put</span>(leveldb::<span class="hljs-built_in">WriteOptions</span>(), key1, <span class="hljs-string">&quot;testvalue1&quot;</span>);<br>  &#125;<br>  s = db-&gt;<span class="hljs-built_in">Get</span>(leveldb::<span class="hljs-built_in">ReadOptions</span>(), key1, &amp;value);<br>  <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">ok</span>()) &#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;found key:&quot;</span> &lt;&lt; key1 &lt;&lt; <span class="hljs-string">&quot;,value:&quot;</span> &lt;&lt; value &lt;&lt; std::endl;<br>  &#125;<br>  s = db-&gt;<span class="hljs-built_in">Delete</span>(leveldb::<span class="hljs-built_in">WriteOptions</span>(), key1);<br>  <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">ok</span>()) &#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;delete key success which key:&quot;</span> &lt;&lt; key1 &lt;&lt; std::endl;<br>  &#125;<br>  s = db-&gt;<span class="hljs-built_in">Get</span>(leveldb::<span class="hljs-built_in">ReadOptions</span>(), key1, &amp;value);<br>  <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">IsNotFound</span>()) &#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;can not found after delete for key:&quot;</span> &lt;&lt; key1 &lt;&lt; std::endl;<br>  &#125;<br><br>  <span class="hljs-keyword">delete</span> db;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>代码的第 13 行到 17 行启动了一个 LevelDB 实例，第 18 到 20 行试图从 LevelDB 中获取键 <em>testkey1</em> 所对应的值。当获取失败后，第 23 行则会向数据库中插入键 <code>testkey1</code> 及其对应的值 <em>testvalue1</em> 。25 行到 28 行则在插入完成后重新查询该键对应的值，29 行到 32 行删除该键对应的值，33 到 36 行则尝试在删除之后再次查询。现在我们考虑第 23 行插入的过程。</p><h2 id="WriteBatch-编码规则"><a href="#WriteBatch-编码规则" class="headerlink" title="WriteBatch 编码规则"></a>WriteBatch 编码规则</h2><p>Debug 进入该函数，我们可以看到 <code>Put</code> 函数的内容</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// db_impl.cc</span><br><span class="hljs-function">Status <span class="hljs-title">DB::Put</span><span class="hljs-params">(<span class="hljs-type">const</span> WriteOptions&amp; opt, <span class="hljs-type">const</span> Slice&amp; key, <span class="hljs-type">const</span> Slice&amp; value)</span> </span>&#123;<br>  WriteBatch batch;<br>  batch.<span class="hljs-built_in">Put</span>(key, value);<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Write</span>(opt, &amp;batch);<br>&#125;<br></code></pre></td></tr></table></figure><p>首先，在进入这个函数之前，我们在 <code>main</code> 函数中以字符串形式存放的 key 和 value 被封装成了 <em>Slice</em> 对象。 Slice 类是一个简单的类，里面有存储了两个数据：以 <code>char*</code> 形式存储的 data 以及以 <code>size_t</code> 记录的 data 大小。这里在 key 对应的 Slice 里面，data 指向了 <code>testkey1</code>，size 则是 8；value 对应的 Slice 里 data 指向了 <code>testvalue</code>，size 则是 10 。</p><p><code>Put</code> 函数的第一行声明了一个 <em>WriteBatch</em> 对象。LevelDB 对外提供了两种写入接口：<code>Put</code> 和 <code>Delete</code> 。在这两种操作中，数据库都会创建一个 WriteBatch 来执行对应的操作，一个 Batch 中的操作是原子的，其是数据库执行一次操作的最小单元。在 WriteBatch 中，所有的数据在被编码后存放在了一个名为 <em>rep_</em> 的 string 中。rep_ 在初始化时会被 resize 成 12 字节大小。这 12 个字节的前 8 个字节（即 64 个 bit）存放了操作的 sequence number，后 4 个字节（32 个 bit)存放了该 Batch 中操作的数量。sequence number 本质上是一个计数器，每个操作都对应了一个 sequence number 。该计数器在 leveldb 内部维护，每进行一次操作就累加一次。由于在 leveldb 中，一次更新或者一次删除，采用的是 append 的方式，而非直接更新原数据。因此对同样一个 key，会有多个版本的数据记录，而最大的 sequence number 对应的数据记录就是最新的。</p><p>在 <code>Put</code> 函数的第二行，函数将写操作对应的 key 和 value 放入了 WriteBatch 中。我们跟着进入这个函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// write_batch.cc</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">WriteBatch::Put</span><span class="hljs-params">(<span class="hljs-type">const</span> Slice&amp; key, <span class="hljs-type">const</span> Slice&amp; value)</span> </span>&#123;<br>  <span class="hljs-comment">// set the count of operation item</span><br>  WriteBatchInternal::<span class="hljs-built_in">SetCount</span>(<span class="hljs-keyword">this</span>, WriteBatchInternal::<span class="hljs-built_in">Count</span>(<span class="hljs-keyword">this</span>) + <span class="hljs-number">1</span>);<br>  <span class="hljs-comment">// record the operation type</span><br>  rep_.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">char</span>&gt;(kTypeValue));<br>  <span class="hljs-comment">// record the key</span><br>  <span class="hljs-built_in">PutLengthPrefixedSlice</span>(&amp;rep_, key);<br>  <span class="hljs-comment">// record the value</span><br>  <span class="hljs-built_in">PutLengthPrefixedSlice</span>(&amp;rep_, value);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，这个函数主要调用了四个函数做了四件事情：</p><ul><li>第一行调用 <code>SetCount</code> 函数，修改 rep_ 的第 9 到 12 个字节中所记录的操作数量，让它在原来的基础上加一。</li><li>第二行将此次操作的类型记录进 rep_ 中，kTypeValue 是一个 enum 类型的数据，其值为 0x1，代表插入。删除所对应的类型为 kTypeDeletion，其值为 0x0 。</li><li>第三行将 key 的数据编码进了 rep_ 中。</li><li>第四行将 value 的数据编码进了 rep_ 中。</li></ul><p>在 <code>PutLengthPrefixedSlice</code> 中编码数据时，函数会先将数据的长度记录进 rep_ 中，再将数据的值记录到 rep_ 中。因此一个操作在 WriteBatch 中被编码为</p><img src="Leveldb-operation_encode.png" width=80%><p>而整个 WriteBatch 在 rep_ 中的编码为</p><img src="Leveldb-write_batch.png" width=50%><h2 id="合并写"><a href="#合并写" class="headerlink" title="合并写"></a>合并写</h2><p>回到 <em>db_impl.cc</em> 的 <code>Put</code> 函数中，其最后一个操作是将编码好的 WriteBatch 在数据库中写入。下面我们进入这个 <code>Write</code> 函数看一看。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// db_impl.cc</span><br><span class="hljs-function">Status <span class="hljs-title">DBImpl::Write</span><span class="hljs-params">(<span class="hljs-type">const</span> WriteOptions&amp; options, WriteBatch* updates)</span> </span>&#123;<br>  <span class="hljs-function">Writer <span class="hljs-title">w</span><span class="hljs-params">(&amp;mutex_)</span></span>;<br>  w.batch = updates;<br>  w.sync = options.sync;<br>  w.done = <span class="hljs-literal">false</span>;<br><br>  <span class="hljs-function">MutexLock <span class="hljs-title">l</span><span class="hljs-params">(&amp;mutex_)</span></span>;<br>  writers_.<span class="hljs-built_in">push_back</span>(&amp;w);<br>  <span class="hljs-keyword">while</span> (!w.done &amp;&amp; &amp;w != writers_.<span class="hljs-built_in">front</span>()) &#123;<br>    w.cv.<span class="hljs-built_in">Wait</span>();<br>  &#125;<br>  <span class="hljs-keyword">if</span> (w.done) &#123;<br>    <span class="hljs-keyword">return</span> w.status;<br>  &#125;<br><br>  <span class="hljs-comment">// May temporarily unlock and wait.</span><br>  Status status = <span class="hljs-built_in">MakeRoomForWrite</span>(updates == <span class="hljs-literal">nullptr</span>);<br>  <span class="hljs-type">uint64_t</span> last_sequence = versions_-&gt;<span class="hljs-built_in">LastSequence</span>();<br>  Writer* last_writer = &amp;w;<br>  <span class="hljs-keyword">if</span> (status.<span class="hljs-built_in">ok</span>() &amp;&amp; updates != <span class="hljs-literal">nullptr</span>) &#123;  <span class="hljs-comment">// nullptr batch is for compactions</span><br>    WriteBatch* write_batch = <span class="hljs-built_in">BuildBatchGroup</span>(&amp;last_writer);<br>    WriteBatchInternal::<span class="hljs-built_in">SetSequence</span>(write_batch, last_sequence + <span class="hljs-number">1</span>);<br>    last_sequence += WriteBatchInternal::<span class="hljs-built_in">Count</span>(write_batch);<br><br>    <span class="hljs-comment">// Add to log and apply to memtable.  We can release the lock</span><br>    <span class="hljs-comment">// during this phase since &amp;w is currently responsible for logging</span><br>    <span class="hljs-comment">// and protects against concurrent loggers and concurrent writes</span><br>    <span class="hljs-comment">// into mem_.</span><br>    &#123;<br>      mutex_.<span class="hljs-built_in">Unlock</span>();<br>      status = log_-&gt;<span class="hljs-built_in">AddRecord</span>(WriteBatchInternal::<span class="hljs-built_in">Contents</span>(write_batch));<br>      <span class="hljs-type">bool</span> sync_error = <span class="hljs-literal">false</span>;<br>      <span class="hljs-keyword">if</span> (status.<span class="hljs-built_in">ok</span>() &amp;&amp; options.sync) &#123;<br>        status = logfile_-&gt;<span class="hljs-built_in">Sync</span>();<br>        <span class="hljs-keyword">if</span> (!status.<span class="hljs-built_in">ok</span>()) &#123;<br>          sync_error = <span class="hljs-literal">true</span>;<br>        &#125;<br>      &#125;<br>      <span class="hljs-keyword">if</span> (status.<span class="hljs-built_in">ok</span>()) &#123;<br>        status = WriteBatchInternal::<span class="hljs-built_in">InsertInto</span>(write_batch, mem_);<br>      &#125;<br>      mutex_.<span class="hljs-built_in">Lock</span>();<br>      <span class="hljs-keyword">if</span> (sync_error) &#123;<br>        <span class="hljs-comment">// The state of the log file is indeterminate: the log record we</span><br>        <span class="hljs-comment">// just added may or may not show up when the DB is re-opened.</span><br>        <span class="hljs-comment">// So we force the DB into a mode where all future writes fail.</span><br>        <span class="hljs-built_in">RecordBackgroundError</span>(status);<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (write_batch == tmp_batch_) tmp_batch_-&gt;<span class="hljs-built_in">Clear</span>();<br><br>    versions_-&gt;<span class="hljs-built_in">SetLastSequence</span>(last_sequence);<br>  &#125;<br><br>  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    Writer* ready = writers_.<span class="hljs-built_in">front</span>();<br>    writers_.<span class="hljs-built_in">pop_front</span>();<br>    <span class="hljs-keyword">if</span> (ready != &amp;w) &#123;<br>      ready-&gt;status = status;<br>      ready-&gt;done = <span class="hljs-literal">true</span>;<br>      ready-&gt;cv.<span class="hljs-built_in">Signal</span>();<br>    &#125;<br>    <span class="hljs-keyword">if</span> (ready == last_writer) <span class="hljs-keyword">break</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// Notify new head of write queue</span><br>  <span class="hljs-keyword">if</span> (!writers_.<span class="hljs-built_in">empty</span>()) &#123;<br>    writers_.<span class="hljs-built_in">front</span>()-&gt;cv.<span class="hljs-built_in">Signal</span>();<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> status;<br>&#125;<br></code></pre></td></tr></table></figure><p>这一段代码大致可以分为几个部分：</p><ul><li>第 8 到第 15 行获取锁，为写入获取权限。</li><li>第 18 行会检查当前活动的 MemTable 是否有足够的空间供写入，以及 Level-0 的文件是否需要进行合并。如果这些检查不通过，则会在后台进行一系列的操作，使得内存中有一个合适的 MemTable 供此次写入操作执行。</li><li>第 19 行到 53 行会进行包括 WAL 和实际数据的写入。第 41 行调用的 <code>WriteBatchInternal::InsertInto</code> 函数将数据插入到了 MemTable 中。</li><li>第 56 到 70 行将 writer 从 Writer 队列中清除。</li></ul><p>在这个函数中，LevelDB 对多个并发写进行了优化，它会将同一时间内的“小写入”合并为一个“大写入”来执行，减少日志文件的小写入次数，增加整体的写入性能。假设同时有 6 个写入请求并发产生：w1，w2，w3，w4，w5，w6 。</p><p><strong>【w1 的执行】</strong> 第 8 到第 15 行代码使得 w1 拿到了写锁，进入了 Writer 队列。此时队列中只有一个 w1 ，因此顺利地进行了 <code>BuildBatchGroup</code> 。到第 31 行时，w1 会释放锁。但是此时由于 w2 到 w6 并不在队列的头部，因此其一直被阻塞，不会影响 w1 的写入。当 w1 完成写入后，在 56 到 70 行中将自己清除出 Writer 队列，然后返回。</p><p><strong>【剩余请求的执行】</strong> 假设此时 Writer 队列中的顺序为：w3，w5，w2，w4，w6 ，那么 w3 就进入 <code>BuildBatchGroup</code> ，在这一函数中 w3 会遍历 Writer 队列，在 WriteBatch 的总大小不超过一定限制的情况下，将尽可能多的写请求合并到自身的 WriteBatch ，合并的过程使用的就是前面所描述的 WriteBatch 的编码规则来进行的。假设这里 w3 将除了 w6 的所有请求都合并了，last_writer 会被置为 w4 。在 56 到 65 行，w3 会将 w5、w2、w4 都唤醒，将它们和自身一起清除出 Writer 队列，最后唤醒位于队首的 w6 。w6 会和 w1 一样执行下去，而 w5、w2、w4 则会在 13 到 15 行直接返回。</p><h2 id="MemTable-插入"><a href="#MemTable-插入" class="headerlink" title="MemTable 插入"></a>MemTable 插入</h2><p>在前文中，我们忽略了位于 <code>WriteBatchInternal::InsertInto</code> 的插入过程。本节我们来看一看数据是如何插入 MemTable 中的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// write_batch.cc</span><br><span class="hljs-function">Status <span class="hljs-title">WriteBatchInternal::InsertInto</span><span class="hljs-params">(<span class="hljs-type">const</span> WriteBatch* b, MemTable* memtable)</span> </span>&#123;<br>  MemTableInserter inserter;<br>  inserter.sequence_ = WriteBatchInternal::<span class="hljs-built_in">Sequence</span>(b);<br>  inserter.mem_ = memtable;<br>  <span class="hljs-keyword">return</span> b-&gt;<span class="hljs-built_in">Iterate</span>(&amp;inserter);<br>&#125;<br><br><span class="hljs-function">Status <span class="hljs-title">WriteBatch::Iterate</span><span class="hljs-params">(Handler* handler)</span> <span class="hljs-type">const</span> </span>&#123;<br>  <span class="hljs-function">Slice <span class="hljs-title">input</span><span class="hljs-params">(rep_)</span></span>;<br>  <span class="hljs-keyword">if</span> (input.<span class="hljs-built_in">size</span>() &lt; kHeader) &#123;<br>    <span class="hljs-keyword">return</span> Status::<span class="hljs-built_in">Corruption</span>(<span class="hljs-string">&quot;malformed WriteBatch (too small)&quot;</span>);<br>  &#125;<br><br>  input.<span class="hljs-built_in">remove_prefix</span>(kHeader);<br>  Slice key, value;<br>  <span class="hljs-type">int</span> found = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">while</span> (!input.<span class="hljs-built_in">empty</span>()) &#123;<br>    found++;<br>    <span class="hljs-type">char</span> tag = input[<span class="hljs-number">0</span>];<br>    input.<span class="hljs-built_in">remove_prefix</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">switch</span> (tag) &#123;<br>      <span class="hljs-keyword">case</span> kTypeValue:<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">GetLengthPrefixedSlice</span>(&amp;input, &amp;key) &amp;&amp;<br>            <span class="hljs-built_in">GetLengthPrefixedSlice</span>(&amp;input, &amp;value)) &#123;<br>          handler-&gt;<span class="hljs-built_in">Put</span>(key, value);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-keyword">return</span> Status::<span class="hljs-built_in">Corruption</span>(<span class="hljs-string">&quot;bad WriteBatch Put&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> kTypeDeletion:<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">GetLengthPrefixedSlice</span>(&amp;input, &amp;key)) &#123;<br>          handler-&gt;<span class="hljs-built_in">Delete</span>(key);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-keyword">return</span> Status::<span class="hljs-built_in">Corruption</span>(<span class="hljs-string">&quot;bad WriteBatch Delete&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">default</span>:<br>        <span class="hljs-keyword">return</span> Status::<span class="hljs-built_in">Corruption</span>(<span class="hljs-string">&quot;unknown WriteBatch tag&quot;</span>);<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (found != WriteBatchInternal::<span class="hljs-built_in">Count</span>(<span class="hljs-keyword">this</span>)) &#123;<br>    <span class="hljs-keyword">return</span> Status::<span class="hljs-built_in">Corruption</span>(<span class="hljs-string">&quot;WriteBatch has wrong count&quot;</span>);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">return</span> Status::<span class="hljs-built_in">OK</span>();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>函数中会新建一个 <em>MemTableInserter</em>，设置好对应的参数后由 WriteBatch 的 <code>Iterate</code> 方法来执行对 MemTable 的插入。</p><p>在 <code>Iterate</code> 方法中，首先会将 WriteBatch 自身的 rep_ 包装为一个 Slice 。前面我们解释 Slice 结构时提到过，Slice 中只有一个以 char* 记录的数据内容和以 size_t 记录的数据大小。随后，系统将 rep_ 的数据头剪切掉，只剩下操作记录的部分。随后不断获取操作记录，如果是插入（Put），则获取其 key 和 value；如果是删除（Delete），则只需要获取其 key 。获取到记录后将其通过 Handler（即前面的 MemTableInserter）插入到 MemTable 中，并记录操作记录的数目。最后检查从 rep_ 中读出的操作数记录的数目是否与 rep_ 中记录的相同。</p><p>说到这里，还是没有讲到如何在 MemTable 中插入数据。以插入数据为例，MemTableInserter 的插入函数会调用 MemTable 的 <code>Add</code> 函数，该函数的细节如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// memtable.cc</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MemTable::Add</span><span class="hljs-params">(SequenceNumber s, ValueType type, <span class="hljs-type">const</span> Slice&amp; key,</span></span><br><span class="hljs-params"><span class="hljs-function">                   <span class="hljs-type">const</span> Slice&amp; value)</span> </span>&#123;<br>  <span class="hljs-comment">// Format of an entry is concatenation of:</span><br>  <span class="hljs-comment">//  key_size     : varint32 of internal_key.size()</span><br>  <span class="hljs-comment">//  key bytes    : char[internal_key.size()]</span><br>  <span class="hljs-comment">//  value_size   : varint32 of value.size()</span><br>  <span class="hljs-comment">//  value bytes  : char[value.size()]</span><br>  <span class="hljs-type">size_t</span> key_size = key.<span class="hljs-built_in">size</span>();<br>  <span class="hljs-type">size_t</span> val_size = value.<span class="hljs-built_in">size</span>();<br>  <span class="hljs-comment">// the internal key is 8 byte bigger than origin key</span><br>  <span class="hljs-type">size_t</span> internal_key_size = key_size + <span class="hljs-number">8</span>;<br>  <span class="hljs-comment">// get the total length of new encode format</span><br>  <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> encoded_len = <span class="hljs-built_in">VarintLength</span>(internal_key_size) +<br>                             internal_key_size + <span class="hljs-built_in">VarintLength</span>(val_size) +<br>                             val_size;<br>  <span class="hljs-comment">// allocate space for new encode data</span><br>  <span class="hljs-type">char</span>* buf = arena_.<span class="hljs-built_in">Allocate</span>(encoded_len);<br>  <span class="hljs-comment">// encode the internal key size to the buffer</span><br>  <span class="hljs-type">char</span>* p = <span class="hljs-built_in">EncodeVarint32</span>(buf, internal_key_size);<br>  <span class="hljs-comment">// encode the key value to the buffer</span><br>  std::<span class="hljs-built_in">memcpy</span>(p, key.<span class="hljs-built_in">data</span>(), key_size);<br>  p += key_size;<br>  <span class="hljs-comment">// encode the sequence number and operation type into buffer</span><br>  <span class="hljs-built_in">EncodeFixed64</span>(p, (s &lt;&lt; <span class="hljs-number">8</span>) | type);<br>  p += <span class="hljs-number">8</span>;<br>  <span class="hljs-comment">// encode the value size</span><br>  p = <span class="hljs-built_in">EncodeVarint32</span>(p, val_size);<br>  <span class="hljs-comment">// encode the value data</span><br>  std::<span class="hljs-built_in">memcpy</span>(p, value.<span class="hljs-built_in">data</span>(), val_size);<br>  <span class="hljs-built_in">assert</span>(p + val_size == buf + encoded_len);<br>  <span class="hljs-comment">// insert the encoded data to skip list</span><br>  <span class="hljs-comment">// skip list is the data structure which used by memtable to store data</span><br>  table_.<span class="hljs-built_in">Insert</span>(buf);<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个函数中，原本的 key 被重新编码为 internal_key，然后重新和 value 编码到 buffer 中。internal_key 在 key_len 和 key_data 的后面追加了 7 个字节的 seqence number 和一个字节的 operation type 。</p><img src="Leveldb-internal_key.png" width=65%><p>编码完成后，这个 buffer 会被插入到一个名为 SkipList 的数据结构中。SkipList 是 MemTable 内部用以存放数据的数据结构，其结构比较复杂，本文就不展开讲了，后面的文章会介绍这个 MemTable 的结构和实现。</p><p>至此，LevelDB 的写流程就介绍结束了。LevelDB 写流程主要有两个点值得我们注意：</p><ul><li>不同操作（写入、删除）在内存中的编码方式</li><li>对并发写的合并</li></ul><p>前者在用尽量少的空间优雅地编码了一个或多个操作记录，后者则巧妙地将多个并发写合并为了一个原子写，这两点非常值得我们反复品味。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://leveldb-handbook.readthedocs.io/zh/latest/">LevelDB Handbook</a></p><p><a href="https://blog.csdn.net/weixin_30871293/article/details/98269550">LevelDB 合并写详情</a></p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>源代码阅读</category>
      
      <category>LevelDB</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>操作系统（三）：进程间通信</title>
    <link href="/2021/03/23/OS-IPC/"/>
    <url>/2021/03/23/OS-IPC/</url>
    
    <content type="html"><![CDATA[<p>在现代操作系统中，使用多个进程来实现应用和系统是一种广泛使用的方法。<strong>进程间通信(Inter-Process Communication)</strong> 是多进程协作的基础。</p><p>一般来说，IPC 至少需要两个进程参与。根据信息流动的方向，这两方可以被称为<strong>发送者</strong>和<strong>接收者</strong>。在实际使用中，IPC 常被用于服务调用，因此参与 IPC 的双方又被称为<strong>调用者</strong>和<strong>被调用者</strong>，或者<strong>客户端</strong>和<strong>服务端</strong>。</p><p>为了有效地协同工作，进程间通信一般伴随着数据的传输。一种常用的通信数据的抽象是**消息(message)<strong>。消息一般包含一个</strong>头部(header)<strong>和一个</strong>数据段(payload)**。头部中通常含有魔数、消息长度、校验码等信息，而数据段中则既可以包含“纯”数据，也可以包含系统资源（如文件描述符等）。</p><p>下面，本文将简略地介绍 IPC 的相关内容。</p><h1 id="一个简单的-IPC-设计"><a href="#一个简单的-IPC-设计" class="headerlink" title="一个简单的 IPC 设计"></a>一个简单的 IPC 设计</h1><p>考虑一个简单的 IPC，内核将两个进程的一段虚拟地址映射到同一段物理地址上，即两个进程之间有一段共享内存。在通信时，发送者将要传输的数据内容拷贝到<strong>发送者消息</strong>上，然后依次设置头部中的状态（设置为“准备就绪”）等信息。接收者会不停地轮询发送者消息的状态，一旦观测到状态信息为“准备就绪”，就表示发送者发出了一个消息。发送者一发送完消息，就开始轮询<strong>接收者消息</strong>的状态，等待其变成“准备就绪”。接收者在读取到发送者的消息后，处理请求，并在接收者消息上准备返回结果。当发送者观测到接收者消息的状态为“准备就绪”后，即表示收到了返回的结果。</p><p>这样，我们就利用共享内存+轮询完成了一个简单的 IPC。但是这个 IPC 有许多缺点，例如：轮询时会浪费 CPU 资源、多个线程进行通信时共享内存较为不方便等。</p><h1 id="IPC-基础"><a href="#IPC-基础" class="headerlink" title="IPC 基础"></a>IPC 基础</h1><h2 id="数据传递"><a href="#数据传递" class="headerlink" title="数据传递"></a>数据传递</h2><p>从以上简单的 IPC 方案可以看出，IPC 的一个重要功能是在进程间传递数据。消息传递(message passing)是 IPC 中常用的数据传递方式：将数据抽象成一个个的消息进行传递。消息传递往往需要一个“中间人”（如共享内存、内核等）。消息传递的基本接口有以下四个：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">发送消息：<span class="hljs-constructor">Send(<span class="hljs-params">message</span>)</span><br>接收消息：<span class="hljs-constructor">Recv(<span class="hljs-params">message</span>)</span><br>远程过程调用：<span class="hljs-constructor">RPC(<span class="hljs-params">req_message</span>, <span class="hljs-params">recv_message</span>)</span><br>回复消息：<span class="hljs-constructor">Reply(<span class="hljs-params">resp_message</span>)</span><br></code></pre></td></tr></table></figure><p>发送消息和接收消息的语义比较直接，远程过程调用（Remote Procedure Call，RPC）可以理解为发送端调用 <code>Send</code> 接口后紧接着调用 <code>Recv</code> 接口。<code>Reply</code> 通常用于回复一个远程过程调用。</p><h3 id="基于共享内存的消息传递"><a href="#基于共享内存的消息传递" class="headerlink" title="基于共享内存的消息传递"></a>基于共享内存的消息传递</h3><p>在前面简单的 IPC 方案中，我们已经看到了进程是如何使用共享内存来进行通信的。这种方式的一个特点是：操作系统在通信过程中不干预数据传输。从操作系统的角度看，共享内存为两个（或多个）进程在其虚拟地址空间中映射了同一段物理内存，这些方案里操作系统通常不参与后续的通信过程。</p><h3 id="操作系统辅助的消息传递"><a href="#操作系统辅助的消息传递" class="headerlink" title="操作系统辅助的消息传递"></a>操作系统辅助的消息传递</h3><p>操作系统辅助的消息传递指内核对用户态提供通信的接口，如 <code>Send</code> 或 <code>Recv</code> 等。进程可以直接使用这些接口，将消息传递给另一个进程，而不需要建立共享内存和执行轮询内存数据等操作。</p><p>当两个进程 $P$ 和 $Q$ 通过内核接口进行 IPC 时，其需要</p><ol><li>通过特定的内核接口建立一个通信连接。这里的建立通信链接更多的是一个抽象的建立过程，具体的形式由内核决定，如内核可以通过维护一个数据结构来记录建立好连接的进程对。</li><li>通过 <code>Send</code> 和 <code>Recv</code> 接口传递消息。</li></ol><h3 id="共享内存和操作系统辅助传递的对比"><a href="#共享内存和操作系统辅助传递的对比" class="headerlink" title="共享内存和操作系统辅助传递的对比"></a>共享内存和操作系统辅助传递的对比</h3><p>从性能的角度来看，共享内存在传递消息时可以实现理论上的零内存拷贝传输。这里的内存拷贝，指的是将数据从内存的一片区域拷贝到内存中的另一片区域。而在操作系统辅助传递方式中，通常需要将数据从发送者的用户态内存拷贝到内核内存，然后将数据从内核内存拷贝到接收者的用户态内存，这个过程包含两次拷贝。</p><p>当然，操作系统辅助传递也有优点。第一，操作系统辅助传递的抽象更简单，内核可以保证每一次通信接口的调用都是一个消息被发送或接收，并且可以很好地支持变长消息，而共享内存则需要用户态软件来封装实现这一功能。第二，操作系统辅助传递的安全性更强，可以保证进程之间的隔离性。第三，在多方通信时，在多个进程之间共享内存是不安全的，而操作系统辅助传递则没有这个问题。</p><h2 id="控制流转移"><a href="#控制流转移" class="headerlink" title="控制流转移"></a>控制流转移</h2><p>对内核来说，实现消息传递机制除了要考虑数据的传输，往往还要附带<strong>控制流转移</strong>的功能：当一个通信发生时，内核将控制流从发送者进程切换到接收者进程（返回时类似）。在共享内存的方案中，如果没有控制流转移的功能，只能通过不断地轮询来检查是否有消息到来，而这可能会浪费大量 CPU 资源。</p><p>一个常见的流程如下：<br>首先，接收者进程完成初始化后将自己阻塞起来等待消息的到来（如执行阻塞的 <code>Recv</code>）。<br>之后，发送者进程发起通信（RPC）。在处理该操作时，内核首先将发送者的消息传递给接收者，然后令发送者进程进入阻塞状态，并将接收者进程从阻塞状态唤醒为预备状态。对接收者进程而言，会从阻塞的 <code>Recv</code> 函数中返回一个消息，表明收到了发送者的一个消息。<br>接收者完成处理，发送消息，然后自己进入阻塞状态。内核将数据传送到发送者进程，并将其唤醒。</p><p>结合内核中的调度以及对进程的调度状态的修改，控制流转移可以避免轮询操作，从而将消息高效地进行传递。</p><h2 id="单向通信与双向通信"><a href="#单向通信与双向通信" class="headerlink" title="单向通信与双向通信"></a>单向通信与双向通信</h2><p>IPC 通常包含三种可能的方向：仅支持单向通信、仅支持双向通信、单向和双向通信均可。</p><p>通常来说，单向通信其实是系统软件实现 IPC 的一个基本单元，双向通信时可以基于单向 IPC 来搭建的。在接口上，如果通信建立后，通信的双方分别只能使用 <code>Send</code> 和 <code>Recv</code> 接口，那么这通常对应于单向通信。实际中，很多系统选择的是单向和双向皆可的策略，这样可以比较好地支持各种场景。当然，如管道、信号等只支持单向通信的机制在实际中同样有较多应用。</p><h2 id="同步与异步-IPC"><a href="#同步与异步-IPC" class="headerlink" title="同步与异步 IPC"></a>同步与异步 IPC</h2><p>IPC 的另一种分类是：同步 IPC 和异步 IPC。简单来说，同步 IPC 在操作时会阻塞进程直到该操作完成；而异步 IPC 则通常是非阻塞的，进程只需要发起一次操作即可返回，而不需要等待其完成。异步 IPC 通常通过轮询内存状态或注册回调函数（如果内核支持）来获取返回结果。</p><p>同步 IPC 往往是双向 IPC（或 RPC），即发送者需要等待返回的结果。不过也存在单向 IPC 是同步的，这种情况下发送者虽然不会等待接收者返回结果，但是其会等待接收者接收消息。</p><p>在早期的微内核系统中，同步 IPC 往往是唯一的 IPC 方式。这是因为相比异步 IPC，同步 IPC 有更好的编程抽象。例如使用同步 RPC 时，调用者可以将进程间通信看作是一种函数调用，调用返回时也意味着结果返回了。但是同步 IPC 在操作系统发展的过程中，逐渐表现出一些不足。一个典型的问题是并发。当一个服务进程要响应很多客户进程的通信时，在同步 IPC 的实现下为了服务进程往往需要创建大量工作线程去响应不同的客户进程，否则可能出现客户进程阻塞的现象。但是这里也有一个问题，过多的工作线程会浪费系统资源。而使用异步 IPC 则可以在并发通信时避免这些问题。总的来看，目前大部分操作系统都会选择同时实现同步和异步的 IPC，以满足不同的应用需求。</p><h2 id="超时机制"><a href="#超时机制" class="headerlink" title="超时机制"></a>超时机制</h2><p>由于进程间有隔离性，因此有一个问题时：通信的双方很难确认对方的状态。例如在同步 IPC 中，当控制流从调用者传递到被调用者后，如果被调用者恶意地不返回到调用者，那么就会使得调用者无法继续执行。异步 IPC 也有类似的问题。即使控制流不会被被调用者恶意地抢占，调用者仍然有可能花费很长时间等待一个请求的处理，例如当被调用者十分忙碌时。</p><p>为了解决这个问题，IPC 的设计中引入了<strong>超时机制</strong>。超时机制扩展了 IPC 通信双方的接口，允许发送者&#x2F;接收者指定它们发送&#x2F;接收请求的等待时间。例如，一个用户进程可以花费 5 秒等待文件系统进程的 IPC 请求处理操作。如果超过这个时间仍没有反馈，则由操作系统内核结束这次 IPC 调用，返回一个超时错误。超时机制允许进程为一次通信的等待时间设置一个上限，从而避免类似<strong>拒绝服务</strong>的攻击情况出现。</p><p>但是在实际中，大部分进程难以决定一个合理的超时。例如前面等待文件系统进程的 5 秒，当处理的数据量非常大时，5 秒可能不够文件系统进程处理请求。一个过短的超时显然不行，但是一个过长的超时又容易使得调用者无法察觉被调用者的异常。因此，内核常引入两个特殊的超时选择：“永不返回”和“立即返回”。“永不返回”和引入超时机制之前的状态类似；而“立即返回”则是说只有当前被调用者处于可以立即响应的状态才会真的发起通信，否则就直接返回。更注重安全性时应该选择“立即返回”，更注重功能性时则应选择“永不返回”，这由发送者决定。</p><h2 id="直接通信与间接通信"><a href="#直接通信与间接通信" class="headerlink" title="直接通信与间接通信"></a>直接通信与间接通信</h2><p>在建立一个连接时，虽然不同的系统有不同的实现，但是通常可以分成两类：<strong>直接通信</strong>和<strong>间接通信</strong>。在直接通信中，通信的进程一方需要显式地标识另一方。例如，<code>Send(P,message)</code> 代表向 $P$ 进程发送一则消息；<code>Recv(Q, message)</code> 代表从 $Q$ 进程接收一则消息。直接通信下连接的建立是自动的，在具体交互时通过标识的名称完成。这就意味着，一个连接会唯一地对应一对进程。连接本身可以是单向的，也可以是双向的。</p><p>在间接通信中，消息传递通过一个中间的信箱来完成。每个信箱有其唯一的标识符，而进程间通过同一个信箱来交换消息。也就是说，进程间连接的建立发生在共享一个信箱时。而每对进程可以通过共享多个信箱来建立多个连接。连接同样可以时单向的或双向的。</p><h2 id="权限检查"><a href="#权限检查" class="headerlink" title="权限检查"></a>权限检查</h2><p>进程间的通信通常依赖于一套权限检查的机制来保证连接的安全性。在如 Linux 这样的宏内核系统中，通常将安全检查机制和文件的权限检查机制结合在一起。一个进程和其他进程通信，必须要通过权限的检查。例如，seL4 等微内核系统中的 Capability 机制，会将所有的通信连接抽象成一个个的内核对象。而每个进程对内核对象的访问权限由 Capability 来刻画。在宏内核系统中，如 Linux 中，通常会复用其有效用户&#x2F;有效组的文件权限，以刻画进程对某个连接的权限。</p><h2 id="命名服务"><a href="#命名服务" class="headerlink" title="命名服务"></a>命名服务</h2><p>权限检查机制带来了安全性，但是权限如何分发呢？通常，权限的分发会通过一个用户态的服务——**命名服务(naming server)**来处理。命名服务进程则指代提供该服务的具体进程。</p><p>命名服务就像一个全局看板，可以协调服务端进程和客户端进程之间的通信。简单来说，服务端进程可以将自己提供的服务告诉命名服务进程，例如文件系统进程可以注册一个“文件系统服务”。客户端进程可以去命名服务上查询当前服务，并选择自己希望建立连接的服务去尝试获取权限。具体是否分发权限给对应的客户端进程，是由命名服务和对应的服务端进程根据特定的策略来判断的，例如文件系统进程可能允许任意线程进行连接，一个数据库进程则可能需要客户端提供私钥签名的证书。使用命名服务有很多的好处，比如各个服务不再是内核中的 ID 等抽象的表示，而是对应用更加友好的“名字”。</p><h1 id="宏内核系统中的-IPC"><a href="#宏内核系统中的-IPC" class="headerlink" title="宏内核系统中的 IPC"></a>宏内核系统中的 IPC</h1><p>一般来说，宏内核系统中 IPC 的方式主要有：管道、消息队列、信号量、共享内存、信号、套接字。</p><h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><p><strong>管道（pipe）</strong>是宏内核场景下重要的进程间通信机制。正如其名，管道是两个进程间的一条通道，一端负责投递，一端负责接收。例如，我们执行 Linux 下的 shell 命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ps aux | grep target<br></code></pre></td></tr></table></figure><p>来查看是否含有关键字为 target 的进程在运行。这里其实有两个命令：ps 和 grep，通过 shell 的管道接口 |，将第一个命令的输出投递到一个管道中，而这条管道的出口则是第二个命令的输入。</p><p>管道是单向的 IPC，内核中通常有一定的缓冲区来缓冲消息，而通信的数据（消息抽象）是字节流，需要应用自己去对数据进行解析。</p><p>具体实现上，管道在 UNIX 系列的系统中会被当作一个文件。内核会为用户态提供代表管道的文件描述符，让其可以通过文件系统相关的系统调用来使用。管道的行为和 FIFO 队列非常像，最早传入的数据会被最先读出来。</p><p>当一个进程尝试在输出端对一个空管道进行读取时，会有两种情况：如果系统发现还没有任何进程有这个管道的写端口，就会得到 EOF（End-of-File）；否则，进程会阻塞在这个系统调用上，直到数据到来。第一种情况发生的可能是，管道的两个端口在 UNIX 系列系统的内核中以两个独立的文件描述符存在的，写端口有可能被进程给主动关闭了。对于第二种情况，进程可以通过配置非阻塞来避免阻塞。</p><h3 id="命名管道和匿名管道"><a href="#命名管道和匿名管道" class="headerlink" title="命名管道和匿名管道"></a>命名管道和匿名管道</h3><p>在经典的 UNIX 实现中，管道有两类：命名管道和匿名管道。主要区别在于它们的创建方式。匿名管道通过 <code>pipe</code> 的系统调用创建，在创建的同时进程会拿到读写的端口（两个文件描述符）。由于整个管道没有全局的“名字”，因此只能通过这两个文件描述符来使用它。这种情况下，通常结合 <code>fork</code> 的使用，即继承的方式来建立父子进程间的连接。例如，父进程创建好了一个管道，然后使用 <code>fork</code> 创建子进程。子进程会有用父进程的系统资源，也就有了该管道的读写端口，因此可以和父进程通过该管道进行通信。这种方式对于父子进程等有着创建关系的进程间通信比较方便，但是对于两个关系较远的进程就不太适用。</p><p>命名管道通过 <code>mkfifo</code> 来创建，在创建时会指定一个全局的文件名，由这个文件名（例如 &#x2F;tmp&#x2F;namedpipe）来指代一个具体的管道。通过这种方式，只要两个进程通过一个相同的管道名进行创建（并且都拥有权限），就可以实现在任意两个进程间建立管道的通信连接。</p><h2 id="System-V-消息队列"><a href="#System-V-消息队列" class="headerlink" title="System V 消息队列"></a>System V 消息队列</h2><p>相比于本文介绍的其他宏内核通信机制，  消息队列是唯一一个以消息为数据抽象的通信机制。应用可以通过消息队列来发送或接收消息，发送和接收的接口是由内核提供的。消息队列是一种非常灵活的通信方式，可以有多个发送者和多个接收者。并且在 Linux 中，消息队列中的每个消息都有其类型抽象，使得发送者和接受者可以根据消息的类型来选择性地处理消息。</p><h3 id="消息队列的结构"><a href="#消息队列的结构" class="headerlink" title="消息队列的结构"></a>消息队列的结构</h3><p>消息队列在 Linux 内核中的实现形式是消息链表。当创建新的消息队列时，操作系统将在内核中新建一个消息链表，作为消息队列的内核对象。队列的消息有一个消息头部指针，即链表中的头结点，它指向队列中的第一个消息（或者为空）。每个消息都会有指向下一个消息的指针（或者为空）。</p><p>在消息结构体中，除了指针外，就是消息的内容。消息的内容有两个部分：类型和数据。数据是一段内存数据，和管道中的字节流类似。类型是用户态程序为每个消息指定的。在消息队列的设计中，内核不需要知道类型的语义，仅仅是保存，以及基于类型进行简单的查找。</p><h3 id="消息队列的基本操作"><a href="#消息队列的基本操作" class="headerlink" title="消息队列的基本操作"></a>消息队列的基本操作</h3><p>消息队列一般有四个基本操作：<code>msgget</code>、<code>msgsnd</code>、<code>msgrcv</code>、<code>msgctl</code>，这四个操作在 Linux 上被实现为系统调用。</p><p><code>msgget</code> 允许进程获取已有的消息队列的连接，或者创建一个新的消息队列。只要有对应的权限，消息队列允许任意数量的进程连接到同一通信连接上（即同一队列上）。<br><code>msgctl</code> 可以控制和管理一个消息队列，如修改消息队列的权限信息或删除消息队列。<br><code>msgsnd</code> 可以往消息队列上发送消息，<code>msgrcv</code> 可以从消息队列上接收消息。多个进程可以同时往消息队列上发送和从消息队列上接收消息。大部分情况下这两个过程是非阻塞的：对发送者来说，只要队列有空闲的空间就可以向其发送消息；对接收者来说，只要队列中有未读消息就可以从队列中读取消息。如果发送消息时队列中没有空间或者读取消息时队列中没有消息可以读，默认的操作是阻塞进程，直到有空间腾出或者有新的消息到达。</p><h3 id="Linux-中的消息队列"><a href="#Linux-中的消息队列" class="headerlink" title="Linux 中的消息队列"></a>Linux 中的消息队列</h3><p>在 Linux 中，一个消息队列如果被创建，除非显式地将其删除，否则其生命周期是和内核一致的。其次，消息队列的内存空间是有限制的，因此消息队列并不适合传递长消息，一般建议用共享内存来传递长消息。最后，消息在用户态和内核态之间传递，会有内存拷贝的开销。</p><h2 id="System-V-信号量"><a href="#System-V-信号量" class="headerlink" title="System V 信号量"></a>System V 信号量</h2><p>和其他 IPC 机制传递数据的方案不同，信号量在实际的使用中主要是用作进程间的“同步”。有些场景下，多个进程需要依赖于进程间通信来同步彼此的状态，如执行的顺序等。信号量本身能传递的数据量很少，一般来说仅有一个共享的整形计数器，该计数器通常由内核维护，而对信号量的操作则需要经过内核系统调用。</p><p>信号量的主要操作有两个原语：P 和 V。P 是荷兰语 Probeer（尝试）的缩写，表示尝试一个操作（在信号量中通常是将一个计数器减 1），该操作的失败会将该进程切换到阻塞状态，直到其他进程执行了 V 操作。<br>V 是荷兰语 Verhoog（增加）的缩写，在信号量中是将一个计数器加 1。V 可能会唤醒一个因 P 操作而陷入阻塞的进程。P 和 V 的操作都是在信号量结构上进行的，该结构会封装一个计数器。</p><p>信号量的一个简单的使用是将其值的范围限定在 0 到 1 之间。但执行 P 原语时，会将计数器减 1；当执行 V 原语时，会将计数器加 1。如果计数器被 P 原语减为负数，则会阻塞该进程，直到其他进程使用 V 原语将计数器修改成非负数时，则会唤醒该进程。</p><p>信号量一种用途是同步进程之间的操作。例如将一个信号量限定在 0 到 1 之间，初始值为 0。进程 A 在执行之前调用 P 原语，此时信号量的计数器减去 1，变成 -1，进程 A 被阻塞。进程 B 在执行结束后使用 V 原语，将信号量的计数器增加为 0，此时进程 A 被唤醒。这样，我们就使用一个信号量，保证进程 A 和 B 的执行顺序为先 B 后 A。</p><p>信号量的另一种典型用途是控制共享资源的访问，此时 P 原语和 V 原语必须成对出现，在获取资源时调用 P 原语，在释放资源时调用 V 原语。例如，某个资源对应的信号量范围在 0 到 1 之间，初始值为 1。进程 A 先访问该资源，调用 P 原语，将信号量的计数器修改为 0，成功获取资源并执行。进程 B 随后访问该资源，调用 P 原语，信号量的计数器修改为 -1，此时进程 B 被阻塞。过后一段时间，进程 A 释放资源，调用 V 原语，将进程 B 唤醒，进程 B 此时获取了资源并开始执行。进程 B 执行完成后，调用 V 原语释放资源，此时信号量的计数器恢复为 1。</p><h2 id="System-V-共享内存"><a href="#System-V-共享内存" class="headerlink" title="System V 共享内存"></a>System V 共享内存</h2><p>对于消息队列、管道、信号量等机制，内核都提供了完整的接口。虽然这些完善的抽象方便了用户进程的使用，但是其中涉及的数据拷贝和控制流转移等处理逻辑影响了这些抽象的性能。共享内存将两个（或多个）进程中的一片虚拟地址空间映射到同一片物理地址空间上，当映射建立完成后，内核就不再参与进程间的通信。这样，在通信时就不存在将数据从用户态内存拷贝到内核态内存的过程，也就增强了 IPC 的性能。因此，共享内存适用于需要传递长消息的场景。</p><h2 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h2><p>管道、消息队列、共享内存等方式主要关注数据传输的设计，而<strong>信号(signal)<strong>的一个特点是</strong>单向的事件通知</strong>。信号量也有通知能力，但是需要进程主动查询计数器或者陷入阻塞状态等待通知。使用信号，一个进程可以随时发送一个事件到特定的进程、线程或进程组等。接收事件的进程不需要阻塞等待该事件，内核会帮助其切换到对应的处理函数中响应信号事件，并且在处理完成后恢复之前的上下文。</p><p>信号传递的信息很短，只有一个编号（信号类型）。例如我们在 Shell 中使用 Ctrl + C 中止一个运行中的进程，就是 Shell 发出了一个 <code>SIGINT</code> 信号，使得进程中止。</p><p>在通信的场景下，一个进程会为一些特定的信号注册处理函数。当进程接收到对应的信号时，内核会自动地将用户的控制流切换到对应的处理函数中。</p><p>在 Linux 中，其早期有 31 个信号（1 ~ 31 号），后续 POSIX 标准又引入了编号从 32 到 64 的其他信号。Linux 传统信号被称为常规信号，POSIX 引入的信号称为实时信号。一个进程如果多次收到某个常规信号，内核只会记录一次，而多个相同的实时信号则不会被丢弃。</p><h3 id="发送信号"><a href="#发送信号" class="headerlink" title="发送信号"></a>发送信号</h3><p>信号的发送者可以是用户态进程，也可以是内核。一个用户态进程可以通过调用内核提供的系统接口，如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">kill(<span class="hljs-type">pid_t</span> pid, <span class="hljs-type">int</span> sig)<br>tgkill(<span class="hljs-type">int</span> tgid, <span class="hljs-type">int</span> tid, <span class="hljs-type">int</span> sig)<br></code></pre></td></tr></table></figure><p>向进程或线程发送特定的信号。内核通过不同的系统调用及其参数，来确定接收信号的目标进程或线程，将信号事件添加到其等待队列上。添加操作需要区别实时信号和常规信号，当发送的信号是非实时的信号，并且现在还未处理该信号时，内核会忽略掉这个事件。</p><h3 id="处理信号"><a href="#处理信号" class="headerlink" title="处理信号"></a>处理信号</h3><p>Linux 提供了一个 <code>sigprocmask</code> 系统调用，允许用户设置队特定信号的阻塞状态。当一个信号被阻塞后，Linux 将不会再触发这个信号的响应函数，直到该信号被解除阻塞。信号被阻塞并不会影响其被添加到等待队列上，当进程解除了对这个信号的阻塞时，其可能需要处理在阻塞期间收到的信号。很多重要的信号是不能被阻塞的，例如 SIGKILL。</p><p>在 Linux 等 UNIX 系统的设计中，信号得到处理的时机通常是内核执行完异常、中断或系统调用等返回到用户态的时刻，此时内核会检查一个状态位来判断是否有信号需要处理。如果有，则先去处理该信号事件。Linux 提供了 <code>signal</code>、<code>sigaction</code> 等系统调用，允许用户为特定的信号注册一个用户态响应函数。</p><h3 id="可重入处理函数"><a href="#可重入处理函数" class="headerlink" title="可重入处理函数"></a>可重入处理函数</h3><p>在信号处理函数执行的过程中，如果其他进程又发送了一个该信号事件过来，并且当前进程由于中断等下陷到内核，那么当前进程可能会暂停当前信号处理函数的执行，并且重新切换到处理函数的开头去处理新的信号事件，然后再回到原来的地方继续执行原本的信号响应函数。这种嵌套需要信号处理函数是<strong>可重入</strong>的。简单来说，就是在信号处理的过程中，有可能会产生并发，并且调用的函数就是信号处理函数本身。假如此时在信号处理函数中使用了全局锁保护一段关键操作时，就有可能导致死锁：信号处理函数在第一次被调用时获得了全局锁，在进行到一半时又被从头执行，此时原本的信号处理函数没有释放获得的锁，因而新的处理函数无法获取全局锁，进而造成死锁的局面。</p><p><strong>可重入（reentrant）</strong>函数允许多个任务并发使用，而不用担心共享数据的错误。一般来说，实现一个可重入函数有以下几个要求：</p><ul><li>不使用静态数据，或者静态数据都是只读的。</li><li>尽量只使用本地数据。</li><li>在必须使用全局共享数据的情况下，需要保护对全局数据的访问（也需要避免死锁）。</li><li>避免在函数中修改自己的代码。</li><li>不调用不可重入的函数，很多库函数的实现（例如 <code>malloc</code>）是不可重入的，需要注意。</li></ul><h2 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h2><p>**套接字(Socket)**是一种既可用于本地，又可跨网络使用的通信机制。因此应用程序可以使用 Socket 来实现本地进程间的通信和跨机器的通信。在进行本地通信时，通信双方通常使用本地回环地址（127.0.0.1），然后各自绑定在不同的端口上。操作系统网络协议栈会识别回环地址，将通信消息转发到目标端口对应的进程。此外，也可以用本地文件系统的一个路径作为地址，这通常被叫做 UNIX domain socket。使用套接字通常有两种协议，TCP 和 UDP。TCP 传输可以保证数据的正确性，UDP 则在传输性能上更佳。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://book.douban.com/subject/35208251/">《现代操作系统：原理与实现》</a>，陈海波，夏虞斌等著，机械工业出版社</p>]]></content>
    
    
    <categories>
      
      <category>计算机科学</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>操作系统（二）：进程与线程</title>
    <link href="/2021/03/12/OS-process-and-thread/"/>
    <url>/2021/03/12/OS-process-and-thread/</url>
    
    <content type="html"><![CDATA[<h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><p>为了管理操作系统中各种各样的程序，操作系统定义了进程（Process）的抽象：每个进程都对应于一个运行中的程序。为了使得多个进程可以同时执行，操作系统提出了上下文切换机制，通过保存和恢复进程在运行过程中的状态（即上下文），使进程可以暂停、切换、恢复，从而实现了 CPU 资源的共享。同时，使用虚拟内存机制，为每个进程都提供了独立的虚拟地址空间。</p><h2 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h2><p>为了对进程进行管理，首先需要定义进程的状态。一般来说，进程有以下几种状态。</p><ul><li><strong>新生状态</strong>：此时进程刚刚被创建出来，尚未完成初始化，不可以被调度。当完成初始化后，迁移至预备状态。</li><li><strong>预备状态</strong>：此时进程可以被调度，但是还没有被调度器选择。当被调度器选择时，迁移至运行状态。</li><li><strong>运行状态</strong>：此时进程正在 CPU 上运行。当调度器中断其执行并将其放回调度队列中时，其迁移至预备状态；当其运行结束时，迁移至终止状态；当其需要等待外部事件时，迁移至阻塞状态。</li><li><strong>阻塞状态</strong>：此时进程需要等待外部事件（例如某个 I&#x2F;O 请求的完成），暂时无法被调度。</li><li><strong>终止状态</strong>：此时进程已经完成了执行，不会再被调度。</li></ul><h2 id="进程的内存空间布局"><a href="#进程的内存空间布局" class="headerlink" title="进程的内存空间布局"></a>进程的内存空间布局</h2><p>如图所示，进程拥有独立的虚拟内存空间。</p><img src="进程内存布局.png" width="20%"><ul><li><strong>用户栈</strong>：用户栈保留了进程需要的各种临时数据，其扩展方向是自顶向下，栈底在高地址，栈顶在低地址。当有数据压入栈时，栈顶向低地址扩展。</li><li><strong>代码库</strong>：进程执行需要的共享代码库（比如 libc），其被标记为只读。</li><li><strong>用户堆</strong>：堆管理的时动态分配的内存，和栈相反，其扩展方向是自底向上。</li><li><strong>数据与代码段</strong>：数据段主要保存的是全局变量的值，代码段保存的是进程执行所需的代码。</li><li><strong>内核部分</strong>：每个进程的虚拟地址空间里都映射了相同的内核内存。当进程在用户态时，内核内存对其不可见；只有进程进入内核态时，才能访问内核内存。</li></ul><p>在 Linux 中，可以使用 <code>cat /proc/PID/maps</code> 来查看某个进程的内存布局。</p><h2 id="进程控制块"><a href="#进程控制块" class="headerlink" title="进程控制块"></a>进程控制块</h2><p>在内核中，每个进程都通过一个数据结构来描述其状态，这个数据结构成为进程控制块（Process Control Block，PCB）。在不同的操作系统中，PCB 所包含的内容也不一样。在 Linux 4.14 中 PCB 对应的数据结构 task_struct 所包含的部分内容如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> &#123;</span><br>  <span class="hljs-comment">// 进程状态</span><br>  <span class="hljs-keyword">volatile</span> <span class="hljs-type">long</span> state;<br>  <span class="hljs-comment">// 虚拟内存状态</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mm_struct</span> *<span class="hljs-title">mm</span>;</span><br>  <span class="hljs-comment">// 进程标识符</span><br>  <span class="hljs-type">pid_t</span> pid;<br>  <span class="hljs-comment">// 进程组标识符</span><br>  <span class="hljs-type">pid_t</span> tgid;<br>  <span class="hljs-comment">// 进程间关系</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> __<span class="hljs-title">rcu</span> *<span class="hljs-title">parent</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">children</span>;</span><br>  <span class="hljs-comment">// 打开的文件</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">files_struct</span> *<span class="hljs-title">files</span>;</span><br>  <span class="hljs-comment">// 其他状态（如上下文）</span><br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><p>进程的上下文（context）包括进程运行时的寄存器状态，其能够用于保存和恢复一个进程在处理器上的运行状态。当操作系统需要切换当前执行的进程时，就会使用上下文切换机制（context switch）。</p><h2 id="Linux-中的进程"><a href="#Linux-中的进程" class="headerlink" title="Linux 中的进程"></a>Linux 中的进程</h2><h3 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h3><p>在 Linux 中进程的创建一般使用 fork 接口，从已有的进程中“分裂”出来。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">pid_t</span> <span class="hljs-title function_">fork</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br></code></pre></td></tr></table></figure><p>fork 接口非常简单，不接收任何参数，返回的时当前进程的 PID。当一个进程调用 fork 时，操作系统会创建一个和该进程几乎一模一样的新进程。当 fork 刚刚完成时，两个进程的内存、寄存器、程序计数器等状态完全一致，但是这两个线程相互独立，拥有独立的虚拟内存空间和不同的 PID。在 fork 结束以后他们会独立执行，互不干扰。</p><p>在调用 fork 之后父子进程之间存在大量的共享，因此会造成很多不确定的行为。例如，假如父进程在 fork 之前打开了一个文件，fork 结束以后，这两个进程都会持有这个文件的文件描述符（File Descriptor）。文件描述符是操作系统提供的对于某一文件引用的抽象，会记录关于文件的一些信息，例如当前位置的偏移量。因此，假如这两个父子进程同时操作该文件，有可能会导致冲突。</p><p>除了简单的 fork 接口，Linux 中还有 clone 接口，其拓展了 fork。关于 fork 和 clone 的详细使用方法，可以参考<a href="https://blog.csdn.net/gatieme/article/details/51417488">Linux中fork，vfork和clone详解（区别与联系）</a>。</p><h3 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h3><h4 id="进程树"><a href="#进程树" class="headerlink" title="进程树"></a>进程树</h4><p>在 Linux 中，由于进程都是通过 fork 创建的，操作系统会以 fork 作为线索记录进程之间的关系。每个进程的 task_struct 都会记录自己的父进程与子进程，进程之间因此形成了进程树的结构。</p><img src="进程树.png" width="55%"><p>处于进程树根节点的是 init 进程，它是操作系统创建的第一个进程，之后所有的进程都是由它直接或间接 fork 出来的。</p><h4 id="进程间监控：wait"><a href="#进程间监控：wait" class="headerlink" title="进程间监控：wait"></a>进程间监控：wait</h4><p>在 Linux 中，进程可以使用 wait 操作来对其子进程进行监控。其由多个变种，这里介绍 <code>waitpid</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">pid_t</span> <span class="hljs-title function_">waitpid</span><span class="hljs-params">(<span class="hljs-type">pid_t</span> pid, <span class="hljs-type">int</span> *wstatus, <span class="hljs-type">int</span> options)</span>;<br></code></pre></td></tr></table></figure><p>其中第一个参数是需要等待的子进程 id，第二个参数会用来保存子进程状态，最后一个参数包含一些选项。父进程调用 <code>waitpid</code> 对子进程进行监控，如果子进程已经退出，那么 waitpid 会立即返回，并设置 status 变量的值；如果子进程还没有退出，则父进程会被阻塞，并等待子进程退出。</p><p>在 Linux 中，wait 操作不仅起到了监控的作用，还起到了回收已经结束的子进程和释放资源的作用。如果父进程没有调用 wait 操作，就算子进程已经终止了，它所占用的资源也不会完全释放，我们将这种进程成为<strong>僵尸进程</strong>。内核会为僵尸进程保留其进程描述符（PID）和终止时的信息（waitpid 中的 status），以便父进程在调用 wait 时可以监控子进程的状态。不过，如果父进程退出了，那么子进程的信息就不会再被父进程使用，也就没有必要继续保留它们了。此时，所有由父进程创建的僵尸进程都会被内核的第一个进程 init 通过调用 wait 的方式回收。</p><p>如果一个父进程调用了一个或若干个子进程，但是父进程在子进程结束之前就已经结束了，那么这些子进程就被成为<strong>孤儿进程</strong>，这些进程会被 init 进程收养。</p><h4 id="进程组和会话"><a href="#进程组和会话" class="headerlink" title="进程组和会话"></a>进程组和会话</h4><p>为了方便对进程进行管理，内核还定义了进程组和会话的概念。会话和进程组主要用于 Shell 环境中的进程管理。</p><p>进程组是进程的集合，可以由一个或多个进程组成。在默认的情况下，父进程和子进程属于同一个进程组。如果子进程想要脱离当前进程组，可以通过 <code>setpgid</code> 创建一个新的进程组或者移入一个已有的进程组。进程组的一大作用是体现在对信号的处理上，应用程序可以调用 <code>killpg</code> 向一个进程组发送信号，这个信号会被发给该进程组的所有进程。</p><p>会话是进程组的集合，可以由一个或多个进程组组成。会话将进程组根据执行状态分为前台进程组和后台进程组。</p><h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><p>在早期的操作系统中，进程是调度的最小单元。随着程序并行性的提高，操作系统需要对程序进行更加细粒度的调度，于是就产生了线程（thread）的概念。同一进程下的所有线程共享进程的地址空间，但又各自保留运行时所需的状态（上下文）。在现代操作系统中，线程取代了进程，成为了操作系统调度的最小单位。</p><h2 id="线程内存布局"><a href="#线程内存布局" class="headerlink" title="线程内存布局"></a>线程内存布局</h2><img src="多线程内存布局.png" width="20%"><p>上图是包含三个线程的进程地址空间，其有两个重要特征：</p><ul><li><strong>分离的内核栈和用户栈</strong>：进程为每个线程都准备了不同的栈，供它们存放临时数据。在内核中，每个线程也有对应的内核栈。</li><li><strong>共享的其他区域</strong>：除了栈，进程中的所有其他区域都由该进程的所有线程共享，包括堆、数据段、代码段等。</li></ul><h2 id="用户态线程和内核线程"><a href="#用户态线程和内核线程" class="headerlink" title="用户态线程和内核线程"></a>用户态线程和内核线程</h2><p>根据线程是由用户应用创建还是内核创建，可以将其分为两类：用户态线程和内核态线程。内核态线程由内核创建，受操作系统调度器管理。用户态线程则是应用创建的，内核不可见，不受操作系统调度器管理。用户态线程中与内核相关的功能（如系统调用）需要内核线程协助才能完成。为了使用户态线程与内核态线程相互协作，操作系统会建立两者之间的关系。一般来说，主要由三种模型：多对一、一对一和多对多。</p><ul><li><strong>多对一</strong>：该模型中一个内核线程服务多个用户态线程，每次只能有一个用户态线程进入内核，其他需要内核服务的线程将被阻塞。随着多核机器的普及，这种模型已不再使用。</li><li><strong>一对一</strong>：该模型中每个用户态线程都有单独的内核态线程，其比一对一模型具有更好的拓展性。这种模型的缺点是，随着用户态线程的增多，创建内核态线程的开销会随之增大。因此，在实现该模型的操作系统中，都会限制用户态线程的总数量。Linux 和 Windows 使用的都是这种模型。</li><li><strong>多对多</strong>：多对多模型将 $N$ 个用户态线程映射到 $M$ 个内核态线程上，其中 $N&gt;M$。这种模型既减轻了多对一模型中因为内核线程数量过少而导致的阻塞问题，也解决了一对一模型中因为内核态线程过多而导致的性能问题。但是这种模型会使得内核态线程的管理变得复杂。macOS 和 iOS 使用的面向用户体验的调度器 GCD 采用了这一种模型。</li></ul><h2 id="线程接口"><a href="#线程接口" class="headerlink" title="线程接口"></a>线程接口</h2><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>在 POSIX 线程库中，使用 <code>pthread_create</code> 函数来创建线程。 其接受四个参数，分别是线程的引用、线程的属性、线程开始运行的函数、线程运行的参数。</p><h3 id="退出"><a href="#退出" class="headerlink" title="退出"></a>退出</h3><p>在 POSIX 线程库中，使用 <code>pthread_exit</code> 函数来退出线程。但是这个调用并不是必要的，当线程运行结束后，<code>pthread_exit</code> 会被隐式地调用。</p><h3 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h3><p>在多线程场景中，有可能会出现几个线程之间相互依赖的情况。因此，线程库中提供了合并（join）操作的函数 <code>pthread_join</code>，其允许一个线程等待另一个线程的执行，并获取其执行的结果。</p><h3 id="挂起"><a href="#挂起" class="headerlink" title="挂起"></a>挂起</h3><p>pthread 中没有专门挂起的函数，此时可以使用 <code>sleep</code> 函数完成挂起操作。调用该函数后，该线程会处于阻塞状态，等到睡眠结束后将转为预备状态，但是此时并不一定会被调度器选择，因此在睡眠结束之后并不一定会立即被执行。<br>还有一种挂起是等待某种事件，线程在挂起之前指明等待的具体时间。在 pthreads 中，对应的接口是 <code>pthread_cond_wait</code>。</p><h1 id="纤程"><a href="#纤程" class="headerlink" title="纤程"></a>纤程</h1><p>由于主流的操作系统都使用一对一的线程模型，用户态线程和内核态线程具有一对一的关系，因此可以认为用户态线程的执行几乎完全收到操作系统调度器的管理。<br>但是，随着程序越来越复杂，应用的设计者可能更能优化调度的性能。因此，操作系统开始提供更多对用户态线程，即<strong>纤程</strong>的支持。因为纤程不是操作系统调度的单位，纤程的调度和切换不需要通过操作系统。更多关于纤程的介绍，可以参考<a href="https://en.wikipedia.org/wiki/Fiber_(computer_science)">Wikipedia</a></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>《现代操作系统：原理与实现》第 5 章，陈海波，夏虞斌等著</p>]]></content>
    
    
    <categories>
      
      <category>计算机科学</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>操作系统（一）：内存</title>
    <link href="/2021/03/11/OS-memory/"/>
    <url>/2021/03/11/OS-memory/</url>
    
    <content type="html"><![CDATA[<h1 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h1><p>为了让每个应用都可以高效又安全地使用物理内存，现代操作系统中会在应用程序和物理内存之间加入一层新的抽象：虚拟内存。应用程序在编写时仅考虑虚拟内存，CPU 在运行时将应用程序的虚拟内存地址翻译成物理内存地址，操作系统负责设置虚拟地址与物理地址之间的映射。</p><p>虚拟内存的设计有以下三个目标：</p><ul><li>高效性：虚拟内存不能在程序运行过程中造成明显的性能开销，且虚拟内存抽象也不应该占用过多的物理内存资源。</li><li>安全性：虚拟内存应使得不同应用程序之间的内存相互隔离。</li><li>透明性：应用程序开发者在变成时无需考虑虚拟内存抽象。</li></ul><h2 id="虚拟内存的翻译"><a href="#虚拟内存的翻译" class="headerlink" title="虚拟内存的翻译"></a>虚拟内存的翻译</h2><p>在使用虚拟内存的情况下，CPU 取指令时发出的时指令的虚拟地址，该虚拟地址被内存管理单元（Memory Management Unit，MMU）翻译为对应的物理地址，包含改物理地址的内存读请求被发送到物理内存设备，然后物理内存设备把该物理地址对应的内容发送给 CPU。为了加速翻译，现代 CPU 都引入了转址旁路缓存（Translation Lookaside Buffer，TLB）。</p><p>MMU 将虚拟地址翻译为物理地址的主要机制有两种：分段机制与分页机制，下面分别介绍。</p><h3 id="基于分段的虚拟地址"><a href="#基于分段的虚拟地址" class="headerlink" title="基于分段的虚拟地址"></a>基于分段的虚拟地址</h3><p>在分段机制中，操作系统以“段”的形式管理物理内存。CPU 访问虚拟内存空间中某一个段时，MMU 会通过查询<strong>段表</strong>得到该段对应的物理地址区域。</p><img src="虚拟内存翻译-段.png" width="65%"><p>虚拟地址由两个部分构成：高位的段号和低位的段内偏移。在翻译时，MMU 首先通过段表基地址寄存器找到段表的位置，结合虚拟地址中的段号，找到对应物理段的信息；然后取出该段的起始地址（物理地址），加上待翻译虚拟地址中的段地址（偏移量），就能够得到最终的物理地址。</p><p>在分段机制下，不仅虚拟内存空间被划分成不同的段，物理内存也以段为单位进行分配。这种段式分配方式容易导致在物理内存中出现外部碎片，即在段与段之间留下碎片空间，从而造成物理内存资源利用率的降低。</p><h3 id="基于分页的虚拟地址"><a href="#基于分页的虚拟地址" class="headerlink" title="基于分页的虚拟地址"></a>基于分页的虚拟地址</h3><h4 id="虚拟地址翻译"><a href="#虚拟地址翻译" class="headerlink" title="虚拟地址翻译"></a>虚拟地址翻译</h4><p>在 x86-64 架构之后，基于分页机制的虚拟内存已经成为主流。分页机制的思想是将虚拟内存地址空间划分成连续的、等长的虚拟页（显著区别于分段机制下不同长度的段），同时物理内存也被划分为连续的、等长的物理页。虚拟页和物理页的页长固定且相等，操作系统可以很方便地为每个应用程序构造<strong>页表</strong>，即虚拟页到物理页的映射关系表。类似于分段机制下的虚拟地址，分页机制下的虚拟地址分为两个部分：高位的页号和低位的页内地址。</p><img src="虚拟内存翻译-页.png" width="65%"><p>在翻译时，MMU 首先解析得到虚拟地址中的虚拟页号，然后通过页表基地址寄存器找到页表，查询该虚拟页号对应的物理页号，最后用该物理页号对应的物理页的起始地址加上虚拟地址中的页内偏移得到最终的物理地址。</p><p>在分页机制下，连续的虚拟页可以对应离散的物理页，因此可以实现物理内存资源的离散分配。并且，分页机制按照固定页大小分配物理内存，可以有效避免分段机制中的外部碎片。</p><h4 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h4><p>页表是分页机制中的关键部分，如果仅使用一张简单的页表来记录映射关系，那么对于 64 位的虚拟地址空间，假设一个页的大小为 4 KB，页表中每一项的大小为 8 字节，那么这个页表的大小就是 $2^{64}&#x2F;4 KB * 8$ 字节，即 33554432 GB。显然，这是不可接受的。因此，人们又设计出了多级页表来节省页表所占用的空间。</p><img src="虚拟内存翻译-多级页.png" width="65%"><p>在使用多级页表时，一个虚拟地址中仍然可以划分为页号和页内偏移量。但是页号被进一步划分成 k 个部分，每一个部分对应着其在每一级页表中所对应的项。在多级页表中，除了最后一级页表中的项是映射到物理页，其余的页表都映射到下一级页表上。注意，在 0 到 k - 1 级页表中，其条目可以为空，该空条目的子页表也就不存在。换句话说，多级页表允许在整个页表结构中出现空洞，而单级页表则不允许。在实际使用中，大多数虚拟地址空间都是未分配的，因此多级页表可以部分创建，进而节省内存空间。</p><h4 id="TLB"><a href="#TLB" class="headerlink" title="TLB"></a>TLB</h4><p>多级页表可以压缩页表的大小，但是会增加虚拟地址翻译的延迟。所以人们在 MMU 中加入了转址旁路缓存（TLB）来加速翻译的过程。TLB 相当于一个哈希表，将虚拟页号映射到物理页号上。考虑虚拟地址 VA，其在应用 A 和应用 B 中所对应的物理页是不同的，因此操作系统在切换应用程序时需要刷新 TLB 。</p><h2 id="虚拟内存的管理"><a href="#虚拟内存的管理" class="headerlink" title="虚拟内存的管理"></a>虚拟内存的管理</h2><h3 id="换页与缺页异常"><a href="#换页与缺页异常" class="headerlink" title="换页与缺页异常"></a>换页与缺页异常</h3><p>如果虚拟页没有被分配使用，那么页表中自然没有对应的物理页映射。反过来，被分配使用的虚拟页在页表中一定有相应的物理页映射吗？答案是否定的。</p><p>虚拟内存中存在换页机制。该机制的基本思想是：当物理内存容量不够的时候，操作系统把若干物理页写入磁盘中，然后回收物理页。当操作系统希望从应用程序 A 回收物理页 P （对应 A 的虚拟页 V）时，其会将物理页 P 的内容写入磁盘中一个位置，并且在应用程序 A 的页表中去除虚拟页 V 的映射，同时记录该物理页写入磁盘时的位置。这一过程叫做换出。此时，虚拟页 V 就处于已分配但未映射的状态。</p><p>当程序访问到已分配但未映射的虚拟页时，就会触发缺页异常，此时会运行操作系统预先定义的缺页异常处理函数。该函数会找到一个空闲的物理页，将磁盘中的数据重新加载到该物理页中，并且在页表中填写虚拟地址到该物理页的映射。这一过程被称为换入。</p><h3 id="换页策略"><a href="#换页策略" class="headerlink" title="换页策略"></a>换页策略</h3><p>常见的换页策略有：FIFO 策略、Second Chance 策略、LRU 策略、MRU 策略、时钟算法策略。</p><h4 id="FIFO-策略"><a href="#FIFO-策略" class="headerlink" title="FIFO 策略"></a>FIFO 策略</h4><p>FIFO 策略优先选择最先换入的页进行换出。操作系统维护一个队列，每换入一个页就将其加入队尾，需要换出页时则从队列头选择页。这种算法在实际中表现不佳，也几乎不会被现代操作系统采用。</p><h4 id="Second-Chance-策略"><a href="#Second-Chance-策略" class="headerlink" title="Second Chance 策略"></a>Second Chance 策略</h4><p>Second Chance 策略是 FIFO 策略的改进版。其在每个记录的物理页上增加了一个访问标志位，在寻找需要换出的内存页时，该策略优先查看位于队头的内存页。如果该内存页的访问标志位没有被置上，则换出该页；否则，将其标志位清空，并将其挪到队尾，然后继续从队头寻找符合条件的内存页。</p><h4 id="LRU-策略"><a href="#LRU-策略" class="headerlink" title="LRU 策略"></a>LRU 策略</h4><p>LRU 策略会记录每个物理页被访问的时间，在寻找物理页进行换出时，优先选择那些最久未被访问的物理页。</p><h4 id="MRU-策略"><a href="#MRU-策略" class="headerlink" title="MRU 策略"></a>MRU 策略</h4><p>MRU 策略和 LRU 策略相反，在寻找物理页进行换出时，会优先选择那些最近被访问的物理页。</p><h4 id="时钟算法策略"><a href="#时钟算法策略" class="headerlink" title="时钟算法策略"></a>时钟算法策略</h4><p>时钟算法将换入物理内存的页号排成一个时钟的形状。该时钟有一个针臂，指向新换入内存的页号的后一个。同时，也为每个页号维护一个访问标志位。每次需要选择换出页号时，该算法从针臂所指的页号开始检查。如果当前页号的访问位没有设置，则将该页换出；否则，将其访问标志位清空，并将针臂顺时针移动到下一个页号。时钟算法策略类似 Second Chance 策略，但实现上更高效些。</p><h1 id="物理内存"><a href="#物理内存" class="headerlink" title="物理内存"></a>物理内存</h1><h2 id="物理内存的分配"><a href="#物理内存的分配" class="headerlink" title="物理内存的分配"></a>物理内存的分配</h2><p>物理内存的分配有两个评价指标：内存资源利用率、分配性能。内存资源利用率要求分配机制可以减少内部碎片和外部碎片的大小；分配性能要求分配机制尽可能降低分配延迟和节约 CPU 资源。</p><h3 id="伙伴系统"><a href="#伙伴系统" class="headerlink" title="伙伴系统"></a>伙伴系统</h3><p>伙伴系统是现代操作系统中广泛使用的机制。其基本思想是将物理内存划分成连续的块，以块为单位进行分配。不同块的大小可以不同，但每个块都有一个或多个连续的物理页组成，物理页的数量必须是 2 的 n 次幂（$0 \le n &lt;$ 预设的最大值）。当一个请求需要分配 m 个物理页时，伙伴系统将寻找一个大小合适的块，该块包括 $2^n$ 个物理页，且满足 $2^{n-1} &lt; m \le 2^{n}$。在处理分配请求的过程中，大的块可以分裂成两半，这两个块互为伙伴。分裂得到的块可以继续分裂，直到一个大小合适的块去服务相应的分配请求。在一个块被释放后，分配器会找到其伙伴块，若伙伴块也处于空闲的状态，则可以将这两个块进行合并，合并得到的块可以进一步向上合并。由于分裂操作和合并操作都是级联的，因此可以很好地解决外部碎片的问题。</p><img src="虚拟内存翻译-空闲链表.png" width="45%"><p>在实际中，常用空闲列表去实现伙伴系统。具体来说，全局有一个有序数组，其每一项都指向一条空闲链表，每条链表将其对应大小的空闲块连接起来（一条链表中的空闲块大小相同）。当收到分配请求之后，伙伴分配器首先计算应该分配多大的空闲块，然后查找对应的空闲链表。例如，请求的大小是 15 KB，则应该分配一个 16 KB 的块。因此首先查找第二条 $2^2$ 空闲链表，如果链表不为空，则取出头节点的空闲块分配即可。但是在图中该链表为空，则继续访问第三条 $2^3$ 空闲链表，取出一个空闲块（32 KB），将其分裂成两个 16 KB 的空闲块，一块用于服务请求，另一个则插入 $2^2$ 这条空闲链表中。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://item.jd.com/12731379.html">现代操作系统：原理与实现</a>第 4 章</p>]]></content>
    
    
    <categories>
      
      <category>计算机科学</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Windows 下使用 Visual Studio 2019 进行 CUDA 编程</title>
    <link href="/2020/12/04/CUDA-PROGRAMMING-IN-WINDOWS/"/>
    <url>/2020/12/04/CUDA-PROGRAMMING-IN-WINDOWS/</url>
    
    <content type="html"><![CDATA[<h2 id="CUDA-安装"><a href="#CUDA-安装" class="headerlink" title="CUDA 安装"></a>CUDA 安装</h2><p>CUDA 的安装比较简单，下载了安装包以后一直点 Next 就行了，可以参考<a href="https://blog.csdn.net/letutu/article/details/81237081">这个博客</a>。</p><p>安装完以后对 CUDA 进行一下测试，在命令行执行 <code>nvcc -V</code> 得到下面的结果说明安装成功</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dns">$ nvcc -V<br>nvcc: NVIDIA (R) Cuda compiler driver<br>Copyright (c) <span class="hljs-number">2005-2019</span> NVIDIA Corporation<br>Built on Fri_Feb__8_19:<span class="hljs-number">08</span>:<span class="hljs-number">26</span>_Pacific_Standard_Time_2019<br>Cuda compilation tools, release <span class="hljs-number">10</span>.<span class="hljs-number">1</span>, V<span class="hljs-number">10.1.105</span><br></code></pre></td></tr></table></figure><h2 id="Visual-Studio-配置"><a href="#Visual-Studio-配置" class="headerlink" title="Visual Studio 配置"></a>Visual Studio 配置</h2><p>网上很多博客中，在 Visual Studio 中新建项目时都会有一个 NVIDIA 的模板，但是我在新建时并没有看到。所以我直接新建空白项目，然后为项目添加 CUDA 的依赖项。</p><img src="1.jpg" style="zoom:40%"><img src="2.png" style="zoom:60%"><p>然后在源文件中添加新建项，以 <code>.cu</code> 结尾，这里是 <code>test.cu</code>。然后对文件属性进行设置<br><img src="3.jpg" style="zoom:40%"></p><p>设置内容为 <code>配置属性-常规-项类型-CUDA C/C++</code>。</p><p>然后对项目属性进行配置。首先在 <code>配置属性-VC++ 目录-包含目录</code> 中添加 <code>$(CUDA_PATH)\include</code>，然后在 <code>配置属性-VC++ 目录-包含目录</code> 中添加 <code>$(CUDA_PATH)\lib\x64</code>，在 <code>配置属性-链接器-常规-附加库目录</code> 中添加 <code>$(CUDA_PATH)\lib\x64</code>，最后在 <code>配置属性-链接器-输入-附加依赖库</code> 中添加 </p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal">cublas.<span class="hljs-keyword">lib</span>;cublasLt.<span class="hljs-keyword">lib</span>;cuda.<span class="hljs-keyword">lib</span>;cudadevrt.<span class="hljs-keyword">lib</span>;cudart.<span class="hljs-keyword">lib</span>;cudart_static.<span class="hljs-keyword">lib</span>;cudnn.<span class="hljs-keyword">lib</span>;cudnn64_8.<span class="hljs-keyword">lib</span>;cudnn_adv_infer.<span class="hljs-keyword">lib</span>;cudnn_adv_infer64_8.<span class="hljs-keyword">lib</span>;cudnn_adv_train.<span class="hljs-keyword">lib</span>;cudnn_adv_train64_8.<span class="hljs-keyword">lib</span>;cudnn_cnn_infer.<span class="hljs-keyword">lib</span>;cudnn_cnn_infer64_8.<span class="hljs-keyword">lib</span>;cudnn_cnn_train.<span class="hljs-keyword">lib</span>;cudnn_cnn_train64_8.<span class="hljs-keyword">lib</span>;cudnn_ops_infer.<span class="hljs-keyword">lib</span>;cudnn_ops_infer64_8.<span class="hljs-keyword">lib</span>;cudnn_ops_train.<span class="hljs-keyword">lib</span>;cudnn_ops_train64_8.<span class="hljs-keyword">lib</span>;cufft.<span class="hljs-keyword">lib</span>;cufftw.<span class="hljs-keyword">lib</span>;curand.<span class="hljs-keyword">lib</span>;cusolver.<span class="hljs-keyword">lib</span>;cusparse.<span class="hljs-keyword">lib</span>;nppc.<span class="hljs-keyword">lib</span>;nppial.<span class="hljs-keyword">lib</span>;nppicc.<span class="hljs-keyword">lib</span>;nppicom.<span class="hljs-keyword">lib</span>;nppidei.<span class="hljs-keyword">lib</span>;nppif.<span class="hljs-keyword">lib</span>;nppig.<span class="hljs-keyword">lib</span>;nppim.<span class="hljs-keyword">lib</span>;nppist.<span class="hljs-keyword">lib</span>;nppisu.<span class="hljs-keyword">lib</span>;nppitc.<span class="hljs-keyword">lib</span>;npps.<span class="hljs-keyword">lib</span>;nvblas.<span class="hljs-keyword">lib</span>;nvgraph.<span class="hljs-keyword">lib</span>;nvml.<span class="hljs-keyword">lib</span>;nvrtc.<span class="hljs-keyword">lib</span>;OpenCL.<span class="hljs-keyword">lib</span><br></code></pre></td></tr></table></figure><p>实际上上面这些就是 <code>$(CUDA_PATH)\lib\x64</code> 下的所有 lib 文件的文件名，每个版本的 CUDA 所包括的 lib 文件各不相同，我这里是 CUDA 10.1 版本的 lib 文件。</p><p>配置完以后就可以编译运行 <code>.cu</code> 文件了，打开 <code>main.cu</code>，输入以下测试代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;cuda.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;cuda_runtime.h&quot;</span></span><br><br><span class="hljs-function">__global__ <span class="hljs-type">void</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello world from device\n&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    hello &lt;&lt; &lt;<span class="hljs-number">1</span>, <span class="hljs-number">1</span> &gt;&gt; &gt; ();<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello world from host\n&quot;</span>);<br>    <span class="hljs-built_in">cudaDeviceSynchronize</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>得到结果</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">Hello world <span class="hljs-keyword">from</span> host<br>Hello world <span class="hljs-keyword">from</span> device<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>环境配置</category>
      
      <category>CUDA 编程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Distilling a Nerual Network Into a Soft Decision Tree 翻译</title>
    <link href="/2020/11/19/Distilling-a-Nerual-Network-Into-a-Soft-Decision-Tree/"/>
    <url>/2020/11/19/Distilling-a-Nerual-Network-Into-a-Soft-Decision-Tree/</url>
    
    <content type="html"><![CDATA[<p>下面是我对《<a href="https://arxiv.org/abs/1711.09784">Distilling a Nerual Network Into a Soft Decision Tree</a>》的简单翻译</p><h1 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h1><p>深度神经网络在分类任务上有很出色的表现，但是却非常难解释其对一个具体的测例做出分类的原因。这是因为他们非常依赖于分布式的分层表示。如果我们将从神经网络中获取到的知识用一个依赖于分层决定的模型来进行表示，解释一个具体的决定会变得更加容易。我们提出了一种使用训练好的神经网络来创建一种软决策树的方法，其比直接从训练数据中学到的模型泛化的更好。</p><h1 id="Introdcution"><a href="#Introdcution" class="headerlink" title="Introdcution"></a>Introdcution</h1><p>深度神经网络优秀的泛化能力取决于它们隐藏层中的分布式表示，但是这种表示非常难被理解。对于第一个隐藏层，我们可以理解使一个神经元激活的原因；对最后一个隐藏层，我们可以理解激活一个神经元的效果；但是对于其他隐藏层，我们很难从有意义的变量的角度，如输入变量和输出变量，来理解特征激活的原因和影响。而且，隐藏层中的神经元将输入的向量分解为一组特征激活，通过这样的方式这些激活特征的组合效果可以在下一个隐藏层中产生一种合适的分布式表示。这使得很难单独地理解任何特定的特征激活的效果，因为其边际效应取决于同一隐藏层中的所有其他神经元的效果。</p><p>深度神经网络可以通过模拟训练数据中输入和输出之间的大量弱统计规律来做出可靠的决定，并且神经网络中没有任何东西可以区分数据集中真实的弱规律性和训练集采样特性导致的虚假规律性，这进一步加剧了上述的困难。面对这些困难，放弃通过理解单个隐藏单元的行为来理解深度神经网络是如果做分类决策的想法看起来是明智。</p><p>相比之下，决策树是如何进行任何特定的分类是很容易进行解释的，因为每个分类取决于一个相对较短的决策序列，并且每个决策都是直接基于输入数据的。但是，决策树通常并没有深度神经网络泛化的好。不同于神经网络中的隐藏神经元，决策树中一个特定的低层节点只被非常少的训练数据使用。因此，除非训练集的大小和树的深度相比呈指数增长，否则决策树的底层部分会趋于过拟合。</p><p>在这篇文章中，我们提出了一种解决泛化性和可解释性之间矛盾的新方法。不同于尝试去理解一个深度神经网络是如何做出决策的，我们使用深度神经网络来训练一个决策树，其模仿神经网络发现的输入-输出函数，但以一种完全不同的方式工作。如果有非常多的无标记数据，则可以使用神经网络创建更大的标记数据集来训练决策树，从而克服决策树统计效率低下的问题。即使没有无标记数据，也可以使用最近先进的生成模型从一个接近于数据分布的分布中来生成合成的无标记数据。即使不适用无标记数据，也仍然可能使用一种叫分馏（distillation）的技术和一种做软决策的决策树来将神级网络中的泛化性转移到决策树中。</p><p>在测试时，我们使用了决策树作为模型。这可能会比神经网络表现的差一些，但是决策树会更快，并且我们有了一个可以解释并直接参与决策的模型。我们从描述我们所使用的特定类型的决策树开始。这个选择是为了便于将深度神经网络获取的知识轻松地提取到决策树中。</p>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>HTML基本语法及使用</title>
    <link href="/2019/07/01/HTML/"/>
    <url>/2019/07/01/HTML/</url>
    
    <content type="html"><![CDATA[<h1 id="HTML简介"><a href="#HTML简介" class="headerlink" title="HTML简介"></a>HTML简介</h1><p>HTML全程为Hyper Text Markup Language，翻译过来是超文本标记语言。所谓的超文本，包含了普通文本、图片、标题、表格、链接等。HTML是前端中最常使用的三个语言之一，一般由其组成网页的骨干。</p><h1 id="HTML示例"><a href="#HTML示例" class="headerlink" title="HTML示例"></a>HTML示例</h1><p>下面有一段简单的HTML代码。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs HTML"><span class="hljs-meta">&lt;!doctype <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>页面标题<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>一级标题<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>段落内容<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>将这一段代码保存为 .html 文件，并用浏览器打开，会得到以下的页面。<br><img src="/example.png" alt="example"></p><h1 id="HTML语法"><a href="#HTML语法" class="headerlink" title="HTML语法"></a>HTML语法</h1><p>简单来说，HTML语言是由一对对的标签组成的。在上面的例子中，我们有 <code>&lt;html&gt;</code> 和 <code>&lt;/html&gt;</code> 这一对标签，其中间的内容是 HTML 文件的主要内容；<code>&lt;h1&gt;</code> 和 <code>&lt;/h1&gt;</code> 两个标签表明他们中间的内容为一级标题，等等。当然，我们也发现了有像 <code>&lt;meta&gt;</code> 这样的单标签，没有响应的另一标签和其对应。</p><p>下面，根据 HTML 标签中的不同种类对其进行介绍。</p><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><table><thead><tr><th>标题等级</th><th>标签</th><th>效果</th></tr></thead><tbody><tr><td>一级标题</td><td><code>&lt;h1&gt;xxx&lt;\h1&gt;</code></td><td><h1>一级标题</td></tr><tr><td>二级标题</td><td><code>&lt;h2&gt;xxx&lt;\h2&gt;</code></td><td><h2>二级标题</td></tr><tr><td>三级标题</td><td><code>&lt;h3&gt;xxx&lt;\h3&gt;</code></td><td><h3>三级标题</td></tr><tr><td>四级标题</td><td><code>&lt;h4&gt;xxx&lt;\h4&gt;</code></td><td><h4>四级标题</td></tr><tr><td>五级标题</td><td><code>&lt;h5&gt;xxx&lt;\h5&gt;</code></td><td><h5>五级标题</td></tr><tr><td>六级标题</td><td><code>&lt;h6&gt;xxx&lt;\h6&gt;</code></td><td><h6>六级标题</td></tr></tbody></table><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>有序列表：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">ol</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>阿凡达<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>泰坦尼克号<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>复仇者联盟<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ol</span>&gt;</span><br></code></pre></td></tr></table></figure><p>效果如下：</p><div style="line-height:12px"><ol>    <li>阿凡达</li>    <li>泰坦尼克号</li>    <li>复仇者联盟</li></ol></div><p>无序列表</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>葡萄<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>西瓜<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>苹果<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br></code></pre></td></tr></table></figure><p>效果如下：</p><div style="line-height:12px"><ul>    <li>葡萄</li>    <li>西瓜</li>    <li>苹果</li></ul></div><p>定义列表：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">dl</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">dt</span>&gt;</span>计算机<span class="hljs-tag">&lt;/<span class="hljs-name">dt</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>用来计算的仪器 ... ...<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">dt</span>&gt;</span>显示器<span class="hljs-tag">&lt;/<span class="hljs-name">dt</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>以视觉方式显示信息的装置 ... ...<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dl</span>&gt;</span><br></code></pre></td></tr></table></figure><p>效果如下：</p><div style="line-height:13px"><dl>   <dt>计算机</dt>   <dd>用来计算的仪器 ... ...</dd>   <dt>显示器</dt>   <dd>以视觉方式显示信息的装置 ... ...</dd></dl></div><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>链接用于外链到其他网站，使用方法如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;http://www.tsinghua.edu.cn&quot;</span>&gt;</span><br>清华大学<br><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><p>效果如下：<br><a href="http://www.tsinghua.edu.cn"><br>清华大学<br></a></p><h2 id="多媒体"><a href="#多媒体" class="headerlink" title="多媒体"></a>多媒体</h2><p>多媒体包括图片、音频、视频等等多媒体文件。</p><p>图片：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> </span><br><span class="hljs-tag"> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://p0.ssl.qhimg.com/t0142620c6328f7ab7d.jpg&quot;</span></span><br><span class="hljs-tag"> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;Metal movable type&quot;</span></span><br><span class="hljs-tag"> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;400&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p>效果：<br><img  src="https://p0.ssl.qhimg.com/t0142620c6328f7ab7d.jpg" alt="Metal movable type" width="400"></p><p>音频：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">audio</span></span><br><span class="hljs-tag"><span class="hljs-attr">controls</span></span><br><span class="hljs-tag"><span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://s2.ssl.qhres.com/static/cbf0c6b1ea11e72b.ogg&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">audio</span>&gt;</span><br></code></pre></td></tr></table></figure><p>效果：<br><audiocontrolssrc="https://s2.ssl.qhres.com/static/cbf0c6b1ea11e72b.ogg"><br></audio></p><p>视频：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">video</span></span><br><span class="hljs-tag">  <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://s2.ssl.qhres.com/static/eb04e248864ac1a8.mp4&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">controls</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">video</span>&gt;</span><br></code></pre></td></tr></table></figure><p>效果：<br><video  src="https://s2.ssl.qhres.com/static/eb04e248864ac1a8.mp4"  controls><br></video></p><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><p>HTML中输入使用的是<code>&lt;input&gt;</code>标签，但是赋予不同的属性之后会得到不一样的效果。</p><p>最简单的输入标签如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><p>效果为：<br>    <input></p><p>如果我们要在输入框中添加一些提示，则可以这样做：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;请输入用户名&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><p>效果如下：<br><input placeholder="请输入用户名"></p><p>如果我们要让用户输入一个范围，那我们可以指定标签的类型。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;range&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><p>效果如下：<br><input type="range"></p><p>如果我们要用户输入一个数字，并且这个数字有一定的范围，那我们可以指定这个标签的更多属性</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;number&quot;</span> <span class="hljs-attr">min</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">max</span>=<span class="hljs-string">&quot;10&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;3&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><p>效果如下：<br><input type="number" min="1" max="10" value="3"></p><p>如果我们要用户输入一个日期，并且也有一定的范围，同上面一样，我们可以这样做：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;date&quot;</span> <span class="hljs-attr">min</span>=<span class="hljs-string">&quot;2018-02-10&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><p>效果如下：<br><input type="date" min="2018-02-10"></p><p>如果我们用用户输入一系列文本，则应该使用<code>&lt;textarea&gt;</code>标签</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">textarea</span>&gt;</span>Hello<span class="hljs-tag">&lt;/<span class="hljs-name">textarea</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><p>效果如下：</p><textarea>Hello</textarea><h2 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h2><p>选择使用的是<code>checkbox</code>和<code>radio</code>两种属性。各自的效果如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span>&gt;</span> Apple<br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">checked</span>&gt;</span> Watermelon<br></code></pre></td></tr></table></figure><p>效果为：<br><input type="checkbox"> Apple<br><input type="checkbox" checked> Watermelon</p><p>另一种选择则是：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sport&quot;</span>&gt;</span> basketball<br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sport&quot;</span>&gt;</span> football<br></code></pre></td></tr></table></figure><p>效果为：<br><input type="radio" name="sport"> basketball<br><input type="radio" name="sport"> football</p><h2 id="文本标签"><a href="#文本标签" class="headerlink" title="文本标签"></a>文本标签</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">blockquote</span> <span class="hljs-attr">cite</span>=<span class="hljs-string">&quot;http://t.cn/RfjKO0F&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>天才并不是⾃⽣⾃⻓在深林荒野⾥的怪物， 是由可以使天才⽣⻓<br>的⺠众产⽣、⻓育出来的，所以没有 这种⺠众，就没有天才。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">blockquote</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>我最喜欢的⼀本书是<span class="hljs-tag">&lt;<span class="hljs-name">cite</span>&gt;</span>⼩王⼦<span class="hljs-tag">&lt;/<span class="hljs-name">cite</span>&gt;</span>。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>在<span class="hljs-tag">&lt;<span class="hljs-name">cite</span>&gt;</span>第⼀章<span class="hljs-tag">&lt;/<span class="hljs-name">cite</span>&gt;</span>，我们讲过<span class="hljs-tag">&lt;<span class="hljs-name">q</span>&gt;</span>字符串是不可变量<span class="hljs-tag">&lt;/<span class="hljs-name">q</span>&gt;</span>。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>const<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span>声明创建⼀个只读的常量。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">pre</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span><br>const add = (a, b) =&gt; a + b;<br>const multiply = (a, b) =&gt; a * b;<br><span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">pre</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>在投资之前，<span class="hljs-tag">&lt;<span class="hljs-name">strong</span>&gt;</span>⼀定要做⻛险评估<span class="hljs-tag">&lt;/<span class="hljs-name">strong</span>&gt;</span>。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><p>效果为：</p><div><blockquote cite="http://t.cn/RfjKO0F"><p>天才并不是⾃⽣⾃⻓在深林荒野⾥的怪物， 是由可以使天才⽣⻓的⺠众产⽣、⻓育出来的，所以没有 这种⺠众，就没有天才。</p></blockquote><p>我最喜欢的⼀本书是<cite>⼩王⼦</cite>。</p><p>在<cite>第⼀章</cite>，我们讲过<q>字符串是不可变量</q>。</p><p><code>const</code>声明创建⼀个只读的常量。</p><pre><code class="hljs">const add = (a, b) => a + b;const multiply = (a, b) => a * b;</code></pre><p>在投资之前，<strong>⼀定要做⻛险评估</strong>。</p></div><p><code>&lt;p&gt;</code>标签生成一个新的段落，<code>&lt;cite&gt;</code>用于标记斜体文字，<code>&lt;code&gt;</code>可以标注出文本中的代码，<code>&lt;strong&gt;</code>用以将指定文字粗体，<code>&lt;pre&gt;</code>用以生成一个文本框。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上就是比较常用的HTML标签，当然，制作一个网页只有HTML是不够的，往往还需要配合CSS和JavaScript才能制作出动态美观的网页。</p>]]></content>
    
    
    <categories>
      
      <category>网页前端</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>最长回文子序列问题</title>
    <link href="/2019/06/14/LPS/"/>
    <url>/2019/06/14/LPS/</url>
    
    <content type="html"><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p><strong>回文</strong>是正序与逆序相同的非空字符串。例如，所有长度为1的字符串、civic、racecar、aibohphobia（害怕回文之意）都是回文。</p><p>设计高效算法，求给定输入字符串的最长回文子序列。例如，给定输入 character，算法应该返回 carac。算法的运行时间是怎么样的？</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>本题出自《算法导论》第 15 章的思考题15-3。这道题可以使用暴力罗列的方法做，那么总共会有 $2^n$ 种情况，算法的复杂度也为 $O(2^n)$ ，其中 $n$ 为输入字符串的长度。</p><p>为了减小算法的复杂度，可以使用动态规划的方法解决。</p><p>给定任意一个输入串 $X &#x3D; {x_1, x_2, x_3, x_4… x_n}$，定义其子串 $X_{i,j} &#x3D; { x_i, x_{i+1}, x_{i+2}, …, x_j}$。设一个函数 $f(X_{i,j})$，其定义如下：</p><p>$$f(X_{i,j})&#x3D; 1 , X_{i,j}是回文序列 $$<br>$$f(X_{i,j})&#x3D; 0 , X_{i,j}不是回文序列$$</p><p>对于任意一个子串 $X_{i,j}$，分以下几种情况讨论：</p><p>$ x_i &#x3D; x_j $，则此时 $X_{i,j}$是否是回文子序列，与 $x_i$和 $x_j$无关，可以将其从 $ X_{ij} $中去除。如果 $X_{i+1, j-1} $是一个回文序列，则 $X_{i, j}$ 也是一个回文序列；如果 $X_{i+1, j-1} $不是一个回文序列，则 $X_{i, j}$也不是一个回文序列。例如，给定一个序列 $ 1w1 $，其中 $w$是一段字符串序列。由于这个序列左右两端是相同的，因此当 $w$是一个回文序列时， $1w1$才是一个回文序列；反之亦然。所以，我们可以给出如下式子：<br>$$ f(X_{i,j}) &#x3D; f(X_{i+1, j - 1}), x_i &#x3D; x_j$$</p><p>$ x_i \neq x_j$，则此时由于 $X_{i, j}$两端的字符不同，其当然不是回文序列。同上，我们有：<br>$$ f(X_{i,j}) &#x3D; 0, x_i \neq x_j$$</p><p>除此之外，我们还知道，一个只含有单个字符的字符串是回文序列；一个只有两个字符的字符串，即 $X_{i, i+1}$，如果有 $x_i &#x3D; x_{i+1} $，则其也是回文序列。</p><p>综上，我们给出 $f(X_{i, j})$的完整递归式：<br>$ f(X_{i, j}) &#x3D;  1 , i &#x3D; j  $<br>$f(X_{i, j}) &#x3D; 1 , x_i &#x3D; x_j, j &#x3D; i + 1 $<br>$  f(X_{i, j}) &#x3D;f(X_{i+1, j-1}) ,x_i &#x3D; x_j $<br>$f(X_{i, j}) &#x3D; 0 , x_i \neq x_j  $</p><p>我们不妨使用一个 $ n \times n $的矩阵来储存 $f(X_{i, j})$的值。我们给出如下伪代码：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs stylus"> <span class="hljs-built_in">LONGEST-PALINDROME-SUBSEQUENCE</span>(S)<br><span class="hljs-number">1</span>   n = S<span class="hljs-selector-class">.length</span><br><span class="hljs-number">2</span>   let <span class="hljs-selector-tag">p</span><span class="hljs-selector-attr">[1 ... n, 1 ... n]</span> be <span class="hljs-selector-tag">a</span> new <span class="hljs-selector-tag">table</span><br><span class="hljs-number">3</span>   <span class="hljs-keyword">for</span> <span class="hljs-selector-tag">i</span> = <span class="hljs-number">1</span> to n<br><span class="hljs-number">4</span>       <span class="hljs-keyword">for</span> j = <span class="hljs-number">1</span> to n<br><span class="hljs-number">5</span>           <span class="hljs-keyword">if</span> <span class="hljs-selector-tag">i</span> == j<br><span class="hljs-number">6</span>               <span class="hljs-selector-tag">p</span><span class="hljs-selector-attr">[i]</span><span class="hljs-selector-attr">[j]</span> = <span class="hljs-number">1</span><br><span class="hljs-number">7</span>           <span class="hljs-keyword">else</span><br><span class="hljs-number">8</span>               <span class="hljs-selector-tag">p</span><span class="hljs-selector-attr">[i]</span><span class="hljs-selector-attr">[j]</span> = <span class="hljs-number">0</span><br><span class="hljs-number">9</span>   <span class="hljs-keyword">for</span> <span class="hljs-selector-tag">i</span> = <span class="hljs-number">1</span> to n-<span class="hljs-number">1</span><br><span class="hljs-number">10</span>      <span class="hljs-keyword">for</span> j = <span class="hljs-number">1</span> to n-<span class="hljs-selector-tag">i</span><br><span class="hljs-number">11</span>          <span class="hljs-keyword">if</span> <span class="hljs-selector-tag">i</span> == <span class="hljs-number">1</span><br><span class="hljs-number">12</span>              <span class="hljs-keyword">if</span> S<span class="hljs-selector-attr">[j]</span> == S<span class="hljs-selector-attr">[j+1]</span><br><span class="hljs-number">13</span>                  <span class="hljs-selector-tag">p</span><span class="hljs-selector-attr">[j]</span><span class="hljs-selector-attr">[j+1]</span> = <span class="hljs-number">1</span><br><span class="hljs-number">14</span>          <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> x<span class="hljs-selector-attr">[j]</span> == x<span class="hljs-selector-attr">[j + i]</span><br><span class="hljs-number">15</span>              <span class="hljs-selector-tag">p</span><span class="hljs-selector-attr">[j]</span><span class="hljs-selector-attr">[j+i]</span> = <span class="hljs-selector-tag">p</span><span class="hljs-selector-attr">[j+1]</span><span class="hljs-selector-attr">[j+i-1]</span><br><span class="hljs-number">16</span>          <span class="hljs-keyword">else</span><br><span class="hljs-number">17</span>              <span class="hljs-selector-tag">p</span><span class="hljs-selector-attr">[j]</span><span class="hljs-selector-attr">[j+i]</span> = <span class="hljs-number">0</span><br><span class="hljs-number">18</span><br><span class="hljs-number">19</span>  max_length = -<span class="hljs-number">1</span>, <span class="hljs-attribute">left</span> = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span><br><span class="hljs-number">20</span>  <span class="hljs-keyword">for</span> <span class="hljs-selector-tag">i</span> = <span class="hljs-number">1</span> to n<br><span class="hljs-number">21</span>      <span class="hljs-keyword">for</span> j = <span class="hljs-number">1</span> to n<br><span class="hljs-number">22</span>          <span class="hljs-keyword">if</span> j - <span class="hljs-selector-tag">i</span> &gt; max_length<br><span class="hljs-number">23</span>              max_length = j - <span class="hljs-selector-tag">i</span><br><span class="hljs-number">24</span>              <span class="hljs-attribute">left</span> = i, right = j<br><span class="hljs-number">25</span>  return S<span class="hljs-selector-attr">[left:right]</span><br></code></pre></td></tr></table></figure><p>使用Python的实现如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np <br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">LPS</span>(<span class="hljs-params">s</span>):<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(s) &lt;= <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">return</span> s<br>    p = np.zeros((<span class="hljs-built_in">len</span>(s), <span class="hljs-built_in">len</span>(s)))<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s)):<br>        p[i][i] = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(s)):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s) - i):<br>            <span class="hljs-keyword">if</span> i == <span class="hljs-number">1</span>:<br>                <span class="hljs-keyword">if</span> s[j] == s[j+i]:<br>                    p[j][j+i] = <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">if</span> s[j] == s[j+i]:<br>                    p[j][j+i] = p[j+<span class="hljs-number">1</span>][j+i-<span class="hljs-number">1</span>]<br>                <span class="hljs-keyword">else</span>:<br>                    p[j][j+i] = <span class="hljs-number">0</span><br>    max_len = -<span class="hljs-number">1</span><br>    l, r = -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s)-<span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i, <span class="hljs-built_in">len</span>(s)):<br>            <span class="hljs-keyword">if</span> p[i][j] == <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> j - i &gt; max_len:<br>                l, r = i, j<br>                max_len = j - i<br>    <span class="hljs-keyword">return</span> s[l:r+<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><p>显然，该算法的复杂度为 $ O(n^2) $，远比暴力求解的 $O(2^n)$要好。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Pytorch使用Visdom可视化</title>
    <link href="/2018/03/11/visdom-1/"/>
    <url>/2018/03/11/visdom-1/</url>
    
    <content type="html"><![CDATA[<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script><h1 id="Visdom"><a href="#Visdom" class="headerlink" title="Visdom"></a>Visdom</h1><p>Visdom是Pytorch自带的一个可视化工具，能够在训练神经网络的过程中，将一些数据进行可视化。目前Visdom可以支持Numpy和Torch。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">$ pip <span class="hljs-keyword">install</span> visdom<br></code></pre></td></tr></table></figure><h2 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h2><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta">$ python -m visdom.<span class="hljs-keyword">server</span><br></code></pre></td></tr></table></figure><p>默认的端口号为8097，如果需要更改端口号，可以加入-p选项</p><h2 id="两个概念"><a href="#两个概念" class="headerlink" title="两个概念"></a>两个概念</h2><p>使用Visdom需要区分其中的一些概念，以将可视化环境分隔开</p><h3 id="Panes"><a href="#Panes" class="headerlink" title="Panes"></a>Panes</h3><p>Panes即窗格，其中可以显示具体的数据可视化内容。Panes可以进行拖放、删除等操作。</p><p><img src="/pane.png" alt="panes"></p><h3 id="env"><a href="#env" class="headerlink" title="env"></a>env</h3><p>env即Environment。Pane存放在env中，一个env中可以存放多个pane。默认的env为<code>main</code>，可以在初始化Visdom的时候指定env，如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> visdom <span class="hljs-keyword">import</span> Visdom<br><br>vis = Visdom()<br></code></pre></td></tr></table></figure><p>此时默认环境为<code>main</code></p><p>而假设想将环境改为<code>loss</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> visdom <span class="hljs-keyword">import</span> Visdom<br><br>vis = Visdom(env=<span class="hljs-string">&#x27;loss&#x27;</span>)<br></code></pre></td></tr></table></figure><p>则此时的visdom环境变成了<code>loss</code></p><h2 id="几个API"><a href="#几个API" class="headerlink" title="几个API"></a>几个API</h2><p>Visdom中提供了不同的API，来绘制不同类型的图像。</p><h3 id="plot-scatter"><a href="#plot-scatter" class="headerlink" title="plot.scatter"></a>plot.scatter</h3><p>plot.scatter 用来绘制2D或者3D的散点图，需要输入N * 2或者N * 3的tensor X来确定N个点的位置。</p><h3 id="plot-line"><a href="#plot-line" class="headerlink" title="plot.line"></a>plot.line</h3><p>这个API可以用来绘制线条。它需要一个形状为N或者N*M的tensorY，用来指定M条线的值（每条线上有N个点），和一个可选的tensorX来指定X轴的值。X可以是一个长度为N的tensor（此时M条线共享一个X），也可以是一个形状和tensorY相同的tensor。</p><h3 id="plot-image"><a href="#plot-image" class="headerlink" title="plot.image"></a>plot.image</h3><p>这个API用来画图像。输入</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-function"><span class="hljs-title">img</span>(<span class="hljs-variable">tensor</span>):<span class="hljs-title">shape</span>(<span class="hljs-variable">C</span> * <span class="hljs-variable">H</span> * <span class="hljs-variable">W</span>)</span><br></code></pre></td></tr></table></figure><h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> visdom <span class="hljs-keyword">import</span> visdom<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br>vis = Visdom(env=<span class="hljs-string">&#x27;test&#x27;</span>)<br>win = vis.line(<br>        X=np.zeros(<span class="hljs-number">1</span>),<br>        Y=np.zeros(<span class="hljs-number">1</span>),<br>        opts=<span class="hljs-built_in">dict</span>(title=<span class="hljs-string">&#x27;test_random&#x27;</span>)<br>)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100</span>):<br>    vis.line(<br>        X=np.array([i]),<br>        Y=np.random.randn(<span class="hljs-number">1</span>),<br>        win=win,<br>        update=<span class="hljs-string">&#x27;append&#x27;</span><br>    ) <span class="hljs-comment"># win要和之前的win保持一致，update选择append不会覆盖之前的数据</span><br></code></pre></td></tr></table></figure><p>效果：</p><p><img src="/test_random.png" alt="test"></p><h2 id="远程使用Visdom"><a href="#远程使用Visdom" class="headerlink" title="远程使用Visdom"></a>远程使用Visdom</h2><p>很多时候训练神经网络并不是在自己的电脑上进行，而是在远端的服务器上进行。下面介绍如何连接查看服务器端的visdom</p><h3 id="SSH连接"><a href="#SSH连接" class="headerlink" title="SSH连接"></a>SSH连接</h3><p>在命令行中输入</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">ssh</span> -L <span class="hljs-number">18097</span>:<span class="hljs-number">127.0.0.1:8097</span> username<span class="hljs-variable">@remote_ip</span><br></code></pre></td></tr></table></figure><p>其中，18097:127.0.0.1代表自己机器上的端口号，8097是服务器上visdom的端口号。username是在远程服务器上的用户名，remote_ip是服务器的ip地址。</p><p>效果：<br><img src="/remote.png" alt="remote"></p><h3 id="启动visdom服务器"><a href="#启动visdom服务器" class="headerlink" title="启动visdom服务器"></a>启动visdom服务器</h3><p>同上面介绍的一样，在服务器端启动visdom服务，输入</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta">$ python -m visdom.<span class="hljs-keyword">server</span><br></code></pre></td></tr></table></figure><h3 id="在本地浏览器中浏览"><a href="#在本地浏览器中浏览" class="headerlink" title="在本地浏览器中浏览"></a>在本地浏览器中浏览</h3><p>启动完远程的visdom服务之后，在本地浏览器中输入</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">127.0.0.1:18097</span><br></code></pre></td></tr></table></figure><p>即可访问服务器端的visdom</p>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
      <category>工具</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
